import {
  DataRouterContext,
  DataRouterStateContext,
  Navigate,
  Route,
  RouterProvider2,
  Routes,
  createHashRouter,
  createMemoryRouter,
  useBlocker,
  useInRouterContext,
  useLocation,
  useNavigate,
  useParams
} from "./chunk-Z7EIL4PA.js";
import {
  require_Stack,
  require_assignValue,
  require_baseAssignValue,
  require_baseClone,
  require_baseFlatten,
  require_baseFor,
  require_baseGet,
  require_baseRest,
  require_baseUniq,
  require_baseUnset,
  require_castPath,
  require_cloneBuffer,
  require_cloneTypedArray,
  require_copyArray,
  require_copyObject,
  require_debounce,
  require_eq,
  require_flatRest,
  require_get,
  require_hasIn,
  require_initCloneObject,
  require_isArguments,
  require_isArray,
  require_isArrayLike,
  require_isBuffer,
  require_isEqual,
  require_isFunction,
  require_isIndex,
  require_isIterateeCall,
  require_isObject,
  require_isObjectLike,
  require_isPlainObject,
  require_isTypedArray,
  require_keysIn,
  require_memoize,
  require_toKey
} from "./chunk-EE76ZZ62.js";
import {
  require_react_is
} from "./chunk-657GFU7K.js";
import {
  require_jsx_runtime
} from "./chunk-KBTYAULA.js";
import {
  require_react
} from "./chunk-QCHXOAYK.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/lodash/_baseSet.js
var require_baseSet = __commonJS({
  "node_modules/lodash/_baseSet.js"(exports, module) {
    var assignValue = require_assignValue();
    var castPath = require_castPath();
    var isIndex = require_isIndex();
    var isObject4 = require_isObject();
    var toKey = require_toKey();
    function baseSet(object, path, value, customizer) {
      if (!isObject4(object)) {
        return object;
      }
      path = castPath(path, object);
      var index = -1, length = path.length, lastIndex = length - 1, nested = object;
      while (nested != null && ++index < length) {
        var key = toKey(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
          return object;
        }
        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : void 0;
          if (newValue === void 0) {
            newValue = isObject4(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }
    module.exports = baseSet;
  }
});

// node_modules/lodash/set.js
var require_set = __commonJS({
  "node_modules/lodash/set.js"(exports, module) {
    var baseSet = require_baseSet();
    function set8(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }
    module.exports = set8;
  }
});

// node_modules/lodash/unset.js
var require_unset = __commonJS({
  "node_modules/lodash/unset.js"(exports, module) {
    var baseUnset = require_baseUnset();
    function unset3(object, path) {
      return object == null ? true : baseUnset(object, path);
    }
    module.exports = unset3;
  }
});

// node_modules/lodash/_assignMergeValue.js
var require_assignMergeValue = __commonJS({
  "node_modules/lodash/_assignMergeValue.js"(exports, module) {
    var baseAssignValue = require_baseAssignValue();
    var eq = require_eq();
    function assignMergeValue(object, key, value) {
      if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
        baseAssignValue(object, key, value);
      }
    }
    module.exports = assignMergeValue;
  }
});

// node_modules/lodash/isArrayLikeObject.js
var require_isArrayLikeObject = __commonJS({
  "node_modules/lodash/isArrayLikeObject.js"(exports, module) {
    var isArrayLike = require_isArrayLike();
    var isObjectLike = require_isObjectLike();
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    module.exports = isArrayLikeObject;
  }
});

// node_modules/lodash/_safeGet.js
var require_safeGet = __commonJS({
  "node_modules/lodash/_safeGet.js"(exports, module) {
    function safeGet(object, key) {
      if (key === "constructor" && typeof object[key] === "function") {
        return;
      }
      if (key == "__proto__") {
        return;
      }
      return object[key];
    }
    module.exports = safeGet;
  }
});

// node_modules/lodash/toPlainObject.js
var require_toPlainObject = __commonJS({
  "node_modules/lodash/toPlainObject.js"(exports, module) {
    var copyObject = require_copyObject();
    var keysIn = require_keysIn();
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }
    module.exports = toPlainObject;
  }
});

// node_modules/lodash/_baseMergeDeep.js
var require_baseMergeDeep = __commonJS({
  "node_modules/lodash/_baseMergeDeep.js"(exports, module) {
    var assignMergeValue = require_assignMergeValue();
    var cloneBuffer = require_cloneBuffer();
    var cloneTypedArray = require_cloneTypedArray();
    var copyArray = require_copyArray();
    var initCloneObject = require_initCloneObject();
    var isArguments = require_isArguments();
    var isArray2 = require_isArray();
    var isArrayLikeObject = require_isArrayLikeObject();
    var isBuffer = require_isBuffer();
    var isFunction3 = require_isFunction();
    var isObject4 = require_isObject();
    var isPlainObject3 = require_isPlainObject();
    var isTypedArray = require_isTypedArray();
    var safeGet = require_safeGet();
    var toPlainObject = require_toPlainObject();
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
      var isCommon = newValue === void 0;
      if (isCommon) {
        var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray2(objValue)) {
            newValue = objValue;
          } else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          } else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          } else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          } else {
            newValue = [];
          }
        } else if (isPlainObject3(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          } else if (!isObject4(objValue) || isFunction3(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        } else {
          isCommon = false;
        }
      }
      if (isCommon) {
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack["delete"](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }
    module.exports = baseMergeDeep;
  }
});

// node_modules/lodash/_baseMerge.js
var require_baseMerge = __commonJS({
  "node_modules/lodash/_baseMerge.js"(exports, module) {
    var Stack = require_Stack();
    var assignMergeValue = require_assignMergeValue();
    var baseFor = require_baseFor();
    var baseMergeDeep = require_baseMergeDeep();
    var isObject4 = require_isObject();
    var keysIn = require_keysIn();
    var safeGet = require_safeGet();
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack());
        if (isObject4(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        } else {
          var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
          if (newValue === void 0) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }
    module.exports = baseMerge;
  }
});

// node_modules/lodash/_createAssigner.js
var require_createAssigner = __commonJS({
  "node_modules/lodash/_createAssigner.js"(exports, module) {
    var baseRest = require_baseRest();
    var isIterateeCall = require_isIterateeCall();
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    module.exports = createAssigner;
  }
});

// node_modules/lodash/merge.js
var require_merge = __commonJS({
  "node_modules/lodash/merge.js"(exports, module) {
    var baseMerge = require_baseMerge();
    var createAssigner = require_createAssigner();
    var merge5 = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });
    module.exports = merge5;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports, module) {
    var baseClone = require_baseClone();
    var CLONE_DEEP_FLAG = 1;
    var CLONE_SYMBOLS_FLAG = 4;
    function cloneDeep3(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }
    module.exports = cloneDeep3;
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match2 = multiMatcher.exec(input);
      while (match2) {
        try {
          replaceMap[match2[0]] = decodeURIComponent(match2[0]);
        } catch (err) {
          var result = decode(match2[0]);
          if (result !== match2[0]) {
            replaceMap[match2[0]] = result;
          }
        }
        match2 = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/filter-obj/index.js
var require_filter_obj = __commonJS({
  "node_modules/filter-obj/index.js"(exports, module) {
    "use strict";
    module.exports = function(obj, predicate) {
      var ret = {};
      var keys = Object.keys(obj);
      var isArr = Array.isArray(predicate);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
          ret[key] = val;
        }
      }
      return ret;
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var filterObject = require_filter_obj();
    var isNullOrUndefined2 = (value) => value === null || value === void 0;
    var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), "[]"].join("")];
            }
            return [...result, [encode(key, options), "[]=", encode(value, options)].join("")];
          };
        case "colon-list-separator":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode(key, options), ":list="].join("")];
            }
            return [...result, [encode(key, options), ":list=", encode(value, options)].join("")];
          };
        case "comma":
        case "separator":
        case "bracket-separator": {
          const keyValueSep = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            value = value === null ? "" : value;
            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join("")];
            }
            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode(key, options)];
            }
            return [...result, [encode(key, options), "=", encode(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "colon-list-separator":
          return (key, value, accumulator) => {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray2 = typeof value === "string" && value.includes(options.arrayFormatSeparator);
            const isEncodedArray = typeof value === "string" && !isArray2 && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            const newValue = isArray2 || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode(item, options)) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };
        case "bracket-separator":
          return (key, value, accumulator) => {
            const isArray2 = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, "");
            if (!isArray2) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }
            const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item) => decode(item, options));
            if (accumulator[key] === void 0) {
              accumulator[key] = arrayValue;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash2 = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash2 = url.slice(hashStart);
      }
      return hash2;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse4(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof query !== "string") {
        return ret;
      }
      query = query.trim().replace(/^[?#&]/, "");
      if (!query) {
        return ret;
      }
      for (const param of query.split("&")) {
        if (param === "") {
          continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k of Object.keys(value)) {
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse4;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined2(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode(key, options);
        }
        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === "bracket-separator") {
            return encode(key, options) + "[]";
          }
          return value.reduce(formatter(key), []).join("&");
        }
        return encode(key, options) + "=" + encode(value, options);
      }).filter((x) => x.length > 0).join("&");
    };
    exports.parseUrl = (url, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url_, hash2] = splitOnFirst(url, "#");
      return Object.assign(
        {
          url: url_.split("?")[0] || "",
          query: parse4(extract(url), options)
        },
        options && options.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode(hash2, options) } : {}
      );
    };
    exports.stringifyUrl = (object, options) => {
      options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
      }, options);
      const url = removeHash(object.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(object.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, object.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash2 = getHash(object.url);
      if (object.fragmentIdentifier) {
        hash2 = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
      }
      return `${url}${queryString}${hash2}`;
    };
    exports.pick = (input, filter, options) => {
      options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
      }, options);
      const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
      return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
      }, options);
    };
    exports.exclude = (input, filter, options) => {
      const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
      return exports.pick(input, exclusionFilter, options);
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// node_modules/lodash/union.js
var require_union = __commonJS({
  "node_modules/lodash/union.js"(exports, module) {
    var baseFlatten = require_baseFlatten();
    var baseRest = require_baseRest();
    var baseUniq = require_baseUniq();
    var isArrayLikeObject = require_isArrayLikeObject();
    var union2 = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    module.exports = union2;
  }
});

// node_modules/lodash/_basePickBy.js
var require_basePickBy = __commonJS({
  "node_modules/lodash/_basePickBy.js"(exports, module) {
    var baseGet2 = require_baseGet();
    var baseSet = require_baseSet();
    var castPath = require_castPath();
    function basePickBy(object, paths, predicate) {
      var index = -1, length = paths.length, result = {};
      while (++index < length) {
        var path = paths[index], value = baseGet2(object, path);
        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }
    module.exports = basePickBy;
  }
});

// node_modules/lodash/_basePick.js
var require_basePick = __commonJS({
  "node_modules/lodash/_basePick.js"(exports, module) {
    var basePickBy = require_basePickBy();
    var hasIn = require_hasIn();
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }
    module.exports = basePick;
  }
});

// node_modules/lodash/pick.js
var require_pick = __commonJS({
  "node_modules/lodash/pick.js"(exports, module) {
    var basePick = require_basePick();
    var flatRest = require_flatRest();
    var pick5 = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });
    module.exports = pick5;
  }
});

// node_modules/jsonexport/dist/core/eol.js
var require_eol = __commonJS({
  "node_modules/jsonexport/dist/core/eol.js"(exports, module) {
    "use strict";
    module.exports = "\n";
  }
});

// node_modules/jsonexport/dist/core/helper.js
var require_helper = __commonJS({
  "node_modules/jsonexport/dist/core/helper.js"(exports, module) {
    "use strict";
    module.exports.isFunction = function(fn) {
      var getType = {};
      return fn && getType.toString.call(fn) === "[object Function]";
    };
    module.exports.isArray = function(arr) {
      return Array.isArray(arr);
    };
    module.exports.isObject = function(obj) {
      return obj instanceof Object;
    };
    module.exports.isString = function(str) {
      return typeof str === "string";
    };
    module.exports.isNumber = function(num) {
      return typeof num === "number";
    };
    module.exports.isBoolean = function(bool) {
      return typeof bool === "boolean";
    };
    module.exports.isDate = function(date) {
      return date instanceof Date;
    };
  }
});

// node_modules/jsonexport/dist/core/join-rows.js
var require_join_rows = __commonJS({
  "node_modules/jsonexport/dist/core/join-rows.js"(exports, module) {
    "use strict";
    var EOL = require_eol();
    var helper = require_helper();
    module.exports = function joinRows(rows, join) {
      if (!rows || !helper.isArray(rows)) {
        throw new TypeError('Invalid params "rows" for joinRows. Must be an array of string.');
      }
      var r = rows.join(join || EOL || "\n");
      return r;
    };
  }
});

// node_modules/jsonexport/dist/parser/handler.js
var require_handler = __commonJS({
  "node_modules/jsonexport/dist/parser/handler.js"(exports, module) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var helper = require_helper();
    var Handler = function() {
      function Handler2(options) {
        _classCallCheck(this, Handler2);
        this._options = options;
        this._options.typeHandlers = this._options.typeHandlers || {};
      }
      _createClass(Handler2, [{
        key: "_setHeaders",
        value: function _setHeaders(result, item) {
          var self = this;
          if (!item) return result;
          return result.map(function(element) {
            element.item = element.item ? item + self._options.headerPathString + element.item : item;
            return element;
          });
        }
      }, {
        key: "castValue",
        value: function castValue(element, item, index, parent) {
          var types = this._options.typeHandlers;
          for (var type in types) {
            if (isInstanceOfTypeName(element, type)) {
              element = types[type].call(types, element, index, parent);
              break;
            }
          }
          return element;
        }
      }, {
        key: "checkComplex",
        value: function checkComplex(element, item) {
          if (helper.isDate(element)) {
            return [{
              item,
              value: (this._options.handleDate || this._handleDate)(element, item)
            }];
          } else if (helper.isArray(element)) {
            var resultArray = this._handleArray(element, item);
            return this._setHeaders(resultArray, item);
          } else if (helper.isObject(element)) {
            var resultObject = this._handleObject(element);
            return this._setHeaders(resultObject, item);
          }
          return [{
            item,
            value: ""
          }];
        }
        /**
         * Check the element type of the element call the correct handle function
         *
         * @param element Element that will be checked
         * @param item Used to make the headers/path breadcrumb
         * @returns [{item, value}] result
         */
      }, {
        key: "check",
        value: function check(element, item, index, parent) {
          element = this.castValue(element, item, index, parent);
          switch (typeof element === "undefined" ? "undefined" : _typeof(element)) {
            case "string":
              return [{
                item,
                value: this._handleString(element, item)
              }];
            case "number":
              return [{
                item,
                value: this._handleNumber(element, item)
              }];
            case "boolean":
              return [{
                item,
                value: this._handleBoolean.bind(this)(element, item)
              }];
          }
          return this.checkComplex(element, item);
        }
        /**
         * Handle all Objects
         *
         * @param {Object} obj
         * @returns [{item, value}] result
         */
      }, {
        key: "_handleObject",
        value: function _handleObject(obj) {
          var result = [];
          for (var prop in obj) {
            var propData = obj[prop];
            var resultCheckType = this.check(propData, prop, prop, obj);
            result = result.concat(resultCheckType);
          }
          return result;
        }
        /**
         * Handle all Arrays, merges arrays with primitive types in a single value
         *
         * @param {Array} array
         * @returns [{item, value}] result
         */
      }, {
        key: "_handleArray",
        value: function _handleArray(array) {
          var self = this;
          var result = [];
          var firstElementWithoutItem;
          for (var aIndex = 0; aIndex < array.length; ++aIndex) {
            var element = array[aIndex];
            var resultCheckType = self.check(element, null, aIndex, array);
            if (resultCheckType.length === 0) continue;
            var firstResult = resultCheckType[0];
            if (!firstResult.item && firstElementWithoutItem !== void 0) {
              firstElementWithoutItem.value += self._options.arrayPathString + firstResult.value;
              continue;
            } else if (resultCheckType.length > 0 && !firstResult.item && firstElementWithoutItem === void 0) {
              firstElementWithoutItem = firstResult;
            }
            result = result.concat(resultCheckType);
          }
          return result;
        }
        /**
         * Handle all Boolean variables, can be replaced with options.handleBoolean
         *
         * @param {Boolean} boolean
         * @returns {String} result
         */
      }, {
        key: "_handleBoolean",
        value: function _handleBoolean(boolean) {
          var result;
          if (boolean) {
            result = this._options.booleanTrueString || "true";
          } else {
            result = this._options.booleanFalseString || "false";
          }
          return result;
        }
        /**
         * Handle all String variables, can be replaced with options.handleString
         *
         * @param {String} string
         * @returns {String} string
         */
      }, {
        key: "_handleString",
        value: function _handleString(string) {
          return string;
        }
        /**
         * Handle all Number variables, can be replaced with options.handleNumber
         *
         * @param {Number} number
         * @returns {Number} number
         */
      }, {
        key: "_handleNumber",
        value: function _handleNumber(number2) {
          return number2;
        }
        /**
         * Handle all Date variables, can be replaced with options.handleDate
         *
         * @param {Date} number
         * @returns {string} result
         */
      }, {
        key: "_handleDate",
        value: function _handleDate(date) {
          return date.toLocaleDateString();
        }
      }]);
      return Handler2;
    }();
    module.exports = Handler;
    var globalScope = typeof window === "undefined" ? global : window;
    function isInstanceOfTypeName(element, typeName) {
      if (element instanceof globalScope[typeName]) {
        return true;
      }
      switch (typeof element === "undefined" ? "undefined" : _typeof(element)) {
        case "string":
          return typeName === "String";
        case "boolean":
          return typeName === "Boolean";
        case "number":
          return typeName === "Number";
      }
      return false;
    }
  }
});

// node_modules/jsonexport/dist/core/escape-delimiters.js
var require_escape_delimiters = __commonJS({
  "node_modules/jsonexport/dist/core/escape-delimiters.js"(exports, module) {
    "use strict";
    module.exports = function escapedDelimiters(textDelimiter, rowDelimiter, forceTextDelimiter) {
      var endOfLine = "\n";
      if (typeof textDelimiter !== "string") {
        throw new TypeError('Invalid param "textDelimiter", must be a string.');
      }
      if (typeof rowDelimiter !== "string") {
        throw new TypeError('Invalid param "rowDelimiter", must be a string.');
      }
      var textDelimiterRegex = new RegExp("\\" + textDelimiter, "g");
      var escapedDelimiter = textDelimiter + textDelimiter;
      var enclosingCondition = textDelimiter === '"' ? function(value) {
        return value.indexOf(rowDelimiter) >= 0 || value.indexOf(endOfLine) >= 0 || value.indexOf('"') >= 0;
      } : function(value) {
        return value.indexOf(rowDelimiter) >= 0 || value.indexOf(endOfLine) >= 0;
      };
      return function(value) {
        if (forceTextDelimiter) value = "" + value;
        if (!value.replace) return value;
        value = value.replace(textDelimiterRegex, escapedDelimiter);
        if (forceTextDelimiter || enclosingCondition(value)) {
          value = textDelimiter + value + textDelimiter;
        }
        return value;
      };
    };
  }
});

// node_modules/jsonexport/dist/parser/csv.js
var require_csv = __commonJS({
  "node_modules/jsonexport/dist/parser/csv.js"(exports, module) {
    "use strict";
    var _createClass = /* @__PURE__ */ function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var joinRows = require_join_rows();
    var Handler = require_handler();
    var helper = require_helper();
    var Parser2 = function() {
      function Parser3(options) {
        _classCallCheck(this, Parser3);
        this._options = options || {};
        this._handler = new Handler(this._options);
        this._headers = this._options.headers || [];
        this._escape = require_escape_delimiters()(this._options.textDelimiter, this._options.rowDelimiter, this._options.forceTextDelimiter);
      }
      _createClass(Parser3, [{
        key: "parse",
        value: function parse4(json, done, stream) {
          if (helper.isArray(json)) return done(null, this._parseArray(json, stream));
          else if (helper.isObject(json)) return done(null, this._parseObject(json));
          return done(new Error("Unable to parse the JSON object, its not an Array or Object."));
        }
      }, {
        key: "_checkRows",
        value: function _checkRows(rows) {
          var lastRow = null;
          var finalRows = [];
          var fillGaps = function fillGaps2(col, index) {
            return col === "" || col === void 0 ? lastRow[index] : col;
          };
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = void 0;
          try {
            for (var _iterator = rows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var row = _step.value;
              var missing = this._headers.length - row.length;
              if (missing > 0) row = row.concat(Array(missing).join(".").split("."));
              if (lastRow && this._options.fillGaps) row = row.map(fillGaps);
              finalRows.push(row.join(this._options.rowDelimiter));
              lastRow = row;
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
          return finalRows;
        }
      }, {
        key: "_parseArray",
        value: function _parseArray(json, stream) {
          var self = this;
          this._headers = this._headers || [];
          var fileRows = [];
          var outputFile = void 0;
          var fillRows = void 0;
          var getHeaderIndex = function getHeaderIndex2(header) {
            var index = self._headers.indexOf(header);
            if (index === -1) {
              self._headers.push(header);
              index = self._headers.indexOf(header);
            }
            return index;
          };
          fillRows = function fillRows2(result) {
            var rows = [];
            var fillAndPush = function fillAndPush2(row) {
              return rows.push(row.map(function(col) {
                return col != null ? col : "";
              }));
            };
            var newRow = function newRow2() {
              return new Array(self._headers.length).fill(null);
            };
            var emptyRowIndexByHeader = {};
            var currentRow = newRow();
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = result[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var element = _step2.value;
                var elementHeaderIndex = getHeaderIndex(element.item);
                if (currentRow[elementHeaderIndex] != void 0) {
                  fillAndPush(currentRow);
                  currentRow = newRow();
                }
                emptyRowIndexByHeader[elementHeaderIndex] = emptyRowIndexByHeader[elementHeaderIndex] || 0;
                if (self._options.fillTopRow && emptyRowIndexByHeader[elementHeaderIndex] < rows.length) {
                  rows[emptyRowIndexByHeader[elementHeaderIndex]][elementHeaderIndex] = self._escape(element.value);
                  emptyRowIndexByHeader[elementHeaderIndex] += 1;
                  continue;
                }
                currentRow[elementHeaderIndex] = self._escape(element.value);
                emptyRowIndexByHeader[elementHeaderIndex] += 1;
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
            if (currentRow.length > 0) {
              fillAndPush(currentRow);
            }
            fileRows = fileRows.concat(self._checkRows(rows));
          };
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = json[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var item = _step3.value;
              var itemResult = self._handler.check(item, self._options.mainPathItem, item, json);
              fillRows(itemResult);
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          if (!stream && self._options.includeHeaders) {
            fileRows.unshift(this.headers);
          }
          return joinRows(fileRows, self._options.endOfLine);
        }
      }, {
        key: "_parseObject",
        value: function _parseObject(json) {
          var self = this;
          var fileRows = [];
          var parseResult = [];
          var outputFile = void 0;
          var fillRows = void 0;
          var horizontalRows = [[], []];
          fillRows = function fillRows2(result) {
            var value = result.value || result.value === 0 ? result.value.toString() : self._options.undefinedString;
            value = self._escape(value);
            if (self._options.verticalOutput) {
              var row = [result.item, value];
              fileRows.push(row.join(self._options.rowDelimiter));
            } else {
              horizontalRows[0].push(result.item);
              horizontalRows[1].push(value);
            }
          };
          for (var prop in json) {
            var prefix = "";
            if (this._options.mainPathItem) prefix = this._options.mainPathItem + this._options.headerPathString;
            parseResult = this._handler.check(json[prop], prefix + prop, prop, json);
            parseResult.forEach(fillRows);
          }
          if (!this._options.verticalOutput) {
            fileRows.push(horizontalRows[0].join(this._options.rowDelimiter));
            fileRows.push(horizontalRows[1].join(this._options.rowDelimiter));
          }
          return joinRows(fileRows, this._options.endOfLine);
        }
      }, {
        key: "headers",
        get: function get16() {
          var _this = this;
          var headers = this._headers;
          if (this._options.rename && this._options.rename.length > 0) headers = headers.map(function(header) {
            return _this._options.rename[_this._options.headers.indexOf(header)] || header;
          });
          if (this._options.forceTextDelimiter) {
            headers = headers.map(function(header) {
              return "" + _this._options.textDelimiter + header + _this._options.textDelimiter;
            });
          }
          if (this._options.mapHeaders) headers = headers.map(this._options.mapHeaders);
          return headers.join(this._options.rowDelimiter);
        }
      }]);
      return Parser3;
    }();
    module.exports = Parser2;
  }
});

// node_modules/jsonexport/dist/core/stream.js
var require_stream = __commonJS({
  "node_modules/jsonexport/dist/core/stream.js"(exports, module) {
    "use strict";
    var Stream = function(_Transform) {
      throw new Error("jsonexport called without third argument as a callback and is required");
    };
    module.exports = Stream;
  }
});

// node_modules/jsonexport/dist/index.js
var require_dist = __commonJS({
  "node_modules/jsonexport/dist/index.js"(exports, module) {
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var Parser2 = require_csv();
    var Stream = require_stream();
    var helper = require_helper();
    var EOL = require_eol();
    module.exports = function() {
      var DEFAULT_OPTIONS = {
        headers: [],
        //              Array
        rename: [],
        //               Array
        headerPathString: ".",
        //    String
        rowDelimiter: ",",
        //        String
        textDelimiter: '"',
        //       String
        arrayPathString: ";",
        //     String
        undefinedString: "",
        //      String
        endOfLine: EOL || "\n",
        //   String
        mainPathItem: null,
        //       String
        booleanTrueString: null,
        //  String
        booleanFalseString: null,
        // String
        includeHeaders: true,
        //     Boolean
        fillGaps: false,
        //          Boolean
        verticalOutput: true,
        //     Boolean
        forceTextDelimiter: false
        //Boolean
      };
      var json = void 0, userOptions = void 0, callback = void 0;
      if (arguments.length === 3) {
        var _arguments = Array.prototype.slice.call(arguments);
        json = _arguments[0];
        userOptions = _arguments[1];
        callback = _arguments[2];
      } else if (arguments.length === 2) {
        var any = void 0;
        var _arguments2 = Array.prototype.slice.call(arguments);
        json = _arguments2[0];
        any = _arguments2[1];
        if (typeof any === "function") {
          callback = any;
        } else if ((typeof any === "undefined" ? "undefined" : _typeof(any)) === "object") {
          userOptions = any;
        }
      } else if (arguments.length === 1) {
        var _arguments3 = Array.prototype.slice.call(arguments), _any = _arguments3[0];
        if ((typeof _any === "undefined" ? "undefined" : _typeof(_any)) === "object") {
          var defaultKeys = Object.keys(DEFAULT_OPTIONS);
          var objectKeys = Object.keys(_any);
          var isOptions = objectKeys.every(function(key) {
            return defaultKeys.includes(key);
          });
          if (objectKeys.length > 0 && isOptions) {
            userOptions = _any;
          } else {
            json = _any;
          }
        } else {
          json = _any;
        }
      } else {
        return new Stream(new Parser2(DEFAULT_OPTIONS));
      }
      var options = Object.assign({}, DEFAULT_OPTIONS, userOptions);
      var parser = new Parser2(options);
      if (!json) {
        return new Stream(parser);
      }
      return new Promise(function(resolve, reject) {
        parser.parse(json, function(err, result) {
          if (callback) return callback(err, result);
          if (err) return reject(err);
          if (reject) return resolve(result);
        });
      });
    };
  }
});

// node_modules/lodash/defaults.js
var require_defaults = __commonJS({
  "node_modules/lodash/defaults.js"(exports, module) {
    var baseRest = require_baseRest();
    var eq = require_eq();
    var isIterateeCall = require_isIterateeCall();
    var keysIn = require_keysIn();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var defaults3 = baseRest(function(object, sources) {
      object = Object(object);
      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }
      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;
        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];
          if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            object[key] = source[key];
          }
        }
      }
      return object;
    });
    module.exports = defaults3;
  }
});

// node_modules/inflection/lib/inflection.js
var require_inflection = __commonJS({
  "node_modules/inflection/lib/inflection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pluralize = pluralize3;
    exports.singularize = singularize;
    exports.inflect = inflect2;
    exports.camelize = camelize;
    exports.underscore = underscore;
    exports.humanize = humanize2;
    exports.capitalize = capitalize;
    exports.dasherize = dasherize;
    exports.titleize = titleize;
    exports.demodulize = demodulize;
    exports.tableize = tableize;
    exports.classify = classify;
    exports.foreignKey = foreignKey;
    exports.ordinalize = ordinalize;
    exports.transform = transform2;
    var uncountableWords = [
      // 'access',
      "accommodation",
      "adulthood",
      "advertising",
      "advice",
      "aggression",
      "aid",
      "air",
      "aircraft",
      "alcohol",
      "anger",
      "applause",
      "arithmetic",
      // 'art',
      "assistance",
      "athletics",
      // 'attention',
      "bacon",
      "baggage",
      // 'ballet',
      // 'beauty',
      "beef",
      // 'beer',
      // 'behavior',
      "biology",
      // 'billiards',
      "blood",
      "botany",
      // 'bowels',
      "bread",
      // 'business',
      "butter",
      "carbon",
      "cardboard",
      "cash",
      "chalk",
      "chaos",
      "chess",
      "crossroads",
      "countryside",
      // 'damage',
      "dancing",
      // 'danger',
      "deer",
      // 'delight',
      // 'dessert',
      "dignity",
      "dirt",
      // 'distribution',
      "dust",
      "economics",
      "education",
      "electricity",
      // 'employment',
      // 'energy',
      "engineering",
      "enjoyment",
      // 'entertainment',
      "envy",
      "equipment",
      "ethics",
      "evidence",
      "evolution",
      // 'failure',
      // 'faith',
      "fame",
      "fiction",
      // 'fish',
      "flour",
      "flu",
      "food",
      // 'freedom',
      // 'fruit',
      "fuel",
      "fun",
      // 'funeral',
      "furniture",
      "gallows",
      "garbage",
      "garlic",
      // 'gas',
      "genetics",
      // 'glass',
      "gold",
      "golf",
      "gossip",
      // 'grass',
      "gratitude",
      "grief",
      // 'ground',
      "guilt",
      "gymnastics",
      // 'hair',
      "happiness",
      "hardware",
      "harm",
      "hate",
      "hatred",
      "health",
      "heat",
      // 'height',
      "help",
      "homework",
      "honesty",
      "honey",
      "hospitality",
      "housework",
      "humour",
      "hunger",
      "hydrogen",
      "ice",
      "importance",
      "inflation",
      "information",
      // 'injustice',
      "innocence",
      // 'intelligence',
      "iron",
      "irony",
      "jam",
      // 'jealousy',
      // 'jelly',
      "jewelry",
      // 'joy',
      "judo",
      // 'juice',
      // 'justice',
      "karate",
      // 'kindness',
      "knowledge",
      // 'labour',
      "lack",
      // 'land',
      "laughter",
      "lava",
      "leather",
      "leisure",
      "lightning",
      "linguine",
      "linguini",
      "linguistics",
      "literature",
      "litter",
      "livestock",
      "logic",
      "loneliness",
      // 'love',
      "luck",
      "luggage",
      "macaroni",
      "machinery",
      "magic",
      // 'mail',
      "management",
      "mankind",
      "marble",
      "mathematics",
      "mayonnaise",
      "measles",
      // 'meat',
      // 'metal',
      "methane",
      "milk",
      "minus",
      "money",
      // 'moose',
      "mud",
      "music",
      "mumps",
      "nature",
      "news",
      "nitrogen",
      "nonsense",
      "nurture",
      "nutrition",
      "obedience",
      "obesity",
      // 'oil',
      "oxygen",
      // 'paper',
      // 'passion',
      "pasta",
      "patience",
      // 'permission',
      "physics",
      "poetry",
      "pollution",
      "poverty",
      // 'power',
      "pride",
      // 'production',
      // 'progress',
      // 'pronunciation',
      "psychology",
      "publicity",
      "punctuation",
      // 'quality',
      // 'quantity',
      "quartz",
      "racism",
      // 'rain',
      // 'recreation',
      "relaxation",
      "reliability",
      "research",
      "respect",
      "revenge",
      "rice",
      "rubbish",
      "rum",
      "safety",
      // 'salad',
      // 'salt',
      // 'sand',
      // 'satire',
      "scenery",
      "seafood",
      "seaside",
      "series",
      "shame",
      "sheep",
      "shopping",
      // 'silence',
      "sleep",
      // 'slang'
      "smoke",
      "smoking",
      "snow",
      "soap",
      "software",
      "soil",
      // 'sorrow',
      // 'soup',
      "spaghetti",
      // 'speed',
      "species",
      // 'spelling',
      // 'sport',
      "steam",
      // 'strength',
      "stuff",
      "stupidity",
      // 'success',
      // 'sugar',
      "sunshine",
      "symmetry",
      // 'tea',
      "tennis",
      "thirst",
      "thunder",
      "timber",
      // 'time',
      // 'toast',
      // 'tolerance',
      // 'trade',
      "traffic",
      "transportation",
      // 'travel',
      "trust",
      // 'understanding',
      "underwear",
      "unemployment",
      "unity",
      // 'usage',
      "validity",
      "veal",
      "vegetation",
      "vegetarianism",
      "vengeance",
      "violence",
      // 'vision',
      "vitality",
      "warmth",
      // 'water',
      "wealth",
      "weather",
      // 'weight',
      "welfare",
      "wheat",
      // 'whiskey',
      // 'width',
      "wildlife",
      // 'wine',
      "wisdom",
      // 'wood',
      // 'wool',
      // 'work',
      // 'yeast',
      "yoga",
      "zinc",
      "zoology"
    ];
    var regex2 = {
      plural: {
        men: new RegExp("^(m|wom)en$", "gi"),
        people: new RegExp("(pe)ople$", "gi"),
        children: new RegExp("(child)ren$", "gi"),
        tia: new RegExp("([ti])a$", "gi"),
        analyses: new RegExp("((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$", "gi"),
        databases: new RegExp("(database)s$", "gi"),
        drives: new RegExp("(drive)s$", "gi"),
        hives: new RegExp("(hi|ti)ves$", "gi"),
        curves: new RegExp("(curve)s$", "gi"),
        lrves: new RegExp("([lr])ves$", "gi"),
        aves: new RegExp("([a])ves$", "gi"),
        foves: new RegExp("([^fo])ves$", "gi"),
        movies: new RegExp("(m)ovies$", "gi"),
        aeiouyies: new RegExp("([^aeiouy]|qu)ies$", "gi"),
        series: new RegExp("(s)eries$", "gi"),
        xes: new RegExp("(x|ch|ss|sh)es$", "gi"),
        mice: new RegExp("([m|l])ice$", "gi"),
        buses: new RegExp("(bus)es$", "gi"),
        oes: new RegExp("(o)es$", "gi"),
        shoes: new RegExp("(shoe)s$", "gi"),
        crises: new RegExp("(cris|ax|test)es$", "gi"),
        octopuses: new RegExp("(octop|vir)uses$", "gi"),
        aliases: new RegExp("(alias|canvas|status|campus)es$", "gi"),
        summonses: new RegExp("^(summons|bonus)es$", "gi"),
        oxen: new RegExp("^(ox)en", "gi"),
        matrices: new RegExp("(matr)ices$", "gi"),
        vertices: new RegExp("(vert|ind)ices$", "gi"),
        feet: new RegExp("^feet$", "gi"),
        teeth: new RegExp("^teeth$", "gi"),
        geese: new RegExp("^geese$", "gi"),
        quizzes: new RegExp("(quiz)zes$", "gi"),
        whereases: new RegExp("^(whereas)es$", "gi"),
        criteria: new RegExp("^(criteri)a$", "gi"),
        genera: new RegExp("^genera$", "gi"),
        ss: new RegExp("ss$", "gi"),
        s: new RegExp("s$", "gi")
      },
      singular: {
        man: new RegExp("^(m|wom)an$", "gi"),
        person: new RegExp("(pe)rson$", "gi"),
        child: new RegExp("(child)$", "gi"),
        drive: new RegExp("(drive)$", "gi"),
        ox: new RegExp("^(ox)$", "gi"),
        axis: new RegExp("(ax|test)is$", "gi"),
        octopus: new RegExp("(octop|vir)us$", "gi"),
        alias: new RegExp("(alias|status|canvas|campus)$", "gi"),
        summons: new RegExp("^(summons|bonus)$", "gi"),
        bus: new RegExp("(bu)s$", "gi"),
        buffalo: new RegExp("(buffal|tomat|potat)o$", "gi"),
        tium: new RegExp("([ti])um$", "gi"),
        sis: new RegExp("sis$", "gi"),
        ffe: new RegExp("(?:([^f])fe|([lr])f)$", "gi"),
        focus: new RegExp("^(focus)$", "gi"),
        hive: new RegExp("(hi|ti)ve$", "gi"),
        aeiouyy: new RegExp("([^aeiouy]|qu)y$", "gi"),
        x: new RegExp("(x|ch|ss|sh)$", "gi"),
        matrix: new RegExp("(matr)ix$", "gi"),
        vertex: new RegExp("(vert|ind)ex$", "gi"),
        mouse: new RegExp("([m|l])ouse$", "gi"),
        foot: new RegExp("^foot$", "gi"),
        tooth: new RegExp("^tooth$", "gi"),
        goose: new RegExp("^goose$", "gi"),
        quiz: new RegExp("(quiz)$", "gi"),
        whereas: new RegExp("^(whereas)$", "gi"),
        criterion: new RegExp("^(criteri)on$", "gi"),
        genus: new RegExp("^genus$", "gi"),
        s: new RegExp("s$", "gi"),
        common: new RegExp("$", "gi")
      }
    };
    var pluralRules = [
      // do not replace if its already a plural word
      [regex2.plural.men],
      [regex2.plural.people],
      [regex2.plural.children],
      [regex2.plural.tia],
      [regex2.plural.analyses],
      [regex2.plural.databases],
      [regex2.plural.drives],
      [regex2.plural.hives],
      [regex2.plural.curves],
      [regex2.plural.lrves],
      [regex2.plural.foves],
      [regex2.plural.aeiouyies],
      [regex2.plural.series],
      [regex2.plural.movies],
      [regex2.plural.xes],
      [regex2.plural.mice],
      [regex2.plural.buses],
      [regex2.plural.oes],
      [regex2.plural.shoes],
      [regex2.plural.crises],
      [regex2.plural.octopuses],
      [regex2.plural.aliases],
      [regex2.plural.summonses],
      [regex2.plural.oxen],
      [regex2.plural.matrices],
      [regex2.plural.feet],
      [regex2.plural.teeth],
      [regex2.plural.geese],
      [regex2.plural.quizzes],
      [regex2.plural.whereases],
      [regex2.plural.criteria],
      [regex2.plural.genera],
      // original rule
      [regex2.singular.man, "$1en"],
      [regex2.singular.person, "$1ople"],
      [regex2.singular.child, "$1ren"],
      [regex2.singular.drive, "$1s"],
      [regex2.singular.ox, "$1en"],
      [regex2.singular.axis, "$1es"],
      [regex2.singular.octopus, "$1uses"],
      [regex2.singular.alias, "$1es"],
      [regex2.singular.summons, "$1es"],
      [regex2.singular.bus, "$1ses"],
      [regex2.singular.buffalo, "$1oes"],
      [regex2.singular.tium, "$1a"],
      [regex2.singular.sis, "ses"],
      [regex2.singular.ffe, "$1$2ves"],
      [regex2.singular.focus, "$1es"],
      [regex2.singular.hive, "$1ves"],
      [regex2.singular.aeiouyy, "$1ies"],
      [regex2.singular.matrix, "$1ices"],
      [regex2.singular.vertex, "$1ices"],
      [regex2.singular.x, "$1es"],
      [regex2.singular.mouse, "$1ice"],
      [regex2.singular.foot, "feet"],
      [regex2.singular.tooth, "teeth"],
      [regex2.singular.goose, "geese"],
      [regex2.singular.quiz, "$1zes"],
      [regex2.singular.whereas, "$1es"],
      [regex2.singular.criterion, "$1a"],
      [regex2.singular.genus, "genera"],
      [regex2.singular.s, "s"],
      [regex2.singular.common, "s"]
    ];
    var singularRules = [
      // do not replace if its already a singular word
      [regex2.singular.man],
      [regex2.singular.person],
      [regex2.singular.child],
      [regex2.singular.drive],
      [regex2.singular.ox],
      [regex2.singular.axis],
      [regex2.singular.octopus],
      [regex2.singular.alias],
      [regex2.singular.summons],
      [regex2.singular.bus],
      [regex2.singular.buffalo],
      [regex2.singular.tium],
      [regex2.singular.sis],
      [regex2.singular.ffe],
      [regex2.singular.focus],
      [regex2.singular.hive],
      [regex2.singular.aeiouyy],
      [regex2.singular.x],
      [regex2.singular.matrix],
      [regex2.singular.mouse],
      [regex2.singular.foot],
      [regex2.singular.tooth],
      [regex2.singular.goose],
      [regex2.singular.quiz],
      [regex2.singular.whereas],
      [regex2.singular.criterion],
      [regex2.singular.genus],
      // original rule
      [regex2.plural.men, "$1an"],
      [regex2.plural.people, "$1rson"],
      [regex2.plural.children, "$1"],
      [regex2.plural.databases, "$1"],
      [regex2.plural.drives, "$1"],
      [regex2.plural.genera, "genus"],
      [regex2.plural.criteria, "$1on"],
      [regex2.plural.tia, "$1um"],
      [regex2.plural.analyses, "$1$2sis"],
      [regex2.plural.hives, "$1ve"],
      [regex2.plural.curves, "$1"],
      [regex2.plural.lrves, "$1f"],
      [regex2.plural.aves, "$1ve"],
      [regex2.plural.foves, "$1fe"],
      [regex2.plural.movies, "$1ovie"],
      [regex2.plural.aeiouyies, "$1y"],
      [regex2.plural.series, "$1eries"],
      [regex2.plural.xes, "$1"],
      [regex2.plural.mice, "$1ouse"],
      [regex2.plural.buses, "$1"],
      [regex2.plural.oes, "$1"],
      [regex2.plural.shoes, "$1"],
      [regex2.plural.crises, "$1is"],
      [regex2.plural.octopuses, "$1us"],
      [regex2.plural.aliases, "$1"],
      [regex2.plural.summonses, "$1"],
      [regex2.plural.oxen, "$1"],
      [regex2.plural.matrices, "$1ix"],
      [regex2.plural.vertices, "$1ex"],
      [regex2.plural.feet, "foot"],
      [regex2.plural.teeth, "tooth"],
      [regex2.plural.geese, "goose"],
      [regex2.plural.quizzes, "$1"],
      [regex2.plural.whereases, "$1"],
      [regex2.plural.ss, "ss"],
      [regex2.plural.s, ""]
    ];
    var nonTitlecasedWords = [
      "and",
      "or",
      "nor",
      "a",
      "an",
      "the",
      "so",
      "but",
      "to",
      "of",
      "at",
      "by",
      "from",
      "into",
      "on",
      "onto",
      "off",
      "out",
      "in",
      "over",
      "with",
      "for"
    ];
    var idSuffix = new RegExp("(_ids|_id)$", "g");
    var underbar = new RegExp("_", "g");
    var spaceOrUnderbar = new RegExp("[ _]", "g");
    var uppercase = new RegExp("([A-Z])", "g");
    var underbarPrefix = new RegExp("^_");
    function applyRules(str, rules, skip, override) {
      if (override) {
        return override;
      } else {
        if (skip.includes(str.toLocaleLowerCase())) {
          return str;
        }
        for (const rule of rules) {
          if (str.match(rule[0])) {
            if (rule[1] !== void 0) {
              return str.replace(rule[0], rule[1]);
            }
            return str;
          }
        }
      }
      return str;
    }
    function pluralize3(str, plural) {
      return applyRules(str, pluralRules, uncountableWords, plural);
    }
    function singularize(str, singular) {
      return applyRules(str, singularRules, uncountableWords, singular);
    }
    function inflect2(str, count, singular, plural) {
      if (isNaN(count))
        return str;
      if (count === 1) {
        return applyRules(str, singularRules, uncountableWords, singular);
      } else {
        return applyRules(str, pluralRules, uncountableWords, plural);
      }
    }
    function camelize(str, lowFirstLetter) {
      const strPath = str.split("/");
      const j = strPath.length;
      let strArr, k, l, first;
      for (let i = 0; i < j; i++) {
        strArr = strPath[i].split("_");
        k = 0;
        l = strArr.length;
        for (; k < l; k++) {
          if (k !== 0) {
            strArr[k] = strArr[k].toLowerCase();
          }
          first = strArr[k].charAt(0);
          first = lowFirstLetter && i === 0 && k === 0 ? first.toLowerCase() : first.toUpperCase();
          strArr[k] = first + strArr[k].substring(1);
        }
        strPath[i] = strArr.join("");
      }
      return strPath.join("::");
    }
    function underscore(str, allUpperCase) {
      if (allUpperCase && str === str.toUpperCase())
        return str;
      const strPath = str.split("::");
      const j = strPath.length;
      for (let i = 0; i < j; i++) {
        strPath[i] = strPath[i].replace(uppercase, "_$1");
        strPath[i] = strPath[i].replace(underbarPrefix, "");
      }
      return strPath.join("/").toLowerCase();
    }
    function humanize2(str, lowFirstLetter) {
      str = str.toLowerCase();
      str = str.replace(idSuffix, "");
      str = str.replace(underbar, " ");
      if (!lowFirstLetter) {
        str = capitalize(str);
      }
      return str;
    }
    function capitalize(str) {
      str = str.toLowerCase();
      return str.substring(0, 1).toUpperCase() + str.substring(1);
    }
    function dasherize(str) {
      return str.replace(spaceOrUnderbar, "-");
    }
    function titleize(str) {
      str = str.toLowerCase().replace(underbar, " ");
      const strArr = str.split(" ");
      const j = strArr.length;
      let d, l;
      for (let i = 0; i < j; i++) {
        d = strArr[i].split("-");
        l = d.length;
        for (let k = 0; k < l; k++) {
          if (nonTitlecasedWords.indexOf(d[k].toLowerCase()) < 0) {
            d[k] = capitalize(d[k]);
          }
        }
        strArr[i] = d.join("-");
      }
      str = strArr.join(" ");
      str = str.substring(0, 1).toUpperCase() + str.substring(1);
      return str;
    }
    function demodulize(str) {
      const strArr = str.split("::");
      return strArr[strArr.length - 1];
    }
    function tableize(str) {
      str = underscore(str);
      str = pluralize3(str);
      return str;
    }
    function classify(str) {
      str = camelize(str);
      str = singularize(str);
      return str;
    }
    function foreignKey(str, dropIdUbar) {
      str = demodulize(str);
      str = underscore(str) + (dropIdUbar ? "" : "_") + "id";
      return str;
    }
    function ordinalize(str) {
      const strArr = str.split(" ");
      const j = strArr.length;
      for (let i = 0; i < j; i++) {
        const k = parseInt(strArr[i], 10);
        if (!isNaN(k)) {
          const ltd = strArr[i].substring(strArr[i].length - 2);
          const ld = strArr[i].substring(strArr[i].length - 1);
          let suf = "th";
          if (ltd != "11" && ltd != "12" && ltd != "13") {
            if (ld === "1") {
              suf = "st";
            } else if (ld === "2") {
              suf = "nd";
            } else if (ld === "3") {
              suf = "rd";
            }
          }
          strArr[i] += suf;
        }
      }
      return strArr.join(" ");
    }
    var transformFunctions = {
      pluralize: pluralize3,
      singularize,
      camelize,
      underscore,
      humanize: humanize2,
      capitalize,
      dasherize,
      titleize,
      demodulize,
      tableize,
      classify,
      foreignKey,
      ordinalize
    };
    function transform2(str, arr) {
      const j = arr.length;
      for (let i = 0; i < j; i++) {
        const method = arr[i];
        const methodFn = transformFunctions[method];
        if (methodFn) {
          str = methodFn(str);
        }
      }
      return str;
    }
  }
});

// node_modules/ra-core/dist/esm/auth/AuthContext.js
var import_react = __toESM(require_react());
var AuthContext = (0, import_react.createContext)(void 0);
AuthContext.displayName = "AuthContext";

// node_modules/ra-core/dist/esm/auth/useAuthProvider.js
var import_react2 = __toESM(require_react());
var defaultAuthParams = {
  loginUrl: "/login",
  afterLoginUrl: "/"
};
var useAuthProvider = function() {
  return (0, import_react2.useContext)(AuthContext);
};
var useAuthProvider_default = useAuthProvider;

// node_modules/ra-core/dist/esm/store/localStorageStore.js
var RA_STORE = "RaStore";
var testLocalStorage = function() {
  if (typeof window === "undefined" || window.localStorage == void 0) {
    return false;
  }
  try {
    window.localStorage.setItem("test", "test");
    window.localStorage.removeItem("test");
    return true;
  } catch (e) {
    return false;
  }
};
var localStorageAvailable = testLocalStorage();
var localStorageStore = function(version, appKey) {
  if (version === void 0) {
    version = "1";
  }
  if (appKey === void 0) {
    appKey = "";
  }
  var prefix = "".concat(RA_STORE).concat(appKey);
  var prefixLength = prefix.length;
  var subscriptions = {};
  var publish = function(key, value) {
    Object.keys(subscriptions).forEach(function(id) {
      if (!subscriptions[id])
        return;
      if (subscriptions[id].key === key) {
        subscriptions[id].callback(value);
      }
    });
  };
  var onLocalStorageChange = function(event) {
    var _a11;
    if (((_a11 = event.key) === null || _a11 === void 0 ? void 0 : _a11.substring(0, prefixLength)) !== prefix) {
      return;
    }
    var key = event.key.substring(prefixLength + 1);
    var value = event.newValue ? tryParse(event.newValue) : void 0;
    Object.keys(subscriptions).forEach(function(id) {
      if (!subscriptions[id])
        return;
      if (subscriptions[id].key === key) {
        if (value === null) {
          subscriptions[id].callback(void 0);
        } else {
          subscriptions[id].callback(value == null ? void 0 : value);
        }
      }
    });
  };
  return {
    setup: function() {
      if (localStorageAvailable) {
        var storedVersion = getStorage().getItem("".concat(prefix, ".version"));
        if (storedVersion && storedVersion !== version) {
          var storage_1 = getStorage();
          Object.keys(storage_1).forEach(function(key) {
            if (key.startsWith(prefix)) {
              storage_1.removeItem(key);
            }
          });
        }
        getStorage().setItem("".concat(prefix, ".version"), version);
        window.addEventListener("storage", onLocalStorageChange);
      }
    },
    teardown: function() {
      if (localStorageAvailable) {
        window.removeEventListener("storage", onLocalStorageChange);
      }
    },
    getItem: function(key, defaultValue) {
      var valueFromStorage = getStorage().getItem("".concat(prefix, ".").concat(key));
      return valueFromStorage == null ? defaultValue : tryParse(valueFromStorage);
    },
    setItem: function(key, value) {
      if (value === void 0) {
        getStorage().removeItem("".concat(prefix, ".").concat(key));
      } else {
        getStorage().setItem("".concat(prefix, ".").concat(key), JSON.stringify(value));
      }
      publish(key, value);
    },
    removeItem: function(key) {
      getStorage().removeItem("".concat(prefix, ".").concat(key));
      publish(key, void 0);
    },
    removeItems: function(keyPrefix) {
      var storage = getStorage();
      Object.keys(storage).forEach(function(key) {
        if (key.startsWith("".concat(prefix, ".").concat(keyPrefix))) {
          storage.removeItem(key);
          var publishKey = key.substring(prefixLength + 1);
          publish(publishKey, void 0);
        }
      });
    },
    reset: function() {
      var storage = getStorage();
      Object.keys(storage).forEach(function(key) {
        if (key.startsWith(prefix)) {
          storage.removeItem(key);
          var publishKey = key.substring(prefixLength + 1);
          publish(publishKey, void 0);
        }
      });
    },
    subscribe: function(key, callback) {
      var id = Math.random().toString();
      subscriptions[id] = {
        key,
        callback
      };
      return function() {
        delete subscriptions[id];
      };
    }
  };
};
var tryParse = function(value) {
  try {
    return JSON.parse(value);
  } catch (e) {
    return value;
  }
};
var LocalStorageShim = (
  /** @class */
  function() {
    function LocalStorageShim2() {
      this.valuesMap = /* @__PURE__ */ new Map();
    }
    LocalStorageShim2.prototype.getItem = function(key) {
      if (this.valuesMap.has(key)) {
        return String(this.valuesMap.get(key));
      }
      return null;
    };
    LocalStorageShim2.prototype.setItem = function(key, value) {
      this.valuesMap.set(key, value);
    };
    LocalStorageShim2.prototype.removeItem = function(key) {
      this.valuesMap.delete(key);
    };
    LocalStorageShim2.prototype.removeItems = function(keyPrefix) {
      var _this = this;
      this.valuesMap.forEach(function(value, key) {
        if (key.startsWith(keyPrefix)) {
          _this.valuesMap.delete(key);
        }
      });
    };
    LocalStorageShim2.prototype.clear = function() {
      this.valuesMap.clear();
    };
    LocalStorageShim2.prototype.key = function(i) {
      if (arguments.length === 0) {
        throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");
      }
      var arr = Array.from(this.valuesMap.keys());
      return arr[i];
    };
    Object.defineProperty(LocalStorageShim2.prototype, "length", {
      get: function() {
        return this.valuesMap.size;
      },
      enumerable: false,
      configurable: true
    });
    return LocalStorageShim2;
  }()
);
var memoryStorage = new LocalStorageShim();
var getStorage = function() {
  return localStorageAvailable ? window.localStorage : memoryStorage;
};

// node_modules/ra-core/dist/esm/store/memoryStore.js
var import_set = __toESM(require_set());
var import_unset = __toESM(require_unset());
var import_get = __toESM(require_get());
var memoryStore = function(storage) {
  if (storage === void 0) {
    storage = {};
  }
  var subscriptions = {};
  var publish = function(key, value) {
    Object.keys(subscriptions).forEach(function(id) {
      if (!subscriptions[id])
        return;
      if (subscriptions[id].key === key) {
        subscriptions[id].callback(value);
      }
    });
  };
  return {
    setup: function() {
    },
    teardown: function() {
      Object.keys(storage).forEach(function(key) {
        return delete storage[key];
      });
    },
    getItem: function(key, defaultValue) {
      return (0, import_get.default)(storage, key, defaultValue);
    },
    setItem: function(key, value) {
      (0, import_set.default)(storage, key, value);
      publish(key, value);
    },
    removeItem: function(key) {
      (0, import_unset.default)(storage, key);
      publish(key, void 0);
    },
    removeItems: function(keyPrefix) {
      var flatStorage = flatten(storage);
      Object.keys(flatStorage).forEach(function(key) {
        if (!key.startsWith(keyPrefix)) {
          return;
        }
        (0, import_unset.default)(storage, key);
        publish(key, void 0);
      });
    },
    reset: function() {
      var flatStorage = flatten(storage);
      Object.keys(flatStorage).forEach(function(key) {
        (0, import_unset.default)(storage, key);
        publish(key, void 0);
      });
    },
    subscribe: function(key, callback) {
      var id = Math.random().toString();
      subscriptions[id] = {
        key,
        callback
      };
      return function() {
        delete subscriptions[id];
      };
    }
  };
};
var flatten = function(data) {
  var result = {};
  function doFlatten(current, prop) {
    if (Object(current) !== current) {
      result[prop] = current;
    } else if (Array.isArray(current)) {
      result[prop] = current;
    } else {
      var isEmpty3 = true;
      for (var p in current) {
        isEmpty3 = false;
        doFlatten(current[p], prop ? prop + "." + p : p);
      }
      if (isEmpty3 && prop)
        result[prop] = {};
    }
  }
  doFlatten(data, "");
  return result;
};

// node_modules/ra-core/dist/esm/store/StoreContext.js
var import_react3 = __toESM(require_react());
var defaultStore = memoryStore();
var StoreContext = (0, import_react3.createContext)(defaultStore);

// node_modules/ra-core/dist/esm/store/StoreContextProvider.js
var React = __toESM(require_react());
var import_react4 = __toESM(require_react());
var StoreContextProvider = function(_a11) {
  var Store = _a11.value, children = _a11.children;
  (0, import_react4.useEffect)(function() {
    Store.setup();
    return function() {
      Store.teardown();
    };
  }, [Store]);
  return React.createElement(StoreContext.Provider, { value: Store }, children);
};

// node_modules/ra-core/dist/esm/store/useStoreContext.js
var import_react5 = __toESM(require_react());
var useStoreContext = function() {
  return (0, import_react5.useContext)(StoreContext);
};

// node_modules/ra-core/dist/esm/store/StoreSetter.js
var React2 = __toESM(require_react());
var import_react6 = __toESM(require_react());
var StoreSetter = function(_a11) {
  var value = _a11.value, name = _a11.name, children = _a11.children;
  var setItem = useStoreContext().setItem;
  (0, import_react6.useEffect)(function() {
    setItem(name, value);
  }, [name, setItem, value]);
  return React2.createElement(React2.Fragment, null, children);
};

// node_modules/ra-core/dist/esm/util/escapePath.js
var escapePath_default = function(url) {
  return url.replace(/(\(|\))/g, "\\$1");
};

// node_modules/ra-core/dist/esm/i18n/substituteTokens.js
var substituteTokens = function(template, data) {
  return template && data ? String.prototype.replace.call(template, defaultTokenRegex, function(expression, argument) {
    if (!data.hasOwnProperty(argument) || data[argument] == null) {
      return expression;
    }
    return data[argument];
  }) : template;
};
var defaultTokenRegex = /%\{(.*?)\}/g;

// node_modules/ra-core/dist/esm/i18n/I18nContext.js
var import_react7 = __toESM(require_react());
var defaultI18nProvider = {
  translate: function(key, options) {
    return (options === null || options === void 0 ? void 0 : options._) ? substituteTokens(options._, options) : substituteTokens(key, options);
  },
  changeLocale: function() {
    return Promise.resolve();
  },
  getLocale: function() {
    return "en";
  }
};
var I18nContext = (0, import_react7.createContext)(defaultI18nProvider);
I18nContext.displayName = "I18nContext";

// node_modules/ra-core/dist/esm/notification/AddNotificationContext.js
var import_react8 = __toESM(require_react());
var AddNotificationContext = (0, import_react8.createContext)(function() {
});

// node_modules/ra-core/dist/esm/notification/NotificationContext.js
var import_react9 = __toESM(require_react());
var NotificationContext = (0, import_react9.createContext)({
  notifications: [],
  addNotification: function() {
  },
  takeNotification: function() {
  },
  resetNotifications: function() {
  },
  setNotifications: function() {
  }
});

// node_modules/ra-core/dist/esm/notification/NotificationContextProvider.js
var React3 = __toESM(require_react());
var import_react10 = __toESM(require_react());
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NotificationContextProvider = function(_a11) {
  var children = _a11.children;
  var _b = (0, import_react10.useState)([]), notifications = _b[0], setNotifications = _b[1];
  var addNotification = (0, import_react10.useCallback)(function(notification) {
    setNotifications(function(notifications2) {
      return __spreadArray(__spreadArray([], notifications2, true), [notification], false);
    });
  }, []);
  var takeNotification = (0, import_react10.useCallback)(function() {
    if (notifications.length === 0)
      return;
    var notification = notifications[0], rest = notifications.slice(1);
    setNotifications(rest);
    return notification;
  }, [notifications]);
  var resetNotifications = (0, import_react10.useCallback)(function() {
    setNotifications([]);
  }, []);
  var contextValue = (0, import_react10.useMemo)(
    function() {
      return {
        notifications,
        addNotification,
        takeNotification,
        resetNotifications,
        setNotifications
      };
    },
    [notifications]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return React3.createElement(
    NotificationContext.Provider,
    { value: contextValue },
    React3.createElement(AddNotificationContext.Provider, { value: addNotification }, children)
  );
};

// node_modules/ra-core/dist/esm/notification/useAddNotificationContext.js
var import_react11 = __toESM(require_react());
var useAddNotificationContext = function() {
  return (0, import_react11.useContext)(AddNotificationContext);
};

// node_modules/ra-core/dist/esm/notification/useNotificationContext.js
var import_react12 = __toESM(require_react());
var useNotificationContext = function() {
  return (0, import_react12.useContext)(NotificationContext);
};

// node_modules/ra-core/dist/esm/notification/useNotify.js
var import_react13 = __toESM(require_react());
var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useNotify = function() {
  var addNotification = useAddNotificationContext();
  return (0, import_react13.useCallback)(function(message2, options) {
    if (options === void 0) {
      options = {};
    }
    var _a11 = options.type, messageType = _a11 === void 0 ? "info" : _a11, notificationOptions = __rest(options, ["type"]);
    addNotification({
      message: message2,
      type: messageType,
      notificationOptions
    });
  }, [addNotification]);
};

// node_modules/ra-core/dist/esm/i18n/I18nContextProvider.js
var React66 = __toESM(require_react());
var import_react161 = __toESM(require_react());

// node_modules/ra-core/dist/esm/store/useStore.js
var import_react160 = __toESM(require_react());
var import_isEqual9 = __toESM(require_isEqual());

// node_modules/ra-core/dist/esm/util/FieldTitle.js
var React62 = __toESM(require_react());
var import_react154 = __toESM(require_react());

// node_modules/ra-core/dist/esm/i18n/TestTranslationProvider.js
var React4 = __toESM(require_react());
var import_get2 = __toESM(require_get());
var TestTranslationProvider = function(_a11) {
  var translate = _a11.translate, messages = _a11.messages, children = _a11.children;
  return React4.createElement(I18nContextProvider, { value: testI18nProvider({ translate, messages }) }, children);
};
var testI18nProvider = function(_a11) {
  var _b = _a11 === void 0 ? {} : _a11, translate = _b.translate, messages = _b.messages;
  return {
    translate: messages ? function(key, options) {
      var message2 = (0, import_get2.default)(messages, key);
      return message2 ? typeof message2 === "function" ? message2(options) : message2 : (options === null || options === void 0 ? void 0 : options._) || key;
    } : translate || function(key) {
      return key;
    },
    changeLocale: function() {
      return Promise.resolve();
    },
    getLocale: function() {
      return "en";
    }
  };
};

// node_modules/ra-core/dist/esm/i18n/TranslatableContext.js
var import_react14 = __toESM(require_react());
var TranslatableContext = (0, import_react14.createContext)(void 0);

// node_modules/ra-core/dist/esm/i18n/TranslatableContextProvider.js
var React5 = __toESM(require_react());
var TranslatableContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React5.createElement(TranslatableContext.Provider, { value }, children);
};

// node_modules/ra-core/dist/esm/i18n/TranslationUtils.js
var import_merge = __toESM(require_merge());
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var resolveBrowserLocale = function(defaultLocale, options) {
  var _a11 = window.navigator, language = _a11.language, browserLanguage = _a11.browserLanguage, userLanguage = _a11.userLanguage;
  var locale = language || browserLanguage || userLanguage || defaultLocale || DEFAULT_LOCALE;
  return (options === null || options === void 0 ? void 0 : options.fullLocale) ? locale : locale.split("-")[0];
};
var mergeTranslations = function() {
  var translationsModules = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    translationsModules[_i] = arguments[_i];
  }
  return import_merge.default.apply(void 0, __spreadArray2([{}], translationsModules, false));
};

// node_modules/ra-core/dist/esm/i18n/useLocaleState.js
var import_react16 = __toESM(require_react());

// node_modules/ra-core/dist/esm/i18n/useI18nProvider.js
var import_react15 = __toESM(require_react());
var useI18nProvider = function() {
  return (0, import_react15.useContext)(I18nContext);
};

// node_modules/ra-core/dist/esm/i18n/useLocaleState.js
var useLocaleState = function() {
  var i18nProvider = useI18nProvider();
  var defaultLocale = (0, import_react16.useMemo)(function() {
    return i18nProvider.getLocale();
  }, [i18nProvider]);
  return useStore("locale", defaultLocale);
};

// node_modules/ra-core/dist/esm/i18n/useLocale.js
var useLocale = function() {
  var locale = useLocaleState()[0];
  return locale;
};

// node_modules/ra-core/dist/esm/i18n/useLocales.js
var import_react17 = __toESM(require_react());
var useLocales = function(options) {
  var _a11;
  var i18nProvider = useI18nProvider();
  var locales = (0, import_react17.useMemo)(function() {
    return (i18nProvider === null || i18nProvider === void 0 ? void 0 : i18nProvider.getLocales) ? i18nProvider === null || i18nProvider === void 0 ? void 0 : i18nProvider.getLocales() : [];
  }, [i18nProvider]);
  return (_a11 = options === null || options === void 0 ? void 0 : options.locales) !== null && _a11 !== void 0 ? _a11 : locales;
};

// node_modules/ra-core/dist/esm/i18n/useSetLocale.js
var useSetLocale = function() {
  var _a11 = useLocaleState(), setLocale = _a11[1];
  return setLocale;
};

// node_modules/ra-core/dist/esm/i18n/useTranslatable.js
var import_react18 = __toESM(require_react());
var import_set2 = __toESM(require_set());
var import_get3 = __toESM(require_get());
var import_cloneDeep = __toESM(require_cloneDeep());
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useTranslatable = function(options) {
  var localeFromUI = useLocaleState()[0];
  var _a11 = options.defaultLocale, defaultLocale = _a11 === void 0 ? localeFromUI : _a11, locales = options.locales;
  var _b = (0, import_react18.useState)(defaultLocale), selectedLocale = _b[0], setSelectedLocale = _b[1];
  var context = (0, import_react18.useMemo)(function() {
    return {
      locales,
      selectedLocale,
      selectLocale: setSelectedLocale,
      getRecordForLocale
    };
  }, [locales, selectedLocale]);
  return context;
};
var getRecordForLocale = function(record, locale) {
  if (!record) {
    return record;
  }
  var paths = getRecordPaths(record);
  var recordForLocale = paths.reduce(function(acc, path) {
    if (path.includes(locale)) {
      var pathWithoutLocale = path.slice(0, -1);
      var value = (0, import_get3.default)(record, path);
      return (0, import_set2.default)(acc, pathWithoutLocale, value);
    }
    return acc;
  }, (0, import_cloneDeep.default)(record));
  return recordForLocale;
};
var getRecordPaths = function(record, path) {
  if (record === void 0) {
    record = {};
  }
  if (path === void 0) {
    path = [];
  }
  return Object.entries(record).reduce(function(acc, _a11) {
    var key = _a11[0], value = _a11[1];
    if (value !== null && typeof value === "object") {
      return __spreadArray3(__spreadArray3(__spreadArray3([], acc, true), [
        __spreadArray3(__spreadArray3([], path, true), [key], false)
      ], false), getRecordPaths(value, __spreadArray3(__spreadArray3([], path, true), [key], false)), true);
    }
    if (Array.isArray(value)) {
      return value.reduce(function(acc2, item, index) {
        return __spreadArray3(__spreadArray3([], acc2, true), getRecordPaths(item, __spreadArray3(__spreadArray3([], path, true), [key, "".concat(index)], false)), true);
      }, acc);
    }
    return __spreadArray3(__spreadArray3([], acc, true), [__spreadArray3(__spreadArray3([], path, true), [key], false)], false);
  }, []);
};

// node_modules/ra-core/dist/esm/i18n/useTranslatableContext.js
var import_react19 = __toESM(require_react());
var useTranslatableContext = function() {
  var context = (0, import_react19.useContext)(TranslatableContext);
  if (!context) {
    throw new Error("useTranslatableContext must be used inside a TranslatableContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/i18n/useTranslate.js
var import_react20 = __toESM(require_react());
var useTranslate = function() {
  var i18nProvider = useI18nProvider();
  var translate = (0, import_react20.useCallback)(
    function(key, options) {
      return i18nProvider.translate(key, options);
    },
    // update the hook each time the locale changes
    [i18nProvider]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return i18nProvider ? translate : identity;
};
var identity = function(key) {
  return key;
};

// node_modules/ra-core/dist/esm/i18n/useTranslateLabel.js
var import_react153 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/CoreAdmin.js
var React57 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/CoreAdminContext.js
var React52 = __toESM(require_react());
var import_react142 = __toESM(require_react());

// node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return !Object.keys(b).some((key) => !partialMatchKey(a[key], b[key]));
  }
  return false;
}
function replaceEqualDeep(a, b) {
  if (a === b) {
    return a;
  }
  const array = isPlainArray(a) && isPlainArray(b);
  if (array || isPlainObject(a) && isPlainObject(b)) {
    const aItems = array ? a : Object.keys(a);
    const aSize = aItems.length;
    const bItems = array ? b : Object.keys(b);
    const bSize = bItems.length;
    const copy = array ? [] : {};
    let equalItems = 0;
    for (let i = 0; i < bSize; i++) {
      const key = array ? i : bItems[i];
      if ((!array && aItems.includes(key) || array) && a[key] === void 0 && b[key] === void 0) {
        copy[key] = void 0;
        equalItems++;
      } else {
        copy[key] = replaceEqualDeep(a[key], b[key]);
        if (copy[key] === a[key] && a[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return aSize === bSize && equalItems === aSize ? a : copy;
  }
  return b;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (true) {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (true) {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var _focused, _cleanup, _setup, _a;
var FocusManager = (_a = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a11;
    if (!this.hasListeners()) {
      (_a11 = __privateGet(this, _cleanup)) == null ? void 0 : _a11.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a11;
    __privateSet(this, _setup, setup);
    (_a11 = __privateGet(this, _cleanup)) == null ? void 0 : _a11.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a11;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a11 = globalThis.document) == null ? void 0 : _a11.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a);
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
var _online, _cleanup2, _setup2, _a2;
var OnlineManager = (_a2 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a11;
    if (!this.hasListeners()) {
      (_a11 = __privateGet(this, _cleanup2)) == null ? void 0 : _a11.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a11;
    __privateSet(this, _setup2, setup);
    (_a11 = __privateGet(this, _cleanup2)) == null ? void 0 : _a11.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online) {
    const changed = __privateGet(this, _online) !== online;
    if (changed) {
      __privateSet(this, _online, online);
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _a2);
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function isCancelledError(value) {
  return value instanceof CancelledError;
}
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let isResolved = false;
  let continueFn;
  const thenable = pendingThenable();
  const cancel = (cancelOptions) => {
    var _a11;
    if (!isResolved) {
      reject(new CancelledError(cancelOptions));
      (_a11 = config.abort) == null ? void 0 : _a11.call(config);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    var _a11;
    if (!isResolved) {
      isResolved = true;
      (_a11 = config.onSuccess) == null ? void 0 : _a11.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    var _a11;
    if (!isResolved) {
      isResolved = true;
      (_a11 = config.onError) == null ? void 0 : _a11.call(config, value);
      continueFn == null ? void 0 : continueFn();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a11;
      continueFn = (value) => {
        if (isResolved || canContinue()) {
          continueResolve(value);
        }
      };
      (_a11 = config.onPause) == null ? void 0 : _a11.call(config);
    }).then(() => {
      var _a11;
      continueFn = void 0;
      if (!isResolved) {
        (_a11 = config.onContinue) == null ? void 0 : _a11.call(config);
      }
    });
  };
  const run = () => {
    if (isResolved) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a11;
      if (isResolved) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a11 = config.onFail) == null ? void 0 : _a11.call(config, failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = (cb) => setTimeout(cb, 0);
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/removable.js
var _gcTimeout, _a3;
var Removable = (_a3 = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _a3);

// node_modules/@tanstack/query-core/build/modern/query.js
var _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _a4;
var Query = (_a4 = class extends Removable {
  constructor(config) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _client);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config.defaultOptions);
    this.setOptions(config.options);
    this.observers = [];
    __privateSet(this, _client, config.client);
    __privateSet(this, _cache, __privateGet(this, _client).getQueryCache());
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    __privateSet(this, _initialState, getDefaultState(this.options));
    this.state = config.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a11;
    return (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a11, _b;
    const promise = (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.promise;
    (_b = __privateGet(this, _retryer)) == null ? void 0 : _b.cancel(options);
    return promise ? promise.then(noop).catch(noop) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    if (this.state.isInvalidated) {
      return true;
    }
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0;
  }
  isStaleByTime(staleTime = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a11;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.continue();
  }
  onOnline() {
    var _a11;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a11 = __privateGet(this, _retryer)) == null ? void 0 : _a11.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  fetch(options, fetchOptions) {
    var _a11, _b, _c;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (true) {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(
          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
        );
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const queryFnContext = {
        client: __privateGet(this, _client),
        queryKey: this.queryKey,
        meta: this.meta
      };
      addSignalProperty(queryFnContext);
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const context = {
      fetchOptions,
      options: this.options,
      queryKey: this.queryKey,
      client: __privateGet(this, _client),
      state: this.state,
      fetchFn
    };
    addSignalProperty(context);
    (_a11 = this.options.behavior) == null ? void 0 : _a11.onFetch(
      context,
      this
    );
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_b = context.fetchOptions) == null ? void 0 : _b.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_c = context.fetchOptions) == null ? void 0 : _c.meta });
    }
    const onError = (error) => {
      var _a12, _b2, _c2, _d;
      if (!(isCancelledError(error) && error.silent)) {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
          type: "error",
          error
        });
      }
      if (!isCancelledError(error)) {
        (_b2 = (_a12 = __privateGet(this, _cache).config).onError) == null ? void 0 : _b2.call(
          _a12,
          error,
          this
        );
        (_d = (_c2 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d.call(
          _c2,
          this.state.data,
          error,
          this
        );
      }
      this.scheduleGc();
    };
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      abort: abortController.abort.bind(abortController),
      onSuccess: (data) => {
        var _a12, _b2, _c2, _d;
        if (data === void 0) {
          if (true) {
            console.error(
              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
            );
          }
          onError(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(data);
        } catch (error) {
          onError(error);
          return;
        }
        (_b2 = (_a12 = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _b2.call(_a12, data, this);
        (_d = (_c2 = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _d.call(
          _c2,
          data,
          this.state.error,
          this
        );
        this.scheduleGc();
      },
      onError,
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    return __privateGet(this, _retryer).start();
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _client = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        return {
          ...state,
          data: action.data,
          dataUpdateCount: state.dataUpdateCount + 1,
          dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const error = action.error;
        if (isCancelledError(error) && error.revert && __privateGet(this, _revertState)) {
          return { ...__privateGet(this, _revertState), fetchStatus: "idle" };
        }
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _a4);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryCache.js
var _queries, _a5;
var QueryCache = (_a5 = class extends Subscribable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _a5);

// node_modules/@tanstack/query-core/build/modern/mutation.js
var _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _a6;
var Mutation = (_a6 = class extends Removable {
  constructor(config) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    this.mutationId = config.mutationId;
    __privateSet(this, _mutationCache, config.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config.state || getDefaultState2();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x) => x !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a11;
    return ((_a11 = __privateGet(this, _retryer2)) == null ? void 0 : _a11.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t;
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (!restored) {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        await ((_b = (_a11 = __privateGet(this, _mutationCache).config).onMutate) == null ? void 0 : _b.call(
          _a11,
          variables,
          this
        ));
        const context = await ((_d = (_c = this.options).onMutate) == null ? void 0 : _d.call(_c, variables));
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_f = (_e = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _f.call(
        _e,
        data,
        variables,
        this.state.context,
        this
      ));
      await ((_h = (_g = this.options).onSuccess) == null ? void 0 : _h.call(_g, data, variables, this.state.context));
      await ((_j = (_i = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _j.call(
        _i,
        data,
        null,
        this.state.variables,
        this.state.context,
        this
      ));
      await ((_l = (_k = this.options).onSettled) == null ? void 0 : _l.call(_k, data, null, variables, this.state.context));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_n = (_m = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _n.call(
          _m,
          error,
          variables,
          this.state.context,
          this
        ));
        await ((_p = (_o = this.options).onError) == null ? void 0 : _p.call(
          _o,
          error,
          variables,
          this.state.context
        ));
        await ((_r = (_q = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this
        ));
        await ((_t = (_s = this.options).onSettled) == null ? void 0 : _t.call(
          _s,
          void 0,
          error,
          variables,
          this.state.context
        ));
        throw error;
      } finally {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      }
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _a6);
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var _mutations, _scopes, _mutationId, _a7;
var MutationCache = (_a7 = class extends Subscribable {
  constructor(config = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _scopes);
    __privateAdd(this, _mutationId);
    this.config = config;
    __privateSet(this, _mutations, /* @__PURE__ */ new Set());
    __privateSet(this, _scopes, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, 0);
  }
  build(client, options, state) {
    const mutation = new Mutation({
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    __privateGet(this, _mutations).add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = __privateGet(this, _scopes).get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        __privateGet(this, _scopes).set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (__privateGet(this, _mutations).delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index = scopedMutations.indexOf(mutation);
            if (index !== -1) {
              scopedMutations.splice(index, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            __privateGet(this, _scopes).delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
      const firstPendingMutation = mutationsWithSameScope == null ? void 0 : mutationsWithSameScope.find(
        (m) => m.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    var _a11;
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = (_a11 = __privateGet(this, _scopes).get(scope)) == null ? void 0 : _a11.find((m) => m !== mutation && m.state.isPaused);
      return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      __privateGet(this, _mutations).forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      __privateGet(this, _mutations).clear();
      __privateGet(this, _scopes).clear();
    });
  }
  getAll() {
    return Array.from(__privateGet(this, _mutations));
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop))
      )
    );
  }
}, _mutations = new WeakMap(), _scopes = new WeakMap(), _mutationId = new WeakMap(), _a7);
function scopeFor(mutation) {
  var _a11;
  return (_a11 = mutation.options.scope) == null ? void 0 : _a11.id;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      var _a11, _b, _c, _d, _e;
      const options = context.options;
      const direction = (_c = (_b = (_a11 = context.fetchOptions) == null ? void 0 : _a11.meta) == null ? void 0 : _b.fetchMore) == null ? void 0 : _c.direction;
      const oldPages = ((_d = context.state.data) == null ? void 0 : _d.pages) || [];
      const oldPageParams = ((_e = context.state.data) == null ? void 0 : _e.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const queryFnContext = {
            client: context.client,
            queryKey: context.queryKey,
            pageParam: param,
            direction: previous ? "backward" : "forward",
            meta: context.options.meta
          };
          addSignalProperty(queryFnContext);
          const page = await queryFn(
            queryFnContext
          );
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a12, _b2;
          return (_b2 = (_a12 = context.options).persister) == null ? void 0 : _b2.call(
            _a12,
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a11;
  return pages.length > 0 ? (_a11 = options.getPreviousPageParam) == null ? void 0 : _a11.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}
function hasNextPage(options, data) {
  if (!data)
    return false;
  return getNextPageParam(options, data) != null;
}
function hasPreviousPage(options, data) {
  if (!data || !options.getPreviousPageParam)
    return false;
  return getPreviousPageParam(options, data) != null;
}

// node_modules/@tanstack/query-core/build/modern/queryClient.js
var _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _a8;
var QueryClient = (_a8 = class {
  constructor(config = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1)
      return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a11, _b;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0)
      return;
    (_a11 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a11.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  getQueryData(queryKey) {
    var _a11;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a11 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a11.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a11;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a11 = __privateGet(this, _queryCache).get(
      options.queryHash
    )) == null ? void 0 : _a11.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    const refetchFilters = {
      type: "active",
      ...filters
    };
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(refetchFilters, options);
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop).catch(noop);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if ((filters == null ? void 0 : filters.refetchType) === "none") {
        return Promise.resolve();
      }
      const refetchFilters = {
        ...filters,
        type: (filters == null ? void 0 : filters.refetchType) ?? (filters == null ? void 0 : filters.type) ?? "active"
      };
      return this.refetchQueries(refetchFilters, options);
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop).catch(noop);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop).catch(noop);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults3 = [...__privateGet(this, _queryDefaults).values()];
    const result = {};
    defaults3.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults3 = [...__privateGet(this, _mutationDefaults).values()];
    let result = {};
    defaults3.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        result = { ...result, ...queryDefault.defaultOptions };
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _a8);

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var _client2, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _a9;
var QueryObserver = (_a9 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _currentThenable);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client2, client);
    __privateSet(this, _selectError, null);
    __privateSet(this, _currentThenable, pendingThenable());
    if (!this.options.experimental_prefetchInRender) {
      __privateGet(this, _currentThenable).reject(
        new Error("experimental_prefetchInRender feature flag is not enabled")
      );
    }
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options, notifyOptions) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client2).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult(notifyOptions);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    const trackedResult = {};
    Object.keys(result).forEach((key) => {
      Object.defineProperty(trackedResult, key, {
        configurable: false,
        enumerable: true,
        get: () => {
          this.trackProp(key);
          onPropTracked == null ? void 0 : onPropTracked(key);
          return result[key];
        }
      });
    });
    return trackedResult;
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client2).defaultQueryOptions(options);
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a11;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    if (options.select && newState.data !== void 0) {
      if (prevResult && newState.data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(newState.data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    } else {
      data = newState.data;
    }
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a11 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a11.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
        if (options.select && placeholderData !== void 0) {
          try {
            placeholderData = options.select(placeholderData);
            __privateSet(this, _selectError, null);
          } catch (selectError) {
            __privateSet(this, _selectError, selectError);
          }
        }
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: __privateGet(this, _currentThenable)
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = __privateGet(this, _currentThenable);
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult(notifyOptions) {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const defaultNotifyOptions = {};
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    if ((notifyOptions == null ? void 0 : notifyOptions.listeners) !== false && shouldNotifyListeners()) {
      defaultNotifyOptions.listeners = true;
    }
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { ...defaultNotifyOptions, ...notifyOptions });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client2 = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise = promise.catch(noop);
  }
  return promise;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time + 1;
  __privateSet(this, _staleTimeoutId, setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client2).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _a9);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false) {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js
var InfiniteQueryObserver = class extends QueryObserver {
  constructor(client, options) {
    super(client, options);
  }
  bindMethods() {
    super.bindMethods();
    this.fetchNextPage = this.fetchNextPage.bind(this);
    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);
  }
  setOptions(options, notifyOptions) {
    super.setOptions(
      {
        ...options,
        behavior: infiniteQueryBehavior()
      },
      notifyOptions
    );
  }
  getOptimisticResult(options) {
    options.behavior = infiniteQueryBehavior();
    return super.getOptimisticResult(options);
  }
  fetchNextPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "forward" }
      }
    });
  }
  fetchPreviousPage(options) {
    return this.fetch({
      ...options,
      meta: {
        fetchMore: { direction: "backward" }
      }
    });
  }
  createResult(query, options) {
    var _a11, _b;
    const { state } = query;
    const parentResult = super.createResult(query, options);
    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;
    const fetchDirection = (_b = (_a11 = state.fetchMeta) == null ? void 0 : _a11.fetchMore) == null ? void 0 : _b.direction;
    const isFetchNextPageError = isError && fetchDirection === "forward";
    const isFetchingNextPage = isFetching && fetchDirection === "forward";
    const isFetchPreviousPageError = isError && fetchDirection === "backward";
    const isFetchingPreviousPage = isFetching && fetchDirection === "backward";
    const result = {
      ...parentResult,
      fetchNextPage: this.fetchNextPage,
      fetchPreviousPage: this.fetchPreviousPage,
      hasNextPage: hasNextPage(options, state.data),
      hasPreviousPage: hasPreviousPage(options, state.data),
      isFetchNextPageError,
      isFetchingNextPage,
      isFetchPreviousPageError,
      isFetchingPreviousPage,
      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,
      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage
    };
    return result;
  }
};

// node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var _client3, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _a10;
var MutationObserver = (_a10 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client3);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client3, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a11;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client3).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client3).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a11;
    if (!this.hasListeners()) {
      (_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a11;
    (_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a11;
    __privateSet(this, _mutateOptions, options);
    (_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client3).getMutationCache().build(__privateGet(this, _client3), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client3 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a11;
  const state = ((_a11 = __privateGet(this, _currentMutation)) == null ? void 0 : _a11.state) ?? getDefaultState2();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a11, _b, _c, _d, _e, _f, _g, _h;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const context = __privateGet(this, _currentResult2).context;
      if ((action == null ? void 0 : action.type) === "success") {
        (_b = (_a11 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b.call(_a11, action.data, variables, context);
        (_d = (_c = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d.call(_c, action.data, null, variables, context);
      } else if ((action == null ? void 0 : action.type) === "error") {
        (_f = (_e = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f.call(_e, action.error, variables, context);
        (_h = (_g = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h.call(
          _g,
          void 0,
          action.error,
          variables,
          context
        );
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _a10);

// node_modules/@tanstack/query-core/build/modern/types.js
var dataTagSymbol = Symbol("dataTagSymbol");
var dataTagErrorSymbol = Symbol("dataTagErrorSymbol");
var unsetMarker = Symbol("unsetMarker");

// node_modules/@tanstack/react-query/build/modern/useQueries.js
var React10 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React6 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React6.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = React6.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};
var QueryClientProvider = ({
  client,
  children
}) => {
  React6.useEffect(() => {
    client.mount();
    return () => {
      client.unmount();
    };
  }, [client]);
  return (0, import_jsx_runtime.jsx)(QueryClientContext.Provider, { value: client, children });
};

// node_modules/@tanstack/react-query/build/modern/isRestoring.js
var React7 = __toESM(require_react(), 1);
var IsRestoringContext = React7.createContext(false);
var useIsRestoring = () => React7.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React8.createContext(createValue());
var useQueryErrorResetBoundary = () => React8.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/utils.js
function shouldThrowError(throwError, params) {
  if (typeof throwError === "function") {
    return throwError(...params);
  }
  return !!throwError;
}
function noop2() {
}

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React9.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  const originalStaleTime = defaultedOptions.staleTime;
  if (defaultedOptions.suspense) {
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => Math.max(originalStaleTime(...args), 1e3) : Math.max(originalStaleTime ?? 1e3, 1e3);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(defaultedOptions.gcTime, 1e3);
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React11 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer, queryClient) {
  var _a11, _b, _c, _d, _e;
  if (true) {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const client = useQueryClient(queryClient);
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b = (_a11 = client.getDefaultOptions().queries) == null ? void 0 : _a11._experimental_beforeQuery) == null ? void 0 : _b.call(
    _a11,
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React11.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React11.useSyncExternalStore(
    React11.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop2;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React11.useEffect(() => {
    observer.setOptions(defaultedOptions, { listeners: false });
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  ;
  (_d = (_c = client.getDefaultOptions().queries) == null ? void 0 : _c._experimental_afterQuery) == null ? void 0 : _d.call(
    _c,
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (_e = client.getQueryCache().get(defaultedOptions.queryHash)) == null ? void 0 : _e.promise
    );
    promise == null ? void 0 : promise.catch(noop2).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver, queryClient);
}

// node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js
var React12 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useIsFetching.js
var React13 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutationState.js
var React14 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutation.js
var React15 = __toESM(require_react(), 1);
function useMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const [observer] = React15.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  React15.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React15.useSyncExternalStore(
    React15.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React15.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop2);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js
function useInfiniteQuery(options, queryClient) {
  return useBaseQuery(
    options,
    InfiniteQueryObserver,
    queryClient
  );
}

// node_modules/ra-core/dist/esm/routing/AdminRouter.js
var React17 = __toESM(require_react());

// node_modules/ra-core/dist/esm/routing/BasenameContextProvider.js
var React16 = __toESM(require_react());

// node_modules/ra-core/dist/esm/routing/BasenameContext.js
var import_react21 = __toESM(require_react());
var BasenameContext = (0, import_react21.createContext)("");

// node_modules/ra-core/dist/esm/routing/BasenameContextProvider.js
var BasenameContextProvider = function(_a11) {
  var children = _a11.children, basename = _a11.basename;
  return React16.createElement(BasenameContext.Provider, { value: basename }, children);
};

// node_modules/ra-core/dist/esm/routing/AdminRouter.js
var AdminRouter = function(_a11) {
  var _b = _a11.basename, basename = _b === void 0 ? "" : _b, children = _a11.children;
  var isInRouter = useInRouterContext();
  var Router = isInRouter ? DummyRouter : InternalRouter;
  return React17.createElement(
    BasenameContextProvider,
    { basename: isInRouter ? basename : "" },
    React17.createElement(Router, { basename }, children)
  );
};
var DummyRouter = function(_a11) {
  var children = _a11.children;
  return React17.createElement(React17.Fragment, null, children);
};
var routerProviderFuture = { v7_startTransition: false, v7_relativeSplatPath: false };
var InternalRouter = function(_a11) {
  var children = _a11.children, basename = _a11.basename;
  var router = createHashRouter([{ path: "*", element: React17.createElement(React17.Fragment, null, children) }], {
    basename,
    future: {
      v7_fetcherPersist: false,
      v7_normalizeFormMethod: false,
      v7_partialHydration: false,
      v7_relativeSplatPath: false,
      v7_skipActionErrorRevalidation: false
    }
  });
  return React17.createElement(RouterProvider2, { router, future: routerProviderFuture });
};

// node_modules/ra-core/dist/esm/routing/useRestoreScrollPosition.js
var import_react24 = __toESM(require_react());
var import_debounce = __toESM(require_debounce());

// node_modules/ra-core/dist/esm/store/useRemoveFromStore.js
var import_react22 = __toESM(require_react());
var useRemoveFromStore = function(hookTimeKey) {
  var removeItem = useStoreContext().removeItem;
  return (0, import_react22.useCallback)(function(key) {
    if (typeof key === "undefined" && typeof hookTimeKey === "undefined") {
      throw new Error("You must provide a key to remove an item from the store");
    }
    return removeItem(key !== null && key !== void 0 ? key : hookTimeKey);
  }, [removeItem, hookTimeKey]);
};

// node_modules/ra-core/dist/esm/store/useRemoveItemsFromStore.js
var import_react23 = __toESM(require_react());
var useRemoveItemsFromStore = function(hookTimeKeyPrefix) {
  var removeItems = useStoreContext().removeItems;
  return (0, import_react23.useCallback)(function(keyPrefix) {
    if (typeof keyPrefix === "undefined" && typeof hookTimeKeyPrefix === "undefined") {
      throw new Error("You must provide a key to remove an item from the store");
    }
    return removeItems(keyPrefix !== null && keyPrefix !== void 0 ? keyPrefix : hookTimeKeyPrefix);
  }, [removeItems, hookTimeKeyPrefix]);
};

// node_modules/ra-core/dist/esm/store/useResetStore.js
var useResetStore = function() {
  var reset = useStoreContext().reset;
  return reset;
};

// node_modules/ra-core/dist/esm/routing/useRestoreScrollPosition.js
var useRestoreScrollPosition = function(storeKey, debounceMs) {
  if (debounceMs === void 0) {
    debounceMs = 250;
  }
  var _a11 = useTrackScrollPosition(storeKey, debounceMs), position = _a11[0], setPosition = _a11[1];
  var location = useLocation();
  (0, import_react24.useEffect)(function() {
    var _a12;
    if (position != null && ((_a12 = location.state) === null || _a12 === void 0 ? void 0 : _a12._scrollToTop) !== true) {
      setPosition(void 0);
      window.scrollTo(0, position);
    }
  }, []);
};
var useTrackScrollPosition = function(storeKey, debounceMs) {
  if (debounceMs === void 0) {
    debounceMs = 250;
  }
  var _a11 = useStore(storeKey), position = _a11[0], setPosition = _a11[1];
  (0, import_react24.useEffect)(function() {
    if (typeof window === "undefined") {
      return;
    }
    var handleScroll = (0, import_debounce.default)(function() {
      setPosition(window.scrollY);
    }, debounceMs);
    window.addEventListener("scroll", handleScroll);
    return function() {
      window.removeEventListener("scroll", handleScroll);
    };
  }, [debounceMs, setPosition]);
  return [position, setPosition];
};

// node_modules/ra-core/dist/esm/routing/RestoreScrollPosition.js
var RestoreScrollPosition = function(_a11) {
  var children = _a11.children, storeKey = _a11.storeKey, _b = _a11.debounce, debounce5 = _b === void 0 ? 250 : _b;
  useRestoreScrollPosition(storeKey, debounce5);
  return children;
};

// node_modules/ra-core/dist/esm/routing/useBasename.js
var import_react25 = __toESM(require_react());
var useBasename = function() {
  return (0, import_react25.useContext)(BasenameContext);
};

// node_modules/ra-core/dist/esm/routing/useCreatePath.js
var import_react26 = __toESM(require_react());
var useCreatePath = function() {
  var basename = useBasename();
  return (0, import_react26.useCallback)(function(_a11) {
    var resource = _a11.resource, id = _a11.id, type = _a11.type;
    if (["list", "create", "edit", "show"].includes(type) && !resource) {
      throw new Error("Cannot create a link without a resource. You must provide the resource name.");
    }
    switch (type) {
      case "list":
        return removeDoubleSlashes("".concat(basename, "/").concat(resource));
      case "create":
        return removeDoubleSlashes("".concat(basename, "/").concat(resource, "/create"));
      case "edit": {
        if (id == null) {
          return removeDoubleSlashes("".concat(basename, "/").concat(resource));
        }
        return removeDoubleSlashes("".concat(basename, "/").concat(resource, "/").concat(encodeURIComponent(id)));
      }
      case "show": {
        if (id == null) {
          return removeDoubleSlashes("".concat(basename, "/").concat(resource));
        }
        return removeDoubleSlashes("".concat(basename, "/").concat(resource, "/").concat(encodeURIComponent(id), "/show"));
      }
      default:
        return type;
    }
  }, [basename]);
};
var removeDoubleSlashes = function(path) {
  return path.replace("//", "/");
};

// node_modules/ra-core/dist/esm/routing/useGetPathForRecord.js
var import_react133 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/useResourceContext.js
var import_react28 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/ResourceContext.js
var import_react27 = __toESM(require_react());
var ResourceContext = (0, import_react27.createContext)(void 0);

// node_modules/ra-core/dist/esm/core/useResourceContext.js
var useResourceContext = function(props) {
  var context = (0, import_react28.useContext)(ResourceContext);
  return props && props.resource || context;
};

// node_modules/ra-core/dist/esm/controller/record/useRecordContext.js
var import_react30 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/record/RecordContext.js
var React18 = __toESM(require_react());
var import_react29 = __toESM(require_react());
var RecordContext = (0, import_react29.createContext)(void 0);
RecordContext.displayName = "RecordContext";
var RecordContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React18.createElement(RecordContext.Provider, { value }, children);
};

// node_modules/ra-core/dist/esm/controller/record/useRecordContext.js
var useRecordContext = function(props) {
  var context = (0, import_react30.useContext)(RecordContext);
  return props && props.record || context;
};

// node_modules/ra-core/dist/esm/auth/useAuthState.js
var import_react32 = __toESM(require_react());

// node_modules/ra-core/dist/esm/auth/useLogout.js
var import_react31 = __toESM(require_react());
var useLogout = function() {
  var authProvider = useAuthProvider_default();
  var queryClient = useQueryClient();
  var resetStore = useResetStore();
  var navigate = useNavigate();
  var navigateRef = (0, import_react31.useRef)(navigate);
  var location = useLocation();
  var locationRef = (0, import_react31.useRef)(location);
  var basename = useBasename();
  var loginUrl = removeDoubleSlashes("".concat(basename, "/").concat(defaultAuthParams.loginUrl));
  (0, import_react31.useEffect)(function() {
    locationRef.current = location;
    navigateRef.current = navigate;
  }, [location, navigate]);
  var logout = (0, import_react31.useCallback)(function(params, redirectTo, redirectToCurrentLocationAfterLogin) {
    if (params === void 0) {
      params = {};
    }
    if (redirectTo === void 0) {
      redirectTo = loginUrl;
    }
    if (redirectToCurrentLocationAfterLogin === void 0) {
      redirectToCurrentLocationAfterLogin = true;
    }
    if (authProvider) {
      return authProvider.logout(params).then(function(redirectToFromProvider) {
        if (redirectToFromProvider === false || redirectTo === false) {
          resetStore();
          queryClient.clear();
          return;
        }
        var finalRedirectTo = redirectToFromProvider || redirectTo;
        if (finalRedirectTo === null || finalRedirectTo === void 0 ? void 0 : finalRedirectTo.startsWith("http")) {
          resetStore();
          queryClient.clear();
          window.location.href = finalRedirectTo;
          return finalRedirectTo;
        }
        var redirectToParts = finalRedirectTo.split("?");
        var newLocation = {
          pathname: redirectToParts[0]
        };
        var newLocationOptions = {};
        if (redirectToCurrentLocationAfterLogin && locationRef.current && locationRef.current.pathname) {
          newLocationOptions = {
            state: {
              nextPathname: locationRef.current.pathname,
              nextSearch: locationRef.current.search
            }
          };
        }
        if (redirectToParts[1]) {
          newLocation.search = redirectToParts[1];
        }
        navigateRef.current(newLocation, newLocationOptions);
        resetStore();
        queryClient.clear();
        return redirectToFromProvider;
      });
    } else {
      navigateRef.current({
        pathname: loginUrl
      }, {
        state: {
          nextPathname: locationRef.current && locationRef.current.pathname
        }
      });
      resetStore();
      queryClient.clear();
      return Promise.resolve();
    }
  }, [authProvider, resetStore, loginUrl, queryClient]);
  return logout;
};
var useLogout_default = useLogout;

// node_modules/ra-core/dist/esm/auth/useAuthState.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var emptyParams = {};
var useAuthState = function(params, logoutOnFailure, queryOptions2) {
  if (params === void 0) {
    params = emptyParams;
  }
  if (logoutOnFailure === void 0) {
    logoutOnFailure = false;
  }
  if (queryOptions2 === void 0) {
    queryOptions2 = emptyParams;
  }
  var authProvider = useAuthProvider_default();
  var logout = useLogout_default();
  var basename = useBasename();
  var notify = useNotify();
  var onSuccess = queryOptions2.onSuccess, onError = queryOptions2.onError, onSettled = queryOptions2.onSettled, options = __rest2(queryOptions2, ["onSuccess", "onError", "onSettled"]);
  var queryResult = useQuery(__assign({ queryKey: ["auth", "checkAuth", params], queryFn: function(_a11) {
    var signal = _a11.signal;
    if (!authProvider) {
      return true;
    }
    return authProvider.checkAuth(__assign(__assign({}, params), { signal })).then(function() {
      return true;
    }).catch(function(error) {
      if (error != null) {
        throw error;
      }
      throw new Error();
    });
  }, retry: false }, options));
  var onSuccessEvent = useEvent(onSuccess !== null && onSuccess !== void 0 ? onSuccess : noop3);
  var onSettledEvent = useEvent(onSettled !== null && onSettled !== void 0 ? onSettled : noop3);
  var onErrorEvent = useEvent(onError !== null && onError !== void 0 ? onError : function(error) {
    if (!logoutOnFailure)
      return;
    var loginUrl = removeDoubleSlashes("".concat(basename, "/").concat(defaultAuthParams.loginUrl));
    logout({}, error && error.redirectTo != null ? error.redirectTo : loginUrl);
    var shouldSkipNotify = error && error.message === false;
    !shouldSkipNotify && notify(getErrorMessage(error, "ra.auth.auth_check_error"), {
      type: "error"
    });
  });
  (0, import_react32.useEffect)(function() {
    if (queryResult.data === void 0 || queryResult.isFetching)
      return;
    if (queryOptions2.enabled === false)
      return;
    onSuccessEvent(queryResult.data);
  }, [
    onSuccessEvent,
    queryResult.data,
    queryResult.isFetching,
    queryOptions2.enabled
  ]);
  (0, import_react32.useEffect)(function() {
    if (queryResult.error == null || queryResult.isFetching)
      return;
    if (queryOptions2.enabled === false)
      return;
    onErrorEvent(queryResult.error);
  }, [
    onErrorEvent,
    queryResult.error,
    queryResult.isFetching,
    queryOptions2.enabled
  ]);
  (0, import_react32.useEffect)(function() {
    if (queryResult.status === "pending" || queryResult.isFetching)
      return;
    if (queryOptions2.enabled === false)
      return;
    onSettledEvent(queryResult.data, queryResult.error);
  }, [
    onSettledEvent,
    queryResult.data,
    queryResult.error,
    queryResult.status,
    queryResult.isFetching,
    queryOptions2.enabled
  ]);
  var result = (0, import_react32.useMemo)(function() {
    return __assign(__assign({}, queryResult), { authenticated: queryResult.error ? false : queryResult.data });
  }, [queryResult]);
  return authProvider != null ? result : noAuthProviderQueryResult;
};
var useAuthState_default = useAuthState;
var getErrorMessage = function(error, defaultMessage) {
  return typeof error === "string" ? error : typeof error === "undefined" || !error.message ? defaultMessage : error.message;
};
var noop3 = function() {
};
var noAuthProviderQueryResult = {
  authenticated: true,
  data: true,
  dataUpdatedAt: 0,
  error: null,
  errorUpdatedAt: 0,
  errorUpdateCount: 0,
  failureCount: 0,
  failureReason: null,
  fetchStatus: "idle",
  isError: false,
  isInitialLoading: false,
  isLoading: false,
  isLoadingError: false,
  isFetched: true,
  isFetchedAfterMount: true,
  isFetching: false,
  isPaused: false,
  isPlaceholderData: false,
  isPending: false,
  isRefetchError: false,
  isRefetching: false,
  isStale: false,
  isSuccess: true,
  status: "success",
  refetch: function() {
    return Promise.resolve(noAuthProviderQueryResult);
  }
};

// node_modules/ra-core/dist/esm/auth/usePermissions.js
var import_react34 = __toESM(require_react());

// node_modules/ra-core/dist/esm/auth/useLogoutIfAccessDenied.js
var import_react33 = __toESM(require_react());
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var timer;
var useLogoutIfAccessDenied = function() {
  var authProvider = useAuthProvider_default();
  var logout = useLogout_default();
  var notify = useNotify();
  var navigate = useNavigate();
  var logoutIfAccessDenied = (0, import_react33.useCallback)(function(error) {
    if (!authProvider) {
      return logoutIfAccessDeniedWithoutProvider();
    }
    return authProvider.checkError(error).then(function() {
      return false;
    }).catch(function(e) {
      return __awaiter(void 0, void 0, void 0, function() {
        var logoutUser, redirectTo, shouldNotify;
        var _a11;
        return __generator(this, function(_b) {
          logoutUser = (_a11 = e === null || e === void 0 ? void 0 : e.logoutUser) !== null && _a11 !== void 0 ? _a11 : true;
          if (timer) {
            return [2, true];
          }
          timer = setTimeout(function() {
            timer = void 0;
          }, 0);
          redirectTo = e && e.redirectTo != null ? e.redirectTo : error && error.redirectTo ? error.redirectTo : void 0;
          shouldNotify = !(e && e.message === false || error && error.message === false || (redirectTo === null || redirectTo === void 0 ? void 0 : redirectTo.startsWith("http")));
          if (shouldNotify) {
            authProvider.checkAuth({}).then(function() {
              if (logoutUser) {
                notify(getErrorMessage2(e, "ra.notification.logged_out"), { type: "error" });
              } else {
                notify(getErrorMessage2(e, "ra.notification.not_authorized"), { type: "error" });
              }
            }).catch(function() {
            });
          }
          if (logoutUser) {
            logout({}, redirectTo);
          } else {
            if (redirectTo.startsWith("http")) {
              window.location.href = redirectTo;
            } else {
              navigate(redirectTo);
            }
          }
          return [2, true];
        });
      });
    });
  }, [authProvider, logout, notify, navigate]);
  return logoutIfAccessDenied;
};
var logoutIfAccessDeniedWithoutProvider = function() {
  return Promise.resolve(false);
};
var getErrorMessage2 = function(error, defaultMessage) {
  return typeof error === "string" ? error : typeof error === "undefined" || !error.message ? defaultMessage : error.message;
};
var useLogoutIfAccessDenied_default = useLogoutIfAccessDenied;

// node_modules/ra-core/dist/esm/auth/usePermissions.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest3 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var emptyParams2 = {};
var usePermissions = function(params, queryParams) {
  if (params === void 0) {
    params = emptyParams2;
  }
  if (queryParams === void 0) {
    queryParams = {
      staleTime: 5 * 60 * 1e3
    };
  }
  var authProvider = useAuthProvider_default();
  var logoutIfAccessDenied = useLogoutIfAccessDenied_default();
  var _a11 = queryParams !== null && queryParams !== void 0 ? queryParams : {}, onSuccess = _a11.onSuccess, onError = _a11.onError, onSettled = _a11.onSettled, queryOptions2 = __rest3(_a11, ["onSuccess", "onError", "onSettled"]);
  var queryResult = useQuery(__assign2({ queryKey: ["auth", "getPermissions", params], queryFn: function(_a12) {
    var signal = _a12.signal;
    return __awaiter2(void 0, void 0, void 0, function() {
      var permissions;
      return __generator2(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!authProvider || !authProvider.getPermissions) {
              return [2, []];
            }
            return [4, authProvider.getPermissions(__assign2(__assign2({}, params), { signal }))];
          case 1:
            permissions = _b.sent();
            return [2, permissions !== null && permissions !== void 0 ? permissions : null];
        }
      });
    });
  } }, queryOptions2));
  var onSuccessEvent = useEvent(onSuccess !== null && onSuccess !== void 0 ? onSuccess : noop4);
  var onSettledEvent = useEvent(onSettled !== null && onSettled !== void 0 ? onSettled : noop4);
  var onErrorEvent = useEvent(onError !== null && onError !== void 0 ? onError : function(error) {
    if (true) {
      console.error(error);
    }
    logoutIfAccessDenied(error);
  });
  (0, import_react34.useEffect)(function() {
    if (queryResult.data === void 0 || queryResult.isFetching)
      return;
    onSuccessEvent(queryResult.data);
  }, [onSuccessEvent, queryResult.data, queryResult.isFetching]);
  (0, import_react34.useEffect)(function() {
    if (queryResult.error == null || queryResult.isFetching)
      return;
    onErrorEvent(queryResult.error);
  }, [onErrorEvent, queryResult.error, queryResult.isFetching]);
  (0, import_react34.useEffect)(function() {
    if (queryResult.status === "pending" || queryResult.isFetching)
      return;
    onSettledEvent(queryResult.data, queryResult.error);
  }, [
    onSettledEvent,
    queryResult.data,
    queryResult.error,
    queryResult.status,
    queryResult.isFetching
  ]);
  var result = (0, import_react34.useMemo)(function() {
    return __assign2(__assign2({}, queryResult), { permissions: queryResult.data });
  }, [queryResult]);
  return !authProvider || !authProvider.getPermissions ? fakeQueryResult : result;
};
var usePermissions_default = usePermissions;
var noop4 = function() {
};
var fakeQueryResult = {
  permissions: void 0,
  data: void 0,
  dataUpdatedAt: 0,
  error: null,
  errorUpdatedAt: 0,
  errorUpdateCount: 0,
  failureCount: 0,
  failureReason: null,
  fetchStatus: "idle",
  isError: false,
  isInitialLoading: false,
  isLoading: false,
  isLoadingError: false,
  isFetched: true,
  isFetchedAfterMount: true,
  isFetching: false,
  isPaused: false,
  isPlaceholderData: false,
  isPending: false,
  isRefetchError: false,
  isRefetching: false,
  isStale: false,
  isSuccess: true,
  status: "success",
  refetch: function() {
    return Promise.resolve(fakeQueryResult);
  }
};

// node_modules/ra-core/dist/esm/auth/WithPermissions.js
var React19 = __toESM(require_react());
var import_react35 = __toESM(require_react());

// node_modules/ra-core/dist/esm/util/warning.js
var warning_default = function(condition, message2) {
  if (condition && true) {
    console.warn(message2);
  }
};

// node_modules/ra-core/dist/esm/auth/useAuthenticated.js
var __rest4 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useAuthenticated = function(_a11) {
  if (_a11 === void 0) {
    _a11 = {};
  }
  var params = _a11.params, _b = _a11.logoutOnFailure, logoutOnFailure = _b === void 0 ? true : _b, options = __rest4(_a11, ["params", "logoutOnFailure"]);
  return useAuthState_default(params !== null && params !== void 0 ? params : emptyParams3, logoutOnFailure, options);
};
var emptyParams3 = {};

// node_modules/ra-core/dist/esm/auth/WithPermissions.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest5 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var isEmptyChildren = function(children) {
  return import_react35.Children.count(children) === 0;
};
var WithPermissions = function(props) {
  var authParams = props.authParams, children = props.children, render = props.render, component = props.component, _a11 = props.loading, Loading = _a11 === void 0 ? null : _a11, staticContext = props.staticContext, rest = __rest5(props, ["authParams", "children", "render", "component", "loading", "staticContext"]);
  warning_default(render && children && !isEmptyChildren(children) || render && component || component && children && !isEmptyChildren(children), "You should only use one of the `component`, `render` and `children` props in <WithPermissions>");
  var isAuthenticationPending = useAuthenticated(authParams).isPending;
  var _b = usePermissions_default(authParams, {
    enabled: !isAuthenticationPending
  }), permissions = _b.permissions, isPendingPermissions = _b.isPending;
  if (isAuthenticationPending || isPendingPermissions) {
    return Loading ? React19.createElement(Loading, null) : null;
  }
  if (component) {
    return (0, import_react35.createElement)(component, __assign3({ permissions }, rest));
  }
  if (render) {
    return render(__assign3({ permissions }, rest));
  }
  if (children) {
    return children(__assign3({ permissions }, rest));
  }
};
var WithPermissions_default = WithPermissions;

// node_modules/ra-core/dist/esm/auth/useLogin.js
var import_react36 = __toESM(require_react());
var useLogin = function() {
  var authProvider = useAuthProvider_default();
  var queryClient = useQueryClient();
  var location = useLocation();
  var locationState = location.state;
  var navigate = useNavigate();
  var basename = useBasename();
  var resetNotifications = useNotificationContext().resetNotifications;
  var nextPathName = locationState && locationState.nextPathname;
  var nextSearch = locationState && locationState.nextSearch;
  var afterLoginUrl = removeDoubleSlashes("".concat(basename, "/").concat(defaultAuthParams.afterLoginUrl));
  var login = (0, import_react36.useCallback)(function(params, pathName) {
    if (params === void 0) {
      params = {};
    }
    if (authProvider) {
      return authProvider.login(params).then(function(ret) {
        resetNotifications();
        queryClient.invalidateQueries({
          queryKey: ["auth", "getPermissions"]
        });
        if (ret && ret.hasOwnProperty("redirectTo")) {
          if (ret) {
            navigate(ret.redirectTo);
          }
        } else {
          var redirectUrl = pathName ? pathName : nextPathName + nextSearch || afterLoginUrl;
          navigate(redirectUrl);
        }
        return ret;
      });
    } else {
      resetNotifications();
      navigate(afterLoginUrl);
      return Promise.resolve();
    }
  }, [
    authProvider,
    queryClient,
    navigate,
    nextPathName,
    nextSearch,
    resetNotifications,
    afterLoginUrl
  ]);
  return login;
};
var useLogin_default = useLogin;

// node_modules/ra-core/dist/esm/auth/useGetPermissions.js
var import_react37 = __toESM(require_react());
var useGetPermissions = function() {
  var authProvider = useAuthProvider_default();
  var getPermissions = (0, import_react37.useCallback)(function(params) {
    if (params === void 0) {
      params = {};
    }
    if (authProvider && authProvider.getPermissions) {
      return authProvider.getPermissions(params).then(function(result) {
        return result !== null && result !== void 0 ? result : null;
      });
    }
    return Promise.resolve([]);
  }, [authProvider]);
  return getPermissions;
};
var useGetPermissions_default = useGetPermissions;

// node_modules/ra-core/dist/esm/auth/types.js
var AUTH_LOGIN = "AUTH_LOGIN";
var AUTH_CHECK = "AUTH_CHECK";
var AUTH_ERROR = "AUTH_ERROR";
var AUTH_LOGOUT = "AUTH_LOGOUT";
var AUTH_GET_PERMISSIONS = "AUTH_GET_PERMISSIONS";

// node_modules/ra-core/dist/esm/auth/convertLegacyAuthProvider.js
var convertLegacyAuthProvider_default = function(legacyAuthProvider) {
  var authProvider = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return legacyAuthProvider.apply(null, args);
  };
  authProvider.login = function(params) {
    return legacyAuthProvider(AUTH_LOGIN, params);
  };
  authProvider.logout = function(params) {
    return legacyAuthProvider(AUTH_LOGOUT, params);
  };
  authProvider.checkAuth = function(params) {
    return legacyAuthProvider(AUTH_CHECK, params);
  };
  authProvider.checkError = function(error) {
    return legacyAuthProvider(AUTH_ERROR, error);
  };
  authProvider.getPermissions = function(params) {
    return legacyAuthProvider(AUTH_GET_PERMISSIONS, params);
  };
  return authProvider;
};

// node_modules/ra-core/dist/esm/auth/Authenticated.js
var React20 = __toESM(require_react());
var Authenticated = function(props) {
  var authParams = props.authParams, _a11 = props.loading, loading = _a11 === void 0 ? null : _a11, children = props.children;
  var _b = useAuthenticated({ params: authParams }), isPending = _b.isPending, isError = _b.isError;
  if (isPending || isError) {
    return loading;
  }
  return React20.createElement(React20.Fragment, null, children);
};

// node_modules/ra-core/dist/esm/auth/CanAccess.js
var React48 = __toESM(require_react());

// node_modules/ra-core/dist/esm/auth/useCanAccess.js
var import_react126 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/useFilterState.js
var import_react38 = __toESM(require_react());
var import_debounce2 = __toESM(require_debounce());
var import_isEqual = __toESM(require_isEqual());
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var defaultFilter = {};
var defaultFilterToQuery = function(v) {
  return { q: v };
};
var useFilterState_default = function(_a11) {
  var _b = _a11.filterToQuery, filterToQuery = _b === void 0 ? defaultFilterToQuery : _b, _c = _a11.permanentFilter, permanentFilter = _c === void 0 ? {} : _c, _d = _a11.debounceTime, debounceTime = _d === void 0 ? 500 : _d;
  var permanentFilterProp = (0, import_react38.useRef)(permanentFilter);
  var latestValue = (0, import_react38.useRef)();
  var _e = (0, import_react38.useState)(__assign4(__assign4({}, permanentFilter), filterToQuery(""))), filter = _e[0], setFilterValue = _e[1];
  var permanentFilterSignature = JSON.stringify(permanentFilter);
  (0, import_react38.useEffect)(function() {
    if (!(0, import_isEqual.default)(permanentFilterProp.current, permanentFilter)) {
      permanentFilterProp.current = permanentFilter;
      setFilterValue(__assign4(__assign4({}, permanentFilter), filterToQuery(latestValue.current || "")));
    }
  }, [permanentFilterSignature, permanentFilterProp, filterToQuery]);
  var setFilter = (0, import_react38.useCallback)(
    (0, import_debounce2.default)(function(value) {
      setFilterValue(__assign4(__assign4({}, permanentFilter), filterToQuery(value)));
      latestValue.current = value;
    }, debounceTime),
    [permanentFilterSignature]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return {
    filter: filter !== null && filter !== void 0 ? filter : defaultFilter,
    setFilter
  };
};

// node_modules/ra-core/dist/esm/controller/useSortState.js
var import_react39 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/list/queryReducer.js
var import_set3 = __toESM(require_set());

// node_modules/ra-core/dist/esm/util/shallowEqual.js
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}
var shallowEqual = function(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (var i = 0; i < keysA.length; i++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }
  return true;
};

// node_modules/ra-core/dist/esm/util/removeEmpty.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var isObject = function(obj) {
  return obj && Object.prototype.toString.call(obj) === "[object Object]";
};
var isEmpty = function(obj) {
  return obj instanceof Date ? false : obj === "" || obj === null || obj === void 0 || shallowEqual(obj, {});
};
var removeEmpty = function(object) {
  return Object.keys(object).reduce(function(acc, key) {
    var _a11;
    var child = object[key];
    if (isObject(object[key])) {
      child = removeEmpty(object[key]);
    }
    return isEmpty(child) ? acc : __assign5(__assign5({}, acc), (_a11 = {}, _a11[key] = child, _a11));
  }, {});
};
var removeEmpty_default = removeEmpty;

// node_modules/ra-core/dist/esm/util/removeKey.js
var removeKey = function(target, path) {
  return Object.keys(target).reduce(function(acc, key) {
    var _a11;
    if (key !== path) {
      return Object.assign({}, acc, (_a11 = {}, _a11[key] = target[key], _a11));
    }
    return acc;
  }, {});
};
var deepRemoveKey = function(target, path) {
  var _a11;
  var paths = path.split(".");
  if (paths.length === 1) {
    return removeKey(target, path);
  }
  var deepKey = paths[0];
  if (target[deepKey] === void 0) {
    return target;
  }
  var deep = deepRemoveKey(target[deepKey], paths.slice(1).join("."));
  if (Object.keys(deep).length === 0) {
    return removeKey(target, deepKey);
  }
  return Object.assign({}, target, (_a11 = {}, _a11[deepKey] = deep, _a11));
};
var removeKey_default = deepRemoveKey;

// node_modules/ra-core/dist/esm/controller/list/queryReducer.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var SET_SORT = "SET_SORT";
var SORT_ASC = "ASC";
var SORT_DESC = "DESC";
var SET_PAGE = "SET_PAGE";
var SET_PER_PAGE = "SET_PER_PAGE";
var SET_FILTER = "SET_FILTER";
var SHOW_FILTER = "SHOW_FILTER";
var HIDE_FILTER = "HIDE_FILTER";
var oppositeOrder = function(direction) {
  return direction === SORT_DESC ? SORT_ASC : SORT_DESC;
};
var queryReducer = function(previousState, action) {
  var _a11;
  var _b;
  switch (action.type) {
    case SET_SORT:
      if (action.payload.field === previousState.sort) {
        return __assign6(__assign6({}, previousState), { order: (_b = action.payload.order) !== null && _b !== void 0 ? _b : oppositeOrder(previousState.order), page: 1 });
      }
      return __assign6(__assign6({}, previousState), { sort: action.payload.field, order: action.payload.order || SORT_ASC, page: 1 });
    case SET_PAGE:
      return __assign6(__assign6({}, previousState), { page: action.payload });
    case SET_PER_PAGE:
      return __assign6(__assign6({}, previousState), { page: 1, perPage: action.payload });
    case SET_FILTER: {
      return __assign6(__assign6({}, previousState), { page: 1, filter: action.payload.filter, displayedFilters: action.payload.displayedFilters ? action.payload.displayedFilters : previousState.displayedFilters });
    }
    case SHOW_FILTER: {
      if (previousState.displayedFilters && previousState.displayedFilters[action.payload.filterName]) {
        return previousState;
      }
      return __assign6(__assign6({}, previousState), {
        filter: typeof action.payload.defaultValue !== "undefined" ? (0, import_set3.default)(previousState.filter, action.payload.filterName, action.payload.defaultValue) : previousState.filter,
        // we don't use lodash.set() for displayed filters
        // to avoid problems with compound filter names (e.g. 'author.name')
        displayedFilters: __assign6(__assign6({}, previousState.displayedFilters), (_a11 = {}, _a11[action.payload.filterName] = true, _a11))
      });
    }
    case HIDE_FILTER: {
      return __assign6(__assign6({}, previousState), {
        filter: removeEmpty_default(removeKey_default(previousState.filter, action.payload)),
        // we don't use lodash.set() for displayed filters
        // to avoid problems with compound filter names (e.g. 'author.name')
        displayedFilters: previousState.displayedFilters ? Object.keys(previousState.displayedFilters).reduce(function(filters, filter) {
          var _a12;
          return filter !== action.payload ? __assign6(__assign6({}, filters), (_a12 = {}, _a12[filter] = true, _a12)) : filters;
        }, {}) : previousState.displayedFilters
      });
    }
    default:
      return previousState;
  }
};
var queryReducer_default = queryReducer;

// node_modules/ra-core/dist/esm/controller/useSortState.js
var sortReducer = function(state, action) {
  switch (action.type) {
    case "SET_SORT":
      return action.payload;
    case "SET_SORT_FIELD": {
      var field = action.payload;
      var order = state.field === field ? state.order === SORT_ASC ? SORT_DESC : SORT_ASC : SORT_ASC;
      return { field, order };
    }
    case "SET_SORT_ORDER": {
      var order = action.payload;
      if (!state.field) {
        throw new Error("cannot change the order on an undefined sort field");
      }
      return {
        field: state.field,
        order
      };
    }
    default:
      return state;
  }
};
var defaultSort = { field: "", order: "ASC" };
var useSortState = function(initialSort) {
  if (initialSort === void 0) {
    initialSort = defaultSort;
  }
  var _a11 = (0, import_react39.useReducer)(sortReducer, initialSort), sort = _a11[0], dispatch = _a11[1];
  var isFirstRender = (0, import_react39.useRef)(true);
  (0, import_react39.useEffect)(function() {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    dispatch({ type: "SET_SORT", payload: initialSort });
  }, [initialSort.field, initialSort.order]);
  return {
    setSort: (0, import_react39.useCallback)(function(sort2) {
      return dispatch({ type: "SET_SORT", payload: sort2 });
    }, [dispatch]),
    setSortField: (0, import_react39.useCallback)(function(field) {
      return dispatch({ type: "SET_SORT_FIELD", payload: field });
    }, [dispatch]),
    setSortOrder: (0, import_react39.useCallback)(function(order) {
      return dispatch({ type: "SET_SORT_ORDER", payload: order });
    }, [dispatch]),
    sort
  };
};
var useSortState_default = useSortState;

// node_modules/ra-core/dist/esm/controller/usePaginationState.js
var import_react40 = __toESM(require_react());
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var paginationReducer = function(prevState, nextState) {
  return __assign7(__assign7({}, prevState), nextState);
};
var defaultPagination = {
  page: 1,
  perPage: 25
};
var usePaginationState_default = function(initialPagination) {
  if (initialPagination === void 0) {
    initialPagination = {};
  }
  var _a11 = (0, import_react40.useReducer)(paginationReducer, __assign7(__assign7({}, defaultPagination), initialPagination)), pagination = _a11[0], setPagination = _a11[1];
  var isFirstRender = (0, import_react40.useRef)(true);
  var setPerPage = (0, import_react40.useCallback)(function(perPage) {
    return setPagination({ perPage, page: 1 });
  }, []);
  var setPage = (0, import_react40.useCallback)(function(page) {
    return setPagination({ page });
  }, []);
  (0, import_react40.useEffect)(function() {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      return;
    }
    setPerPage(initialPagination.perPage || 25);
  }, [initialPagination.perPage, setPerPage]);
  return {
    page: pagination.page,
    perPage: pagination.perPage,
    pagination,
    setPage,
    setPerPage,
    setPagination
  };
};

// node_modules/ra-core/dist/esm/controller/checkMinimumRequiredProps.js
var React21 = __toESM(require_react());
var useCheckMinimumRequiredProps = function(displayName, requiredProps, props) {
  var propNames = Object.keys(props);
  var missingProps = requiredProps.filter(function(prop) {
    return !propNames.includes(prop);
  });
  if (missingProps.length > 0) {
    throw new Error("<".concat(displayName, "> component is not properly configured, some essential props are missing.\nBe sure to pass the props from the parent. Example:\n\nconst My").concat(displayName, " = props => (\n    <").concat(displayName, " {...props}></").concat(displayName, ">\n);\n\nThe missing props are: ").concat(missingProps.join(", ")));
  }
};

// node_modules/ra-core/dist/esm/controller/button/useDeleteWithUndoController.js
var import_react62 = __toESM(require_react());

// node_modules/ra-core/dist/esm/dataProvider/dataFetchActions.js
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var GET_LIST = "GET_LIST";
var GET_ONE = "GET_ONE";
var GET_MANY = "GET_MANY";
var GET_MANY_REFERENCE = "GET_MANY_REFERENCE";
var CREATE = "CREATE";
var UPDATE = "UPDATE";
var UPDATE_MANY = "UPDATE_MANY";
var DELETE = "DELETE";
var DELETE_MANY = "DELETE_MANY";
var fetchActionsWithRecordResponse = ["getOne", "create", "update"];
var fetchActionsWithArrayOfIdentifiedRecordsResponse = [
  "getList",
  "getMany",
  "getManyReference"
];
var fetchActionsWithArrayOfRecordsResponse = __spreadArray4(__spreadArray4([], fetchActionsWithArrayOfIdentifiedRecordsResponse, true), [
  "updateMany",
  "deleteMany"
], false);
var fetchActionsWithTotalResponse = ["getList", "getManyReference"];
var reactAdminFetchActions = __spreadArray4(__spreadArray4([], fetchActionsWithRecordResponse, true), fetchActionsWithArrayOfRecordsResponse, true);
var sanitizeFetchType = function(fetchType) {
  switch (fetchType) {
    case GET_LIST:
      return "getList";
    case GET_ONE:
      return "getOne";
    case GET_MANY:
      return "getMany";
    case GET_MANY_REFERENCE:
      return "getManyReference";
    case CREATE:
      return "create";
    case UPDATE:
      return "update";
    case UPDATE_MANY:
      return "updateMany";
    case DELETE:
      return "delete";
    case DELETE_MANY:
      return "deleteMany";
    default:
      return fetchType;
  }
};

// node_modules/ra-core/dist/esm/dataProvider/defaultDataProvider.js
var defaultDataProvider = {
  create: function() {
    return Promise.resolve({ data: null });
  },
  delete: function() {
    return Promise.resolve({ data: null });
  },
  deleteMany: function() {
    return Promise.resolve({ data: [] });
  },
  getList: function() {
    return Promise.resolve({ data: [], total: 0 });
  },
  getMany: function() {
    return Promise.resolve({ data: [] });
  },
  getManyReference: function() {
    return Promise.resolve({ data: [], total: 0 });
  },
  getOne: function() {
    return Promise.resolve({ data: null });
  },
  update: function() {
    return Promise.resolve({ data: null });
  },
  updateMany: function() {
    return Promise.resolve({ data: [] });
  }
};

// node_modules/ra-core/dist/esm/dataProvider/convertLegacyDataProvider.js
var fetchMap = {
  create: CREATE,
  delete: DELETE,
  deleteMany: DELETE_MANY,
  getList: GET_LIST,
  getMany: GET_MANY,
  getManyReference: GET_MANY_REFERENCE,
  getOne: GET_ONE,
  update: UPDATE,
  updateMany: UPDATE_MANY
};
var convertLegacyDataProvider = function(legacyDataProvider) {
  var proxy = new Proxy(defaultDataProvider, {
    get: function(_, name) {
      return function(resource, params) {
        if (Object.keys(fetchMap).includes(name.toString())) {
          var fetchType = fetchMap[name.toString()];
          return legacyDataProvider(fetchType, resource, params);
        }
        return legacyDataProvider(name.toString(), resource, params);
      };
    },
    apply: function(_, __, args) {
      return legacyDataProvider.apply(legacyDataProvider, args);
    }
  });
  return proxy;
};
var convertLegacyDataProvider_default = convertLegacyDataProvider;

// node_modules/ra-core/dist/esm/dataProvider/DataProviderContext.js
var import_react41 = __toESM(require_react());
var DataProviderContext = (0, import_react41.createContext)(null);
DataProviderContext.displayName = "DataProviderContext";
var DataProviderContext_default = DataProviderContext;

// node_modules/ra-core/dist/esm/dataProvider/HttpError.js
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HttpError = (
  /** @class */
  function(_super) {
    __extends(HttpError2, _super);
    function HttpError2(message2, status, body) {
      if (body === void 0) {
        body = null;
      }
      var _this = _super.call(this, message2) || this;
      _this.message = message2;
      _this.status = status;
      _this.body = body;
      Object.setPrototypeOf(_this, HttpError2.prototype);
      _this.name = _this.constructor.name;
      if (typeof Error.captureStackTrace === "function") {
        Error.captureStackTrace(_this, _this.constructor);
      } else {
        _this.stack = new Error(message2).stack;
      }
      _this.stack = new Error().stack;
      return _this;
    }
    return HttpError2;
  }(Error)
);
var HttpError_default = HttpError;

// node_modules/ra-core/dist/esm/dataProvider/fetch.js
var fetch_exports = {};
__export(fetch_exports, {
  createHeadersFromOptions: () => createHeadersFromOptions,
  fetchJson: () => fetchJson,
  flattenObject: () => flattenObject,
  queryParameters: () => queryParameters
});
var import_query_string = __toESM(require_query_string());
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var __spreadArray5 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var createHeadersFromOptions = function(options) {
  var requestHeaders = options.headers || new Headers({
    Accept: "application/json"
  });
  var hasBody = options && options.body;
  var isContentTypeSet = requestHeaders.has("Content-Type");
  var isGetMethod = !(options === null || options === void 0 ? void 0 : options.method) || (options === null || options === void 0 ? void 0 : options.method) === "GET";
  var isFormData = (options === null || options === void 0 ? void 0 : options.body) instanceof FormData;
  var shouldSetContentType = hasBody && !isContentTypeSet && !isGetMethod && !isFormData;
  if (shouldSetContentType) {
    requestHeaders.set("Content-Type", "application/json");
  }
  if (options.user && options.user.authenticated && options.user.token) {
    requestHeaders.set("Authorization", options.user.token);
  }
  return requestHeaders;
};
var fetchJson = function(url, options) {
  if (options === void 0) {
    options = {};
  }
  var requestHeaders = createHeadersFromOptions(options);
  return fetch(url, __assign8(__assign8({}, options), { headers: requestHeaders })).then(function(response) {
    return response.text().then(function(text) {
      return {
        status: response.status,
        statusText: response.statusText,
        headers: response.headers,
        body: text
      };
    });
  }).then(function(_a11) {
    var status = _a11.status, statusText = _a11.statusText, headers = _a11.headers, body = _a11.body;
    var json;
    try {
      json = JSON.parse(body);
    } catch (e) {
    }
    if (status < 200 || status >= 300) {
      return Promise.reject(new HttpError_default(json && json.message || statusText, status, json));
    }
    return Promise.resolve({ status, headers, body, json });
  });
};
var queryParameters = import_query_string.stringify;
var isValidObject = function(value) {
  if (!value) {
    return false;
  }
  var isArray2 = Array.isArray(value);
  var isBuffer = typeof Buffer !== "undefined" && Buffer.isBuffer(value);
  var isObject4 = Object.prototype.toString.call(value) === "[object Object]";
  var hasKeys = !!Object.keys(value).length;
  return !isArray2 && !isBuffer && isObject4 && hasKeys;
};
var flattenObject = function(value, path) {
  var _a11;
  if (path === void 0) {
    path = [];
  }
  if (isValidObject(value)) {
    return Object.assign.apply(Object, __spreadArray5([{}], Object.keys(value).map(function(key) {
      return flattenObject(value[key], path.concat([key]));
    }), false));
  } else {
    return path.length ? (_a11 = {}, _a11[path.join(".")] = value, _a11) : value;
  }
};

// node_modules/eventemitter3/index.mjs
var import_index2 = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index2.default;

// node_modules/ra-core/dist/esm/dataProvider/undoableEventEmitter.js
var undoableEventEmitter_default = new eventemitter3_default();

// node_modules/ra-core/dist/esm/dataProvider/combineDataProviders.js
var __spreadArray6 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var combineDataProviders = function(dataProviderMatcher) {
  return new Proxy(defaultDataProvider, {
    get: function(target, name) {
      if (name === "then") {
        return null;
      }
      return function(resource) {
        var _a11;
        var params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          params[_i - 1] = arguments[_i];
        }
        if (typeof name === "symbol") {
          return;
        }
        return (_a11 = dataProviderMatcher(resource))[name].apply(_a11, __spreadArray6([resource], params, false));
      };
    }
  });
};

// node_modules/ra-core/dist/esm/dataProvider/testDataProvider.js
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var defaultTestDataProvider = {
  create: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("create is not implemented");
      });
    });
  },
  delete: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("delete not implemented");
      });
    });
  },
  deleteMany: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("deleteMany is not implemented");
      });
    });
  },
  getList: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("getList is not implemented");
      });
    });
  },
  getMany: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("getMany is not implemented");
      });
    });
  },
  getManyReference: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("getManyReference is not implemented");
      });
    });
  },
  getOne: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("getOne is not implemented");
      });
    });
  },
  update: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("update not implemented");
      });
    });
  },
  updateMany: function() {
    return __awaiter3(void 0, void 0, void 0, function() {
      return __generator3(this, function(_a11) {
        throw new Error("updateMany not implemented");
      });
    });
  }
};
var testDataProvider = function(overrides) {
  return __assign9(__assign9({}, defaultTestDataProvider), overrides);
};

// node_modules/ra-core/dist/esm/dataProvider/withLifecycleCallbacks.js
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var withLifecycleCallbacks = function(dataProvider, handlers) {
  return __assign10(__assign10({}, dataProvider), { getList: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, result, _a11;
      return __generator4(this, function(_b) {
        switch (_b.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeGetList",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _b.sent();
            return [4, dataProvider.getList(resource, newParams)];
          case 2:
            result = _b.sent();
            return [4, applyCallbacks({
              name: "afterGetList",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 3:
            result = _b.sent();
            _a11 = result;
            return [4, Promise.all(result.data.map(function(record) {
              return applyCallbacks({
                name: "afterRead",
                params: record,
                dataProvider,
                handlers,
                resource
              });
            }))];
          case 4:
            _a11.data = _b.sent();
            return [2, result];
        }
      });
    });
  }, getOne: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, result, _a11;
      return __generator4(this, function(_b) {
        switch (_b.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeGetOne",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _b.sent();
            return [4, dataProvider.getOne(resource, newParams)];
          case 2:
            result = _b.sent();
            return [4, applyCallbacks({
              name: "afterGetOne",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 3:
            result = _b.sent();
            _a11 = result;
            return [4, applyCallbacks({
              name: "afterRead",
              params: result.data,
              dataProvider,
              handlers,
              resource
            })];
          case 4:
            _a11.data = _b.sent();
            return [2, result];
        }
      });
    });
  }, getMany: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, result, _a11;
      return __generator4(this, function(_b) {
        switch (_b.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeGetMany",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _b.sent();
            return [4, dataProvider.getMany(resource, newParams)];
          case 2:
            result = _b.sent();
            return [4, applyCallbacks({
              name: "afterGetMany",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 3:
            result = _b.sent();
            _a11 = result;
            return [4, Promise.all(result.data.map(function(record) {
              return applyCallbacks({
                name: "afterRead",
                params: record,
                dataProvider,
                handlers,
                resource
              });
            }))];
          case 4:
            _a11.data = _b.sent();
            return [2, result];
        }
      });
    });
  }, getManyReference: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, result, _a11;
      return __generator4(this, function(_b) {
        switch (_b.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeGetManyReference",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _b.sent();
            return [4, dataProvider.getManyReference(resource, newParams)];
          case 2:
            result = _b.sent();
            return [4, applyCallbacks({
              name: "afterGetManyReference",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 3:
            result = _b.sent();
            _a11 = result;
            return [4, Promise.all(result.data.map(function(record) {
              return applyCallbacks({
                name: "afterRead",
                params: record,
                dataProvider,
                handlers,
                resource
              });
            }))];
          case 4:
            _a11.data = _b.sent();
            return [2, result];
        }
      });
    });
  }, update: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, _a11, result, _b;
      return __generator4(this, function(_c) {
        switch (_c.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeUpdate",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _c.sent();
            _a11 = newParams;
            return [4, applyCallbacks({
              name: "beforeSave",
              params: newParams.data,
              dataProvider,
              handlers,
              resource
            })];
          case 2:
            _a11.data = _c.sent();
            return [4, dataProvider.update(resource, newParams)];
          case 3:
            result = _c.sent();
            return [4, applyCallbacks({
              name: "afterUpdate",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 4:
            result = _c.sent();
            _b = result;
            return [4, applyCallbacks({
              name: "afterSave",
              params: result.data,
              dataProvider,
              handlers,
              resource
            })];
          case 5:
            _b.data = _c.sent();
            return [2, result];
        }
      });
    });
  }, create: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, _a11, result, _b;
      return __generator4(this, function(_c) {
        switch (_c.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeCreate",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _c.sent();
            _a11 = newParams;
            return [4, applyCallbacks({
              name: "beforeSave",
              params: newParams.data,
              dataProvider,
              handlers,
              resource
            })];
          case 2:
            _a11.data = _c.sent();
            return [4, dataProvider.create(resource, newParams)];
          case 3:
            result = _c.sent();
            return [4, applyCallbacks({
              name: "afterCreate",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 4:
            result = _c.sent();
            _b = result;
            return [4, applyCallbacks({
              name: "afterSave",
              params: result.data,
              dataProvider,
              handlers,
              resource
            })];
          case 5:
            _b.data = _c.sent();
            return [2, result];
        }
      });
    });
  }, delete: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, result;
      return __generator4(this, function(_a11) {
        switch (_a11.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeDelete",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _a11.sent();
            return [4, dataProvider.delete(resource, newParams)];
          case 2:
            result = _a11.sent();
            return [4, applyCallbacks({
              name: "afterDelete",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 3:
            result = _a11.sent();
            return [2, result];
        }
      });
    });
  }, updateMany: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, _a11, result, afterSaveHandlers, records;
      return __generator4(this, function(_b) {
        switch (_b.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeUpdateMany",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _b.sent();
            _a11 = newParams;
            return [4, applyCallbacks({
              name: "beforeSave",
              params: newParams.data,
              dataProvider,
              handlers,
              resource
            })];
          case 2:
            _a11.data = _b.sent();
            return [4, dataProvider.updateMany(resource, newParams)];
          case 3:
            result = _b.sent();
            return [4, applyCallbacks({
              name: "afterUpdateMany",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 4:
            result = _b.sent();
            afterSaveHandlers = handlers.filter(function(h) {
              return (h.resource === resource || h.resource === "*") && h.afterSave;
            });
            if (!(afterSaveHandlers.length > 0)) return [3, 7];
            return [4, dataProvider.getMany(resource, {
              //@ts-ignore
              ids: result.data
            })];
          case 5:
            records = _b.sent().data;
            return [4, Promise.all(records.map(function(record) {
              return applyCallbacks({
                name: "afterSave",
                params: record,
                dataProvider,
                handlers,
                resource
              });
            }))];
          case 6:
            _b.sent();
            _b.label = 7;
          case 7:
            return [2, result];
        }
      });
    });
  }, deleteMany: function(resource, params) {
    return __awaiter4(this, void 0, void 0, function() {
      var newParams, result;
      return __generator4(this, function(_a11) {
        switch (_a11.label) {
          case 0:
            newParams = params;
            return [4, applyCallbacks({
              name: "beforeDeleteMany",
              params: newParams,
              dataProvider,
              handlers,
              resource
            })];
          case 1:
            newParams = _a11.sent();
            return [4, dataProvider.deleteMany(resource, newParams)];
          case 2:
            result = _a11.sent();
            return [4, applyCallbacks({
              name: "afterDeleteMany",
              params: result,
              dataProvider,
              handlers,
              resource
            })];
          case 3:
            result = _a11.sent();
            return [2, result];
        }
      });
    });
  } });
};
var applyCallbacks = function(_a11) {
  var name = _a11.name, params = _a11.params, dataProvider = _a11.dataProvider, handlers = _a11.handlers, resource = _a11.resource;
  return __awaiter4(this, void 0, void 0, function() {
    var newParams, handlersToApply, _i, handlersToApply_1, handler, callbacksValue, _b, _c, callback;
    return __generator4(this, function(_d) {
      switch (_d.label) {
        case 0:
          newParams = params;
          handlersToApply = handlers.filter(function(h) {
            return (h.resource === resource || h.resource === "*") && h[name];
          });
          _i = 0, handlersToApply_1 = handlersToApply;
          _d.label = 1;
        case 1:
          if (!(_i < handlersToApply_1.length)) return [3, 9];
          handler = handlersToApply_1[_i];
          callbacksValue = handler[name];
          if (!Array.isArray(callbacksValue)) return [3, 6];
          _b = 0, _c = callbacksValue !== null && callbacksValue !== void 0 ? callbacksValue : [];
          _d.label = 2;
        case 2:
          if (!(_b < _c.length)) return [3, 5];
          callback = _c[_b];
          return [4, callback(newParams, dataProvider, resource)];
        case 3:
          newParams = _d.sent();
          _d.label = 4;
        case 4:
          _b++;
          return [3, 2];
        case 5:
          return [3, 8];
        case 6:
          return [4, callbacksValue(newParams, dataProvider, resource)];
        case 7:
          newParams = _d.sent();
          _d.label = 8;
        case 8:
          _i++;
          return [3, 1];
        case 9:
          return [2, newParams];
      }
    });
  });
};

// node_modules/ra-core/dist/esm/dataProvider/useDataProvider.js
var import_react42 = __toESM(require_react());

// node_modules/ra-core/dist/esm/dataProvider/validateResponseFormat.js
function validateResponseFormat(response, type, logger) {
  if (logger === void 0) {
    logger = console.error;
  }
  if (!response) {
    logger("The dataProvider returned an empty response for '".concat(type, "'."));
    throw new Error("ra.notification.data_provider_error");
  }
  if (!response.hasOwnProperty("data")) {
    logger("The response to '".concat(type, "' must be like { data: ... }, but the received response does not have a 'data' key. The dataProvider is probably wrong for '").concat(type, "'."));
    throw new Error("ra.notification.data_provider_error");
  }
  if (fetchActionsWithArrayOfRecordsResponse.includes(type) && !Array.isArray(response.data)) {
    logger("The response to '".concat(type, "' must be like { data : [...] }, but the received data is not an array. The dataProvider is probably wrong for '").concat(type, "'"));
    throw new Error("ra.notification.data_provider_error");
  }
  if (fetchActionsWithArrayOfIdentifiedRecordsResponse.includes(type) && Array.isArray(response.data) && response.data.length > 0 && !response.data[0].hasOwnProperty("id")) {
    logger("The response to '".concat(type, "' must be like { data : [{ id: 123, ...}, ...] }, but the received data items do not have an 'id' key. The dataProvider is probably wrong for '").concat(type, "'"));
    throw new Error("ra.notification.data_provider_error");
  }
  if (fetchActionsWithRecordResponse.includes(type) && !response.data.hasOwnProperty("id")) {
    logger("The response to '".concat(type, "' must be like { data: { id: 123, ... } }, but the received data does not have an 'id' key. The dataProvider is probably wrong for '").concat(type, "'"));
    throw new Error("ra.notification.data_provider_error");
  }
  if (fetchActionsWithTotalResponse.includes(type) && !response.hasOwnProperty("total") && !response.hasOwnProperty("pageInfo")) {
    logger("The response to '".concat(type, "' must be like { data: [...], total: 123 } or { data: [...], pageInfo: {...} }, but the received response has neither a 'total' nor a 'pageInfo' key. The dataProvider is probably wrong for '").concat(type, "'"));
    throw new Error("ra.notification.data_provider_error");
  }
}
var validateResponseFormat_default = validateResponseFormat;

// node_modules/ra-core/dist/esm/dataProvider/populateQueryCache.js
var populateQueryCache = function(_a11) {
  var data = _a11.data, queryClient = _a11.queryClient, _b = _a11.staleTime, staleTime = _b === void 0 ? 1e3 : _b;
  var updatedAt = Date.now() + staleTime;
  Object.keys(data).forEach(function(resource) {
    data[resource].forEach(function(record) {
      if (!record || record.id == null)
        return;
      queryClient.setQueryData([resource, "getOne", { id: String(record.id) }], record, { updatedAt });
    });
    var recordIds = data[resource].map(function(record) {
      return String(record.id);
    });
    queryClient.setQueryData([resource, "getMany", { ids: recordIds }], data[resource], { updatedAt });
  });
};

// node_modules/ra-core/dist/esm/dataProvider/useDataProvider.js
var arrayReturnTypes = ["getList", "getMany", "getManyReference"];
var useDataProvider = function() {
  var dataProvider = (0, import_react42.useContext)(DataProviderContext_default) || defaultDataProvider;
  var queryClient = useQueryClient();
  var logoutIfAccessDenied = useLogoutIfAccessDenied_default();
  var dataProviderProxy = (0, import_react42.useMemo)(function() {
    return new Proxy(dataProvider, {
      get: function(_, name) {
        if (typeof name === "symbol" || name === "then") {
          return;
        }
        if (name === "supportAbortSignal") {
          return dataProvider.supportAbortSignal;
        }
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var type = name.toString();
          if (typeof dataProvider[type] !== "function") {
            throw new Error("Unknown dataProvider function: ".concat(type));
          }
          try {
            return dataProvider[type].apply(dataProvider, args).then(function(response) {
              var _a11;
              if (reactAdminFetchActions.includes(type)) {
                validateResponseFormat_default(response, type);
              }
              if ((_a11 = response === null || response === void 0 ? void 0 : response.meta) === null || _a11 === void 0 ? void 0 : _a11.prefetched) {
                populateQueryCache({
                  data: response === null || response === void 0 ? void 0 : response.meta.prefetched,
                  queryClient
                });
              }
              return response;
            }).catch(function(error) {
              if (
                // do not log AbortErrors
                !isAbortError(error)
              ) {
                console.error(error);
              }
              return logoutIfAccessDenied(error).then(function(loggedOut) {
                if (loggedOut)
                  return {
                    data: arrayReturnTypes.includes(type) ? [] : {}
                  };
                throw error;
              });
            });
          } catch (e) {
            if (true) {
              console.error(e);
            }
            throw new Error("The dataProvider threw an error. It should return a rejected Promise instead.");
          }
        };
      }
    });
  }, [dataProvider, logoutIfAccessDenied, queryClient]);
  return dataProviderProxy;
};
var isAbortError = function(error) {
  return error instanceof DOMException && error.name === "AbortError";
};

// node_modules/ra-core/dist/esm/dataProvider/useIsDataLoaded.js
var import_react43 = __toESM(require_react());
var useIsDataLoaded = function(queryKey, options) {
  if (options === void 0) {
    options = {};
  }
  var _a11 = options.enabled, enabled = _a11 === void 0 ? true : _a11;
  var queryClient = useQueryClient();
  var _b = (0, import_react43.useState)(function() {
    if (!enabled) {
      return false;
    }
    return queryClient.getQueryData(queryKey) !== void 0;
  }), isDataLoaded = _b[0], setDataLoaded = _b[1];
  (0, import_react43.useEffect)(function() {
    if (!enabled)
      return;
    if (queryClient.getQueryData(queryKey) === void 0) {
      var observer = new QueryObserver(queryClient, { queryKey });
      var unsubscribe_1 = observer.subscribe(function(result) {
        setDataLoaded(!result.isPending);
        unsubscribe_1();
      });
      return unsubscribe_1;
    }
  }, [enabled, queryKey, queryClient]);
  return isDataLoaded;
};

// node_modules/ra-core/dist/esm/dataProvider/useLoading.js
var import_react44 = __toESM(require_react());
var useLoading = function() {
  var client = useQueryClient();
  var mountedRef = import_react44.default.useRef(false);
  var isFetchingRef = import_react44.default.useRef(client.isFetching() > 0);
  var isMutatingRef = import_react44.default.useRef(client.isMutating() > 0);
  var _a11 = import_react44.default.useState(isFetchingRef.current || isMutatingRef.current), isLoading = _a11[0], setIsLoading = _a11[1];
  import_react44.default.useEffect(function() {
    mountedRef.current = true;
    var unsubscribeQueryCache = client.getQueryCache().subscribe(notifyManager.batchCalls(function() {
      if (mountedRef.current) {
        isFetchingRef.current = client.isFetching() > 0;
        setIsLoading(isFetchingRef.current || isMutatingRef.current);
      }
    }));
    var unsubscribeMutationCache = client.getMutationCache().subscribe(notifyManager.batchCalls(function() {
      if (mountedRef.current) {
        isMutatingRef.current = client.isMutating() > 0;
        setIsLoading(isFetchingRef.current || isMutatingRef.current);
      }
    }));
    return function() {
      mountedRef.current = false;
      unsubscribeQueryCache();
      unsubscribeMutationCache();
    };
  }, [client]);
  return isLoading;
};

// node_modules/ra-core/dist/esm/dataProvider/useRefresh.js
var import_react45 = __toESM(require_react());
var useRefresh = function() {
  var queryClient = useQueryClient();
  return (0, import_react45.useCallback)(function() {
    queryClient.invalidateQueries();
  }, [queryClient]);
};

// node_modules/ra-core/dist/esm/dataProvider/useGetOne.js
var import_react46 = __toESM(require_react());
var __assign11 = function() {
  __assign11 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign11.apply(this, arguments);
};
var __rest6 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useGetOne = function(resource, _a11, options) {
  var id = _a11.id, meta = _a11.meta;
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var _b = options.onError, onError = _b === void 0 ? noop5 : _b, _c = options.onSuccess, onSuccess = _c === void 0 ? noop5 : _c, _d = options.onSettled, onSettled = _d === void 0 ? noop5 : _d, enabled = options.enabled, queryOptions2 = __rest6(options, ["onError", "onSuccess", "onSettled", "enabled"]);
  var onSuccessEvent = useEvent(onSuccess);
  var onErrorEvent = useEvent(onError);
  var onSettledEvent = useEvent(onSettled);
  var result = useQuery(__assign11({
    // Sometimes the id comes as a string (e.g. when read from the URL in a Show view).
    // Sometimes the id comes as a number (e.g. when read from a Record in useGetList response).
    // As the react-query cache is type-sensitive, we always stringify the identifier to get a match
    queryKey: [resource, "getOne", { id: String(id), meta }],
    queryFn: function(queryParams) {
      return id == null ? new Promise(function() {
      }) : dataProvider.getOne(resource, {
        id,
        meta,
        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
      }).then(function(_a12) {
        var data = _a12.data;
        return data;
      });
    },
    enabled: enabled !== null && enabled !== void 0 ? enabled : id != null
  }, queryOptions2));
  (0, import_react46.useEffect)(function() {
    if (result.data === void 0 || result.error != null || result.isFetching)
      return;
    onSuccessEvent(result.data);
  }, [onSuccessEvent, result.data, result.error, result.isFetching]);
  (0, import_react46.useEffect)(function() {
    if (result.error == null || result.isFetching)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error, result.isFetching]);
  (0, import_react46.useEffect)(function() {
    if (result.status === "pending" || result.isFetching)
      return;
    onSettledEvent(result.data, result.error);
  }, [
    onSettledEvent,
    result.data,
    result.error,
    result.status,
    result.isFetching
  ]);
  return result;
};
var noop5 = function() {
  return void 0;
};

// node_modules/ra-core/dist/esm/dataProvider/useGetList.js
var import_react47 = __toESM(require_react());
var __assign12 = function() {
  __assign12 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign12.apply(this, arguments);
};
var __rest7 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var MAX_DATA_LENGTH_TO_CACHE = 100;
var useGetList = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var _a11 = params.pagination, pagination = _a11 === void 0 ? { page: 1, perPage: 25 } : _a11, _b = params.sort, sort = _b === void 0 ? { field: "id", order: "DESC" } : _b, _c = params.filter, filter = _c === void 0 ? {} : _c, meta = params.meta;
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var _d = options.onError, onError = _d === void 0 ? noop6 : _d, _e = options.onSuccess, onSuccess = _e === void 0 ? noop6 : _e, _f = options.onSettled, onSettled = _f === void 0 ? noop6 : _f, queryOptions2 = __rest7(options, ["onError", "onSuccess", "onSettled"]);
  var onSuccessEvent = useEvent(onSuccess);
  var onErrorEvent = useEvent(onError);
  var onSettledEvent = useEvent(onSettled);
  var result = useQuery(__assign12({ queryKey: [resource, "getList", { pagination, sort, filter, meta }], queryFn: function(queryParams) {
    return dataProvider.getList(resource, {
      pagination,
      sort,
      filter,
      meta,
      signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
    }).then(function(_a12) {
      var data = _a12.data, total = _a12.total, pageInfo = _a12.pageInfo, meta2 = _a12.meta;
      return {
        data,
        total,
        pageInfo,
        meta: meta2
      };
    });
  } }, queryOptions2));
  var metaValue = (0, import_react47.useRef)(meta);
  var resourceValue = (0, import_react47.useRef)(resource);
  (0, import_react47.useEffect)(function() {
    metaValue.current = meta;
  }, [meta]);
  (0, import_react47.useEffect)(function() {
    resourceValue.current = resource;
  }, [resource]);
  (0, import_react47.useEffect)(function() {
    var _a12;
    if (result.data === void 0 || result.error != null || result.isFetching)
      return;
    if (((_a12 = result.data) === null || _a12 === void 0 ? void 0 : _a12.data) && result.data.data.length <= MAX_DATA_LENGTH_TO_CACHE) {
      result.data.data.forEach(function(record) {
        queryClient.setQueryData([
          resourceValue.current,
          "getOne",
          { id: String(record.id), meta: metaValue.current }
        ], function(oldRecord) {
          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;
        });
      });
    }
    onSuccessEvent(result.data);
  }, [
    onSuccessEvent,
    queryClient,
    result.data,
    result.error,
    result.isFetching
  ]);
  (0, import_react47.useEffect)(function() {
    if (result.error == null || result.isFetching)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error, result.isFetching]);
  (0, import_react47.useEffect)(function() {
    if (result.status === "pending" || result.isFetching)
      return;
    onSettledEvent(result.data, result.error);
  }, [
    onSettledEvent,
    result.data,
    result.error,
    result.status,
    result.isFetching
  ]);
  return (0, import_react47.useMemo)(function() {
    return result.data ? __assign12(__assign12({}, result), result.data) : result;
  }, [result]);
};
var noop6 = function() {
  return void 0;
};

// node_modules/ra-core/dist/esm/dataProvider/useGetMany.js
var import_react48 = __toESM(require_react());
var __assign13 = function() {
  __assign13 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign13.apply(this, arguments);
};
var __rest8 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useGetMany = function(resource, params, options) {
  if (options === void 0) {
    options = {};
  }
  var ids = params.ids, meta = params.meta;
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var _a11 = options.onError, onError = _a11 === void 0 ? noop7 : _a11, _b = options.onSuccess, onSuccess = _b === void 0 ? noop7 : _b, _c = options.onSettled, onSettled = _c === void 0 ? noop7 : _c, enabled = options.enabled, queryOptions2 = __rest8(options, ["onError", "onSuccess", "onSettled", "enabled"]);
  var onSuccessEvent = useEvent(onSuccess);
  var onErrorEvent = useEvent(onError);
  var onSettledEvent = useEvent(onSettled);
  var result = useQuery(__assign13({ queryKey: [
    resource,
    "getMany",
    {
      ids: !ids || ids.length === 0 ? [] : ids.map(function(id) {
        return String(id);
      }),
      meta
    }
  ], queryFn: function(queryParams) {
    if (!ids || ids.length === 0) {
      return Promise.resolve([]);
    }
    return dataProvider.getMany(resource, {
      ids,
      meta,
      signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
    }).then(function(_a12) {
      var data = _a12.data;
      return data;
    });
  }, placeholderData: function() {
    var records = !ids || ids.length === 0 ? [] : ids.map(function(id) {
      return queryClient.getQueryData([
        resource,
        "getOne",
        { id: String(id), meta }
      ]);
    });
    if (records.some(function(record) {
      return record === void 0;
    })) {
      return void 0;
    } else {
      return records;
    }
  }, retry: false, enabled: enabled !== null && enabled !== void 0 ? enabled : ids != null }, queryOptions2));
  var metaValue = (0, import_react48.useRef)(meta);
  var resourceValue = (0, import_react48.useRef)(resource);
  (0, import_react48.useEffect)(function() {
    metaValue.current = meta;
  }, [meta]);
  (0, import_react48.useEffect)(function() {
    resourceValue.current = resource;
  }, [resource]);
  (0, import_react48.useEffect)(function() {
    if (result.data === void 0 || result.error != null || result.isFetching)
      return;
    result.data.forEach(function(record) {
      queryClient.setQueryData([
        resourceValue.current,
        "getOne",
        { id: String(record.id), meta: metaValue.current }
      ], function(oldRecord) {
        return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;
      });
    });
    onSuccessEvent(result.data);
  }, [
    queryClient,
    onSuccessEvent,
    result.data,
    result.error,
    result.isFetching
  ]);
  (0, import_react48.useEffect)(function() {
    if (result.error == null || result.isFetching)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error, result.isFetching]);
  (0, import_react48.useEffect)(function() {
    if (result.status === "pending" || result.isFetching)
      return;
    onSettledEvent(result.data, result.error);
  }, [
    onSettledEvent,
    result.data,
    result.error,
    result.status,
    result.isFetching
  ]);
  return result;
};
var noop7 = function() {
  return void 0;
};

// node_modules/ra-core/dist/esm/dataProvider/useGetManyAggregate.js
var import_react49 = __toESM(require_react());
var import_union = __toESM(require_union());
var __assign14 = function() {
  __assign14 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign14.apply(this, arguments);
};
var __rest9 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray7 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useGetManyAggregate = function(resource, params, options) {
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var _a11 = options.onError, onError = _a11 === void 0 ? noop8 : _a11, _b = options.onSuccess, onSuccess = _b === void 0 ? noop8 : _b, _c = options.onSettled, onSettled = _c === void 0 ? noop8 : _c, enabled = options.enabled, queryOptions2 = __rest9(options, ["onError", "onSuccess", "onSettled", "enabled"]);
  var onSuccessEvent = useEvent(onSuccess);
  var onErrorEvent = useEvent(onError);
  var onSettledEvent = useEvent(onSettled);
  var ids = params.ids, meta = params.meta;
  var placeholderData = (0, import_react49.useMemo)(function() {
    var records = (Array.isArray(ids) ? ids : [ids]).map(function(id) {
      return queryClient.getQueryData([
        resource,
        "getOne",
        { id: String(id), meta }
      ]);
    });
    if (records.some(function(record) {
      return record === void 0;
    })) {
      return void 0;
    } else {
      return records;
    }
  }, [ids, queryClient, resource, meta]);
  var result = useQuery(__assign14({ queryKey: [
    resource,
    "getMany",
    {
      ids: (Array.isArray(ids) ? ids : [ids]).map(function(id) {
        return String(id);
      }),
      meta
    }
  ], queryFn: function(queryParams) {
    return new Promise(function(resolve, reject) {
      if (!ids || ids.length === 0) {
        return resolve([]);
      }
      return callGetManyQueries({
        resource,
        ids,
        meta,
        resolve,
        reject,
        dataProvider,
        queryClient,
        signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
      });
    });
  }, placeholderData, enabled: enabled !== null && enabled !== void 0 ? enabled : ids != null, retry: false }, queryOptions2));
  var metaValue = (0, import_react49.useRef)(meta);
  var resourceValue = (0, import_react49.useRef)(resource);
  (0, import_react49.useEffect)(function() {
    metaValue.current = meta;
  }, [meta]);
  (0, import_react49.useEffect)(function() {
    resourceValue.current = resource;
  }, [resource]);
  (0, import_react49.useEffect)(function() {
    var _a12;
    if (result.data === void 0 || result.error != null || result.isFetching)
      return;
    ((_a12 = result.data) !== null && _a12 !== void 0 ? _a12 : []).forEach(function(record) {
      queryClient.setQueryData([
        resourceValue.current,
        "getOne",
        { id: String(record.id), meta: metaValue.current }
      ], function(oldRecord) {
        return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;
      });
    });
    onSuccessEvent(result.data);
  }, [
    queryClient,
    onSuccessEvent,
    result.data,
    result.error,
    result.isFetching
  ]);
  (0, import_react49.useEffect)(function() {
    if (result.error == null || result.isFetching)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error, result.isFetching]);
  (0, import_react49.useEffect)(function() {
    if (result.status === "pending" || result.isFetching)
      return;
    onSettledEvent(result.data, result.error);
  }, [
    onSettledEvent,
    result.data,
    result.error,
    result.status,
    result.isFetching
  ]);
  return result;
};
var batch = function(fn) {
  var capturedArgs = [];
  var timeout = null;
  return function(arg) {
    capturedArgs.push(arg);
    if (timeout)
      clearTimeout(timeout);
    timeout = setTimeout(function() {
      timeout = null;
      fn(__spreadArray7([], capturedArgs, true));
      capturedArgs = [];
    }, 0);
  };
};
var callGetManyQueries = batch(function(calls) {
  var dataProvider = calls[0].dataProvider;
  var queryClient = calls[0].queryClient;
  var callsByResource = calls.reduce(function(acc, callArgs) {
    if (!acc[callArgs.resource]) {
      acc[callArgs.resource] = [];
    }
    acc[callArgs.resource].push(callArgs);
    return acc;
  }, {});
  Object.keys(callsByResource).forEach(function(resource) {
    var callsForResource = callsByResource[resource];
    var aggregatedIds = callsForResource.reduce(function(acc, _a11) {
      var ids2 = _a11.ids;
      return (0, import_union.default)(acc, ids2);
    }, []).filter(function(v) {
      return v != null && v !== "";
    });
    var uniqueMeta = callsForResource.reduce(function(acc, _a11) {
      var meta2 = _a11.meta;
      return meta2 || acc;
    }, void 0);
    if (aggregatedIds.length === 0) {
      callsForResource.forEach(function(_a11) {
        var resolve = _a11.resolve;
        resolve([]);
      });
      return;
    }
    var callThatHasAllAggregatedIds = callsForResource.find(function(_a11) {
      var ids2 = _a11.ids, signal2 = _a11.signal;
      return JSON.stringify(ids2) === JSON.stringify(aggregatedIds) && !(signal2 === null || signal2 === void 0 ? void 0 : signal2.aborted);
    });
    if (callThatHasAllAggregatedIds) {
      var dataProvider_1 = callThatHasAllAggregatedIds.dataProvider, resource_1 = callThatHasAllAggregatedIds.resource, ids = callThatHasAllAggregatedIds.ids, meta = callThatHasAllAggregatedIds.meta, signal = callThatHasAllAggregatedIds.signal;
      dataProvider_1.getMany(resource_1, { ids, meta, signal }).then(function(_a11) {
        var data = _a11.data;
        return data;
      }).then(function(data) {
        callsForResource.forEach(function(_a11) {
          var ids2 = _a11.ids, resolve = _a11.resolve;
          resolve(data.filter(function(record) {
            return ids2.map(function(id) {
              return String(id);
            }).includes(String(record.id));
          }));
        });
      }, function(error) {
        callsForResource.forEach(function(_a11) {
          var reject = _a11.reject;
          reject(error);
        });
      });
      return;
    }
    queryClient.fetchQuery({
      queryKey: [
        resource,
        "getMany",
        {
          ids: aggregatedIds.map(function(id) {
            return String(id);
          }),
          meta: uniqueMeta
        }
      ],
      queryFn: function(queryParams) {
        return dataProvider.getMany(resource, {
          ids: aggregatedIds,
          meta: uniqueMeta,
          signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
        }).then(function(_a11) {
          var data = _a11.data;
          return data;
        });
      }
    }).then(function(data) {
      callsForResource.forEach(function(_a11) {
        var ids2 = _a11.ids, resolve = _a11.resolve;
        resolve(data.filter(function(record) {
          return ids2.map(function(id) {
            return String(id);
          }).includes(String(record.id));
        }));
      });
    }).catch(function(error) {
      return callsForResource.forEach(function(_a11) {
        var reject = _a11.reject;
        return reject(error);
      });
    });
  });
});
var noop8 = function() {
  return void 0;
};

// node_modules/ra-core/dist/esm/dataProvider/useGetManyReference.js
var import_react50 = __toESM(require_react());
var __assign15 = function() {
  __assign15 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign15.apply(this, arguments);
};
var __rest10 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useGetManyReference = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var target = params.target, id = params.id, _a11 = params.pagination, pagination = _a11 === void 0 ? { page: 1, perPage: 25 } : _a11, _b = params.sort, sort = _b === void 0 ? { field: "id", order: "DESC" } : _b, _c = params.filter, filter = _c === void 0 ? {} : _c, meta = params.meta;
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var _d = options.onError, onError = _d === void 0 ? noop9 : _d, _e = options.onSuccess, onSuccess = _e === void 0 ? noop9 : _e, _f = options.onSettled, onSettled = _f === void 0 ? noop9 : _f, queryOptions2 = __rest10(options, ["onError", "onSuccess", "onSettled"]);
  var onSuccessEvent = useEvent(onSuccess);
  var onErrorEvent = useEvent(onError);
  var onSettledEvent = useEvent(onSettled);
  var result = useQuery(__assign15({ queryKey: [
    resource,
    "getManyReference",
    { target, id, pagination, sort, filter, meta }
  ], queryFn: function(queryParams) {
    if (!target || id == null) {
      return Promise.reject(new Error("target and id are required"));
    }
    return dataProvider.getManyReference(resource, {
      target,
      id,
      pagination,
      sort,
      filter,
      meta,
      signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
    }).then(function(_a12) {
      var data = _a12.data, total = _a12.total, pageInfo = _a12.pageInfo, meta2 = _a12.meta;
      return {
        data,
        total,
        pageInfo,
        meta: meta2
      };
    });
  } }, queryOptions2));
  (0, import_react50.useEffect)(function() {
    var _a12, _b2;
    if (result.data === void 0)
      return;
    (_b2 = (_a12 = result.data) === null || _a12 === void 0 ? void 0 : _a12.data) === null || _b2 === void 0 ? void 0 : _b2.forEach(function(record) {
      queryClient.setQueryData([resource, "getOne", { id: String(record.id), meta }], function(oldRecord) {
        return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;
      });
    });
    onSuccessEvent(result.data);
  }, [queryClient, meta, onSuccessEvent, resource, result.data]);
  (0, import_react50.useEffect)(function() {
    if (result.error == null)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error]);
  (0, import_react50.useEffect)(function() {
    if (result.status === "pending")
      return;
    onSettledEvent(result.data, result.error);
  }, [onSettledEvent, result.data, result.error, result.status]);
  return (0, import_react50.useMemo)(function() {
    return result.data ? __assign15(__assign15({}, result), result.data) : result;
  }, [result]);
};
var noop9 = function() {
  return void 0;
};

// node_modules/ra-core/dist/esm/dataProvider/useGetRecordId.js
function useGetRecordId(recordId) {
  var _a11;
  var contextRecord = useRecordContext();
  var routeId = useParams().id;
  var actualRecordId = (_a11 = recordId !== null && recordId !== void 0 ? recordId : contextRecord === null || contextRecord === void 0 ? void 0 : contextRecord.id) !== null && _a11 !== void 0 ? _a11 : routeId;
  if (actualRecordId == null)
    throw new Error("useGetRecordId could not find the current record id. You need to use it inside a RecordContextProvider, or inside a supported route, or provide the record id to the hook yourself.");
  return actualRecordId;
}

// node_modules/ra-core/dist/esm/dataProvider/useCreate.js
var import_react51 = __toESM(require_react());
var __assign16 = function() {
  __assign16 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign16.apply(this, arguments);
};
var __rest11 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useCreate = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var paramsRef = (0, import_react51.useRef)(params);
  var hasCallTimeOnError = (0, import_react51.useRef)(false);
  var hasCallTimeOnSuccess = (0, import_react51.useRef)(false);
  var hasCallTimeOnSettled = (0, import_react51.useRef)(false);
  var getMutateWithMiddlewares = options.getMutateWithMiddlewares, mutationOptions = __rest11(options, ["getMutateWithMiddlewares"]);
  var mutation = useMutation(__assign16(__assign16({ mutationFn: function(_a11) {
    var _b = _a11 === void 0 ? {} : _a11, _c = _b.resource, callTimeResource = _c === void 0 ? resource : _c, _d = _b.data, callTimeData = _d === void 0 ? paramsRef.current.data : _d, _e = _b.meta, callTimeMeta = _e === void 0 ? paramsRef.current.meta : _e;
    if (!callTimeResource) {
      throw new Error("useCreate mutation requires a non-empty resource");
    }
    if (!callTimeData) {
      throw new Error("useCreate mutation requires a non-empty data object");
    }
    if (getMutateWithMiddlewares) {
      var createWithMiddlewares = getMutateWithMiddlewares(dataProvider.create.bind(dataProvider));
      return createWithMiddlewares(callTimeResource, {
        data: callTimeData,
        meta: callTimeMeta
      }).then(function(_a12) {
        var data = _a12.data;
        return data;
      });
    }
    return dataProvider.create(callTimeResource, {
      data: callTimeData,
      meta: callTimeMeta
    }).then(function(_a12) {
      var data = _a12.data;
      return data;
    });
  } }, mutationOptions), { onError: function(error, variables, context) {
    if (options.onError && !hasCallTimeOnError.current) {
      return options.onError(error, variables, context);
    }
  }, onSuccess: function(data, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    var _a11 = variables.resource, callTimeResource = _a11 === void 0 ? resource : _a11;
    queryClient.setQueryData([callTimeResource, "getOne", { id: String(data.id) }], data);
    queryClient.invalidateQueries({
      queryKey: [callTimeResource, "getList"]
    });
    queryClient.invalidateQueries({
      queryKey: [callTimeResource, "getInfiniteList"]
    });
    queryClient.invalidateQueries({
      queryKey: [callTimeResource, "getMany"]
    });
    queryClient.invalidateQueries({
      queryKey: [callTimeResource, "getManyReference"]
    });
    if (options.onSuccess && !hasCallTimeOnSuccess.current) {
      options.onSuccess(data, variables, context);
    }
  }, onSettled: function(data, error, variables, context) {
    if (options.onSettled && !hasCallTimeOnSettled.current) {
      return options.onSettled(data, error, variables, context);
    }
  } }));
  var create = function(callTimeResource, callTimeParams, callTimeOptions) {
    if (callTimeResource === void 0) {
      callTimeResource = resource;
    }
    if (callTimeParams === void 0) {
      callTimeParams = {};
    }
    if (callTimeOptions === void 0) {
      callTimeOptions = {};
    }
    var _a11 = callTimeOptions.returnPromise, returnPromise = _a11 === void 0 ? options.returnPromise : _a11, otherCallTimeOptions = __rest11(callTimeOptions, ["returnPromise"]);
    hasCallTimeOnError.current = !!otherCallTimeOptions.onError;
    hasCallTimeOnSuccess.current = !!otherCallTimeOptions.onSuccess;
    hasCallTimeOnSettled.current = !!otherCallTimeOptions.onSettled;
    if (returnPromise) {
      return mutation.mutateAsync(__assign16({ resource: callTimeResource }, callTimeParams), otherCallTimeOptions);
    }
    return mutation.mutate(__assign16({ resource: callTimeResource }, callTimeParams), otherCallTimeOptions);
  };
  var mutationResult = (0, import_react51.useMemo)(function() {
    return __assign16({ isLoading: mutation.isPending }, mutation);
  }, [mutation]);
  return [useEvent(create), mutationResult];
};

// node_modules/ra-core/dist/esm/dataProvider/useUpdate.js
var import_react54 = __toESM(require_react());

// node_modules/ra-core/dist/esm/dataProvider/undo/useAddUndoableMutation.js
var import_react53 = __toESM(require_react());

// node_modules/ra-core/dist/esm/dataProvider/undo/AddUndoableMutationContext.js
var import_react52 = __toESM(require_react());
var AddUndoableMutationContext = (0, import_react52.createContext)(function() {
});

// node_modules/ra-core/dist/esm/dataProvider/undo/useAddUndoableMutation.js
var useAddUndoableMutation = function() {
  return (0, import_react53.useContext)(AddUndoableMutationContext);
};

// node_modules/ra-core/dist/esm/dataProvider/useUpdate.js
var __assign17 = function() {
  __assign17 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign17.apply(this, arguments);
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator5 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest12 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray8 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useUpdate = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var addUndoableMutation = useAddUndoableMutation();
  var id = params.id, data = params.data, meta = params.meta;
  var _a11 = options.mutationMode, mutationMode = _a11 === void 0 ? "pessimistic" : _a11, getMutateWithMiddlewares = options.getMutateWithMiddlewares, mutationOptions = __rest12(options, ["mutationMode", "getMutateWithMiddlewares"]);
  var mode = (0, import_react54.useRef)(mutationMode);
  var paramsRef = (0, import_react54.useRef)(params);
  var snapshot = (0, import_react54.useRef)([]);
  var mutateWithMiddlewares = (0, import_react54.useRef)(dataProvider.update);
  var callTimeOnError = (0, import_react54.useRef)();
  var callTimeOnSettled = (0, import_react54.useRef)();
  var hasCallTimeOnSuccess = (0, import_react54.useRef)(false);
  var updateCache = function(_a12) {
    var resource2 = _a12.resource, id2 = _a12.id, data2 = _a12.data, meta2 = _a12.meta;
    var now = Date.now();
    var updatedAt = mode.current === "undoable" ? now + 5 * 1e3 : now;
    var clonedData = JSON.parse(JSON.stringify(data2));
    var updateColl = function(old) {
      if (!old)
        return old;
      var index = old.findIndex(
        // eslint-disable-next-line eqeqeq
        function(record) {
          return record.id == id2;
        }
      );
      if (index === -1) {
        return old;
      }
      return __spreadArray8(__spreadArray8(__spreadArray8([], old.slice(0, index), true), [
        __assign17(__assign17({}, old[index]), clonedData)
      ], false), old.slice(index + 1), true);
    };
    queryClient.setQueryData([resource2, "getOne", { id: String(id2), meta: meta2 }], function(record) {
      return __assign17(__assign17({}, record), clonedData);
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getList"] }, function(res) {
      return res && res.data ? __assign17(__assign17({}, res), { data: updateColl(res.data) }) : res;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getInfiniteList"] }, function(res) {
      return res && res.pages ? __assign17(__assign17({}, res), { pages: res.pages.map(function(page) {
        return __assign17(__assign17({}, page), { data: updateColl(page.data) });
      }) }) : res;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getMany"] }, function(coll) {
      return coll && coll.length > 0 ? updateColl(coll) : coll;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getManyReference"] }, function(res) {
      return res && res.data ? { data: updateColl(res.data), total: res.total } : res;
    }, { updatedAt });
  };
  var mutation = useMutation(__assign17(__assign17({ mutationFn: function(_a12) {
    var _b = _a12 === void 0 ? {} : _a12, _c = _b.resource, callTimeResource = _c === void 0 ? resource : _c, _d = _b.id, callTimeId = _d === void 0 ? paramsRef.current.id : _d, _e = _b.data, callTimeData = _e === void 0 ? paramsRef.current.data : _e, _f = _b.meta, callTimeMeta = _f === void 0 ? paramsRef.current.meta : _f, _g = _b.previousData, callTimePreviousData = _g === void 0 ? paramsRef.current.previousData : _g;
    if (!callTimeResource) {
      throw new Error("useUpdate mutation requires a non-empty resource");
    }
    if (callTimeId == null) {
      throw new Error("useUpdate mutation requires a non-empty id");
    }
    if (!callTimeData) {
      throw new Error("useUpdate mutation requires a non-empty data object");
    }
    return mutateWithMiddlewares.current(callTimeResource, {
      id: callTimeId,
      data: callTimeData,
      previousData: callTimePreviousData,
      meta: callTimeMeta
    }).then(function(_a13) {
      var data2 = _a13.data;
      return data2;
    });
  } }, mutationOptions), { onMutate: function(variables) {
    return __awaiter5(void 0, void 0, void 0, function() {
      var userContext;
      return __generator5(this, function(_a12) {
        switch (_a12.label) {
          case 0:
            if (!mutationOptions.onMutate) return [3, 2];
            return [4, mutationOptions.onMutate(variables)];
          case 1:
            userContext = _a12.sent() || {};
            return [2, __assign17({ snapshot: snapshot.current }, userContext)];
          case 2:
            return [2, { snapshot: snapshot.current }];
        }
      });
    });
  }, onError: function(error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var key = _a12[0], value = _a12[1];
        queryClient.setQueryData(key, value);
      });
    }
    if (callTimeOnError.current) {
      return callTimeOnError.current(error, variables, context);
    }
    if (mutationOptions.onError) {
      return mutationOptions.onError(error, variables, context);
    }
  }, onSuccess: function(data2, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "pessimistic") {
      var _a12 = variables.resource, callTimeResource = _a12 === void 0 ? resource : _a12, _b = variables.id, callTimeId = _b === void 0 ? id : _b, _c = variables.meta, callTimeMeta = _c === void 0 ? meta : _c;
      updateCache({
        resource: callTimeResource,
        id: callTimeId,
        data: data2,
        meta: callTimeMeta
      });
      if (mutationOptions.onSuccess && !hasCallTimeOnSuccess.current) {
        mutationOptions.onSuccess(data2, variables, context);
      }
    }
  }, onSettled: function(data2, error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var queryKey = _a12[0];
        queryClient.invalidateQueries({ queryKey });
      });
    }
    if (callTimeOnSettled.current) {
      return callTimeOnSettled.current(data2, error, variables, context);
    }
    if (mutationOptions.onSettled) {
      return mutationOptions.onSettled(data2, error, variables, context);
    }
  } }));
  var update = function(callTimeResource, callTimeParams, callTimeOptions) {
    if (callTimeResource === void 0) {
      callTimeResource = resource;
    }
    if (callTimeParams === void 0) {
      callTimeParams = {};
    }
    if (callTimeOptions === void 0) {
      callTimeOptions = {};
    }
    return __awaiter5(void 0, void 0, void 0, function() {
      var mutationMode2, _a12, returnPromise, onError, onSettled, onSuccess, otherCallTimeOptions, _b, callTimeId, _c, callTimeData, _d, callTimeMeta, previousRecord, queryKeys;
      return __generator5(this, function(_e) {
        switch (_e.label) {
          case 0:
            mutationMode2 = callTimeOptions.mutationMode, _a12 = callTimeOptions.returnPromise, returnPromise = _a12 === void 0 ? mutationOptions.returnPromise : _a12, onError = callTimeOptions.onError, onSettled = callTimeOptions.onSettled, onSuccess = callTimeOptions.onSuccess, otherCallTimeOptions = __rest12(callTimeOptions, ["mutationMode", "returnPromise", "onError", "onSettled", "onSuccess"]);
            if (getMutateWithMiddlewares) {
              mutateWithMiddlewares.current = getMutateWithMiddlewares(dataProvider.update.bind(dataProvider));
            } else {
              mutateWithMiddlewares.current = dataProvider.update;
            }
            hasCallTimeOnSuccess.current = !!onSuccess;
            callTimeOnError.current = onError;
            callTimeOnSettled.current = onSettled;
            paramsRef.current = params;
            if (mutationMode2) {
              mode.current = mutationMode2;
            }
            if (returnPromise && mode.current !== "pessimistic") {
              console.warn("The returnPromise parameter can only be used if the mutationMode is set to pessimistic");
            }
            if (mode.current === "pessimistic") {
              if (returnPromise) {
                return [2, mutation.mutateAsync(__assign17({ resource: callTimeResource }, callTimeParams), __assign17({ onSuccess }, otherCallTimeOptions))];
              }
              return [2, mutation.mutate(__assign17({ resource: callTimeResource }, callTimeParams), __assign17({ onSuccess }, otherCallTimeOptions))];
            }
            _b = callTimeParams.id, callTimeId = _b === void 0 ? id : _b, _c = callTimeParams.data, callTimeData = _c === void 0 ? data : _c, _d = callTimeParams.meta, callTimeMeta = _d === void 0 ? meta : _d;
            previousRecord = queryClient.getQueryData([
              callTimeResource,
              "getOne",
              { id: String(callTimeId), meta: callTimeMeta }
            ]);
            queryKeys = [
              [
                callTimeResource,
                "getOne",
                { id: String(callTimeId), meta: callTimeMeta }
              ],
              [callTimeResource, "getList"],
              [callTimeResource, "getInfiniteList"],
              [callTimeResource, "getMany"],
              [callTimeResource, "getManyReference"]
            ];
            snapshot.current = queryKeys.reduce(function(prev, queryKey) {
              return prev.concat(queryClient.getQueriesData({ queryKey }));
            }, []);
            return [4, Promise.all(snapshot.current.map(function(_a13) {
              var queryKey = _a13[0];
              return queryClient.cancelQueries({ queryKey });
            }))];
          case 1:
            _e.sent();
            updateCache({
              resource: callTimeResource,
              id: callTimeId,
              data: callTimeData,
              meta: callTimeMeta
            });
            setTimeout(function() {
              if (onSuccess) {
                onSuccess(__assign17(__assign17({}, previousRecord), callTimeData), __assign17({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              } else if (mutationOptions.onSuccess && !hasCallTimeOnSuccess.current) {
                mutationOptions.onSuccess(__assign17(__assign17({}, previousRecord), callTimeData), __assign17({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              }
            }, 0);
            if (mode.current === "optimistic") {
              return [2, mutation.mutate(__assign17({ resource: callTimeResource }, callTimeParams))];
            } else {
              addUndoableMutation(function(_a13) {
                var isUndo = _a13.isUndo;
                if (isUndo) {
                  snapshot.current.forEach(function(_a14) {
                    var key = _a14[0], value = _a14[1];
                    queryClient.setQueryData(key, value);
                  });
                } else {
                  mutation.mutate(__assign17({ resource: callTimeResource }, callTimeParams));
                }
              });
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  var mutationResult = (0, import_react54.useMemo)(function() {
    return __assign17({ isLoading: mutation.isPending }, mutation);
  }, [mutation]);
  return [useEvent(update), mutationResult];
};

// node_modules/ra-core/dist/esm/dataProvider/useUpdateMany.js
var import_react55 = __toESM(require_react());
var __assign18 = function() {
  __assign18 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign18.apply(this, arguments);
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator6 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest13 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray9 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useUpdateMany = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var addUndoableMutation = useAddUndoableMutation();
  var ids = params.ids, data = params.data, meta = params.meta;
  var _a11 = options.mutationMode, mutationMode = _a11 === void 0 ? "pessimistic" : _a11, mutationOptions = __rest13(options, ["mutationMode"]);
  var mode = (0, import_react55.useRef)(mutationMode);
  var paramsRef = (0, import_react55.useRef)(params);
  var snapshot = (0, import_react55.useRef)([]);
  var hasCallTimeOnError = (0, import_react55.useRef)(false);
  var hasCallTimeOnSuccess = (0, import_react55.useRef)(false);
  var hasCallTimeOnSettled = (0, import_react55.useRef)(false);
  var updateCache = function(_a12) {
    var resource2 = _a12.resource, ids2 = _a12.ids, data2 = _a12.data, meta2 = _a12.meta;
    return __awaiter6(void 0, void 0, void 0, function() {
      var updatedAt, clonedData, updateColl;
      return __generator6(this, function(_b) {
        updatedAt = mode.current === "undoable" ? Date.now() + 1e3 * 5 : Date.now();
        clonedData = JSON.parse(JSON.stringify(data2));
        updateColl = function(old) {
          if (!old)
            return old;
          var newCollection = __spreadArray9([], old, true);
          ids2.forEach(function(id) {
            var index = old.findIndex(function(record) {
              return record.id == id;
            });
            if (index === -1) {
              return;
            }
            newCollection = __spreadArray9(__spreadArray9(__spreadArray9([], newCollection.slice(0, index), true), [
              __assign18(__assign18({}, newCollection[index]), clonedData)
            ], false), newCollection.slice(index + 1), true);
          });
          return newCollection;
        };
        ids2.forEach(function(id) {
          queryClient.setQueryData([resource2, "getOne", { id: String(id), meta: meta2 }], function(record) {
            return __assign18(__assign18({}, record), clonedData);
          }, { updatedAt });
        });
        queryClient.setQueriesData({ queryKey: [resource2, "getList"] }, function(res) {
          return res && res.data ? __assign18(__assign18({}, res), { data: updateColl(res.data) }) : res;
        }, { updatedAt });
        queryClient.setQueriesData({ queryKey: [resource2, "getInfiniteList"] }, function(res) {
          return res && res.pages ? __assign18(__assign18({}, res), { pages: res.pages.map(function(page) {
            return __assign18(__assign18({}, page), { data: updateColl(page.data) });
          }) }) : res;
        }, { updatedAt });
        queryClient.setQueriesData({ queryKey: [resource2, "getMany"] }, function(coll) {
          return coll && coll.length > 0 ? updateColl(coll) : coll;
        }, { updatedAt });
        queryClient.setQueriesData({ queryKey: [resource2, "getManyReference"] }, function(res) {
          return res && res.data ? { data: updateColl(res.data), total: res.total } : res;
        }, { updatedAt });
        return [
          2
          /*return*/
        ];
      });
    });
  };
  var mutation = useMutation(__assign18(__assign18({ mutationFn: function(_a12) {
    var _b = _a12 === void 0 ? {} : _a12, _c = _b.resource, callTimeResource = _c === void 0 ? resource : _c, _d = _b.ids, callTimeIds = _d === void 0 ? paramsRef.current.ids : _d, _e = _b.data, callTimeData = _e === void 0 ? paramsRef.current.data : _e, _f = _b.meta, callTimeMeta = _f === void 0 ? paramsRef.current.meta : _f;
    if (!callTimeResource) {
      throw new Error("useUpdateMany mutation requires a non-empty resource");
    }
    if (!callTimeIds) {
      throw new Error("useUpdateMany mutation requires an array of ids");
    }
    if (!callTimeData) {
      throw new Error("useUpdateMany mutation requires a non-empty data object");
    }
    return dataProvider.updateMany(callTimeResource, {
      ids: callTimeIds,
      data: callTimeData,
      meta: callTimeMeta
    }).then(function(_a13) {
      var data2 = _a13.data;
      return data2 || [];
    });
  } }, mutationOptions), { onMutate: function(variables) {
    return __awaiter6(void 0, void 0, void 0, function() {
      var userContext;
      return __generator6(this, function(_a12) {
        switch (_a12.label) {
          case 0:
            if (!mutationOptions.onMutate) return [3, 2];
            return [4, mutationOptions.onMutate(variables)];
          case 1:
            userContext = _a12.sent() || {};
            return [2, __assign18({ snapshot: snapshot.current }, userContext)];
          case 2:
            return [2, { snapshot: snapshot.current }];
        }
      });
    });
  }, onError: function(error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var key = _a12[0], value = _a12[1];
        queryClient.setQueryData(key, value);
      });
    }
    if (mutationOptions.onError && !hasCallTimeOnError.current) {
      return mutationOptions.onError(error, variables, context);
    }
  }, onSuccess: function(dataFromResponse, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "pessimistic") {
      var _a12 = variables.resource, callTimeResource = _a12 === void 0 ? resource : _a12, _b = variables.ids, callTimeIds = _b === void 0 ? ids : _b, _c = variables.data, callTimeData = _c === void 0 ? data : _c, _d = variables.meta, callTimeMeta = _d === void 0 ? meta : _d;
      if (!callTimeResource) {
        throw new Error("useUpdateMany mutation requires a non-empty resource");
      }
      if (!callTimeIds) {
        throw new Error("useUpdateMany mutation requires an array of ids");
      }
      updateCache({
        resource: callTimeResource,
        ids: callTimeIds,
        data: callTimeData,
        meta: callTimeMeta
      });
      if (mutationOptions.onSuccess && !hasCallTimeOnSuccess.current) {
        mutationOptions.onSuccess(dataFromResponse, variables, context);
      }
    }
  }, onSettled: function(data2, error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var queryKey = _a12[0];
        queryClient.invalidateQueries({ queryKey });
      });
    }
    if (mutationOptions.onSettled && !hasCallTimeOnSettled.current) {
      return mutationOptions.onSettled(data2, error, variables, context);
    }
  } }));
  var updateMany = function(callTimeResource, callTimeParams, callTimeOptions) {
    if (callTimeResource === void 0) {
      callTimeResource = resource;
    }
    if (callTimeParams === void 0) {
      callTimeParams = {};
    }
    if (callTimeOptions === void 0) {
      callTimeOptions = {};
    }
    return __awaiter6(void 0, void 0, void 0, function() {
      var mutationMode2, _a12, returnPromise, otherCallTimeOptions, _b, callTimeIds, _c, callTimeData, _d, callTimeMeta, queryKeys;
      return __generator6(this, function(_e) {
        switch (_e.label) {
          case 0:
            if (!callTimeResource) {
              throw new Error("useUpdateMany mutation requires a non-empty resource");
            }
            mutationMode2 = callTimeOptions.mutationMode, _a12 = callTimeOptions.returnPromise, returnPromise = _a12 === void 0 ? mutationOptions.returnPromise : _a12, otherCallTimeOptions = __rest13(callTimeOptions, ["mutationMode", "returnPromise"]);
            hasCallTimeOnError.current = !!otherCallTimeOptions.onError;
            hasCallTimeOnSuccess.current = !!otherCallTimeOptions.onSuccess;
            hasCallTimeOnSettled.current = !!otherCallTimeOptions.onSettled;
            paramsRef.current = params;
            if (mutationMode2) {
              mode.current = mutationMode2;
            }
            if (returnPromise && mode.current !== "pessimistic") {
              console.warn("The returnPromise parameter can only be used if the mutationMode is set to pessimistic");
            }
            if (mode.current === "pessimistic") {
              if (returnPromise) {
                return [2, mutation.mutateAsync(__assign18({ resource: callTimeResource }, callTimeParams), otherCallTimeOptions)];
              }
              return [2, mutation.mutate(__assign18({ resource: callTimeResource }, callTimeParams), otherCallTimeOptions)];
            }
            _b = callTimeParams.ids, callTimeIds = _b === void 0 ? ids : _b, _c = callTimeParams.data, callTimeData = _c === void 0 ? data : _c, _d = callTimeParams.meta, callTimeMeta = _d === void 0 ? meta : _d;
            if (!callTimeIds) {
              throw new Error("useUpdateMany mutation requires an array of ids");
            }
            queryKeys = [
              [callTimeResource, "getOne"],
              [callTimeResource, "getList"],
              [callTimeResource, "getInfiniteList"],
              [callTimeResource, "getMany"],
              [callTimeResource, "getManyReference"]
            ];
            snapshot.current = queryKeys.reduce(function(prev, queryKey) {
              return prev.concat(queryClient.getQueriesData({ queryKey }));
            }, []);
            return [4, Promise.all(snapshot.current.map(function(_a13) {
              var queryKey = _a13[0];
              return queryClient.cancelQueries({ queryKey });
            }))];
          case 1:
            _e.sent();
            return [4, updateCache({
              resource: callTimeResource,
              ids: callTimeIds,
              data: callTimeData,
              meta: callTimeMeta
            })];
          case 2:
            _e.sent();
            setTimeout(function() {
              if (otherCallTimeOptions.onSuccess) {
                otherCallTimeOptions.onSuccess(callTimeIds, __assign18({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              } else if (mutationOptions.onSuccess) {
                mutationOptions.onSuccess(callTimeIds, __assign18({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              }
            }, 0);
            if (mode.current === "optimistic") {
              return [2, mutation.mutate(__assign18({ resource: callTimeResource }, callTimeParams), {
                onSettled: otherCallTimeOptions.onSettled,
                onError: otherCallTimeOptions.onError
              })];
            } else {
              addUndoableMutation(function(_a13) {
                var isUndo = _a13.isUndo;
                if (isUndo) {
                  snapshot.current.forEach(function(_a14) {
                    var key = _a14[0], value = _a14[1];
                    queryClient.setQueryData(key, value);
                  });
                } else {
                  mutation.mutate(__assign18({ resource: callTimeResource }, callTimeParams), {
                    onSettled: otherCallTimeOptions.onSettled,
                    onError: otherCallTimeOptions.onError
                  });
                }
              });
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  var mutationResult = (0, import_react55.useMemo)(function() {
    return __assign18({ isLoading: mutation.isPending }, mutation);
  }, [mutation]);
  return [useEvent(updateMany), mutationResult];
};

// node_modules/ra-core/dist/esm/dataProvider/useDelete.js
var import_react56 = __toESM(require_react());
var __assign19 = function() {
  __assign19 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign19.apply(this, arguments);
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator7 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest14 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray10 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useDelete = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var addUndoableMutation = useAddUndoableMutation();
  var id = params.id, previousData = params.previousData;
  var _a11 = options.mutationMode, mutationMode = _a11 === void 0 ? "pessimistic" : _a11, mutationOptions = __rest14(options, ["mutationMode"]);
  var mode = (0, import_react56.useRef)(mutationMode);
  var paramsRef = (0, import_react56.useRef)(params);
  var snapshot = (0, import_react56.useRef)([]);
  var hasCallTimeOnError = (0, import_react56.useRef)(false);
  var hasCallTimeOnSuccess = (0, import_react56.useRef)(false);
  var hasCallTimeOnSettled = (0, import_react56.useRef)(false);
  var updateCache = function(_a12) {
    var resource2 = _a12.resource, id2 = _a12.id;
    var now = Date.now();
    var updatedAt = mode.current === "undoable" ? now + 5 * 1e3 : now;
    var updateColl = function(old) {
      if (!old)
        return old;
      var index = old.findIndex(
        // eslint-disable-next-line eqeqeq
        function(record) {
          return record.id == id2;
        }
      );
      if (index === -1) {
        return old;
      }
      return __spreadArray10(__spreadArray10([], old.slice(0, index), true), old.slice(index + 1), true);
    };
    queryClient.setQueriesData({ queryKey: [resource2, "getList"] }, function(res) {
      if (!res || !res.data)
        return res;
      var newCollection = updateColl(res.data);
      var recordWasFound = newCollection.length < res.data.length;
      return recordWasFound ? {
        data: newCollection,
        total: res.total ? res.total - 1 : void 0,
        pageInfo: res.pageInfo
      } : res;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getInfiniteList"] }, function(res) {
      if (!res || !res.pages)
        return res;
      return __assign19(__assign19({}, res), { pages: res.pages.map(function(page) {
        var newCollection = updateColl(page.data);
        var recordWasFound = newCollection.length < page.data.length;
        return recordWasFound ? __assign19(__assign19({}, page), { data: newCollection, total: page.total ? page.total - 1 : void 0, pageInfo: page.pageInfo }) : page;
      }) });
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getMany"] }, function(coll) {
      return coll && coll.length > 0 ? updateColl(coll) : coll;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getManyReference"] }, function(res) {
      if (!res || !res.data)
        return res;
      var newCollection = updateColl(res.data);
      var recordWasFound = newCollection.length < res.data.length;
      return recordWasFound ? {
        data: newCollection,
        total: res.total - 1
      } : res;
    }, { updatedAt });
  };
  var mutation = useMutation(__assign19(__assign19({ mutationFn: function(_a12) {
    var _b = _a12 === void 0 ? {} : _a12, _c = _b.resource, callTimeResource = _c === void 0 ? resource : _c, _d = _b.id, callTimeId = _d === void 0 ? paramsRef.current.id : _d, _e = _b.previousData, callTimePreviousData = _e === void 0 ? paramsRef.current.previousData : _e, _f = _b.meta, callTimeMeta = _f === void 0 ? paramsRef.current.meta : _f;
    if (!callTimeResource) {
      throw new Error("useDelete mutation requires a non-empty resource");
    }
    if (callTimeId == null) {
      throw new Error("useDelete mutation requires a non-empty id");
    }
    return dataProvider.delete(callTimeResource, {
      id: callTimeId,
      previousData: callTimePreviousData,
      meta: callTimeMeta
    }).then(function(_a13) {
      var data = _a13.data;
      return data;
    });
  } }, mutationOptions), { onMutate: function(variables) {
    return __awaiter7(void 0, void 0, void 0, function() {
      var userContext;
      return __generator7(this, function(_a12) {
        switch (_a12.label) {
          case 0:
            if (!mutationOptions.onMutate) return [3, 2];
            return [4, mutationOptions.onMutate(variables)];
          case 1:
            userContext = _a12.sent() || {};
            return [2, __assign19({ snapshot: snapshot.current }, userContext)];
          case 2:
            return [2, { snapshot: snapshot.current }];
        }
      });
    });
  }, onError: function(error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var key = _a12[0], value = _a12[1];
        queryClient.setQueryData(key, value);
      });
    }
    if (mutationOptions.onError && !hasCallTimeOnError.current) {
      return mutationOptions.onError(error, variables, context);
    }
  }, onSuccess: function(data, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "pessimistic") {
      var _a12 = variables.resource, callTimeResource = _a12 === void 0 ? resource : _a12, _b = variables.id, callTimeId = _b === void 0 ? id : _b;
      updateCache({
        resource: callTimeResource,
        id: callTimeId
      });
      if (mutationOptions.onSuccess && !hasCallTimeOnSuccess.current) {
        mutationOptions.onSuccess(data, variables, context);
      }
    }
  }, onSettled: function(data, error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    context.snapshot.forEach(function(_a12) {
      var queryKey = _a12[0];
      queryClient.invalidateQueries({ queryKey });
    });
    if (mutationOptions.onSettled && !hasCallTimeOnSettled.current) {
      return mutationOptions.onSettled(data, error, variables, context);
    }
  } }));
  var mutate = function(callTimeResource, callTimeParams, callTimeOptions) {
    if (callTimeResource === void 0) {
      callTimeResource = resource;
    }
    if (callTimeParams === void 0) {
      callTimeParams = {};
    }
    if (callTimeOptions === void 0) {
      callTimeOptions = {};
    }
    return __awaiter7(void 0, void 0, void 0, function() {
      var mutationMode2, otherCallTimeOptions, _a12, callTimeId, _b, callTimePreviousData, queryKeys;
      return __generator7(this, function(_c) {
        switch (_c.label) {
          case 0:
            mutationMode2 = callTimeOptions.mutationMode, otherCallTimeOptions = __rest14(callTimeOptions, ["mutationMode"]);
            hasCallTimeOnError.current = !!callTimeOptions.onError;
            hasCallTimeOnSuccess.current = !!callTimeOptions.onSuccess;
            hasCallTimeOnSettled.current = !!callTimeOptions.onSettled;
            paramsRef.current = params;
            if (mutationMode2) {
              mode.current = mutationMode2;
            }
            _a12 = callTimeParams.id, callTimeId = _a12 === void 0 ? id : _a12, _b = callTimeParams.previousData, callTimePreviousData = _b === void 0 ? previousData : _b;
            queryKeys = [
              [callTimeResource, "getList"],
              [callTimeResource, "getInfiniteList"],
              [callTimeResource, "getMany"],
              [callTimeResource, "getManyReference"]
            ];
            snapshot.current = queryKeys.reduce(function(prev, queryKey) {
              return prev.concat(queryClient.getQueriesData({ queryKey }));
            }, []);
            if (mode.current === "pessimistic") {
              return [2, mutation.mutate(__assign19({ resource: callTimeResource }, callTimeParams), otherCallTimeOptions)];
            }
            return [4, Promise.all(snapshot.current.map(function(_a13) {
              var queryKey = _a13[0];
              return queryClient.cancelQueries({ queryKey });
            }))];
          case 1:
            _c.sent();
            updateCache({
              resource: callTimeResource,
              id: callTimeId
            });
            setTimeout(function() {
              if (callTimeOptions.onSuccess) {
                callTimeOptions.onSuccess(callTimePreviousData, __assign19({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              } else if (mutationOptions.onSuccess) {
                mutationOptions.onSuccess(callTimePreviousData, __assign19({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              }
            }, 0);
            if (mode.current === "optimistic") {
              return [2, mutation.mutate(__assign19({ resource: callTimeResource }, callTimeParams), {
                onSettled: callTimeOptions.onSettled,
                onError: callTimeOptions.onError
              })];
            } else {
              addUndoableMutation(function(_a13) {
                var isUndo = _a13.isUndo;
                if (isUndo) {
                  snapshot.current.forEach(function(_a14) {
                    var key = _a14[0], value = _a14[1];
                    queryClient.setQueryData(key, value);
                  });
                } else {
                  mutation.mutate(__assign19({ resource: callTimeResource }, callTimeParams), {
                    onSettled: callTimeOptions.onSettled,
                    onError: callTimeOptions.onError
                  });
                }
              });
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  var mutationResult = (0, import_react56.useMemo)(function() {
    return __assign19({ isLoading: mutation.isPending }, mutation);
  }, [mutation]);
  return [useEvent(mutate), mutationResult];
};

// node_modules/ra-core/dist/esm/dataProvider/useDeleteMany.js
var import_react57 = __toESM(require_react());
var __assign20 = function() {
  __assign20 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign20.apply(this, arguments);
};
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator8 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest15 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray11 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useDeleteMany = function(resource, params, options) {
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var addUndoableMutation = useAddUndoableMutation();
  var ids = params.ids;
  var _a11 = options.mutationMode, mutationMode = _a11 === void 0 ? "pessimistic" : _a11, mutationOptions = __rest15(options, ["mutationMode"]);
  var mode = (0, import_react57.useRef)(mutationMode);
  var paramsRef = (0, import_react57.useRef)({});
  var snapshot = (0, import_react57.useRef)([]);
  var hasCallTimeOnError = (0, import_react57.useRef)(false);
  var hasCallTimeOnSuccess = (0, import_react57.useRef)(false);
  var hasCallTimeOnSettled = (0, import_react57.useRef)(false);
  var updateCache = function(_a12) {
    var resource2 = _a12.resource, ids2 = _a12.ids;
    var now = Date.now();
    var updatedAt = mode.current === "undoable" ? now + 5 * 1e3 : now;
    var updateColl = function(old) {
      if (!old)
        return old;
      var newCollection = __spreadArray11([], old, true);
      ids2.forEach(function(id) {
        var index = newCollection.findIndex(
          // eslint-disable-next-line eqeqeq
          function(record) {
            return record.id == id;
          }
        );
        if (index === -1) {
          return;
        }
        newCollection = __spreadArray11(__spreadArray11([], newCollection.slice(0, index), true), newCollection.slice(index + 1), true);
      });
      return newCollection;
    };
    queryClient.setQueriesData({ queryKey: [resource2, "getList"] }, function(res) {
      if (!res || !res.data)
        return res;
      var newCollection = updateColl(res.data);
      var recordWasFound = newCollection.length < res.data.length;
      return recordWasFound ? {
        data: newCollection,
        total: res.total ? res.total - (res.data.length - newCollection.length) : void 0,
        pageInfo: res.pageInfo
      } : res;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getInfiniteList"] }, function(res) {
      if (!res || !res.pages)
        return res;
      return __assign20(__assign20({}, res), { pages: res.pages.map(function(page) {
        var newCollection = updateColl(page.data);
        var recordWasFound = newCollection.length < page.data.length;
        return recordWasFound ? __assign20(__assign20({}, page), { data: newCollection, total: page.total ? page.total - (page.data.length - newCollection.length) : void 0, pageInfo: page.pageInfo }) : page;
      }) });
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getMany"] }, function(coll) {
      return coll && coll.length > 0 ? updateColl(coll) : coll;
    }, { updatedAt });
    queryClient.setQueriesData({ queryKey: [resource2, "getManyReference"] }, function(res) {
      if (!res || !res.data)
        return res;
      var newCollection = updateColl(res.data);
      var recordWasFound = newCollection.length < res.data.length;
      if (!recordWasFound) {
        return res;
      }
      if (res.total) {
        return {
          data: newCollection,
          total: res.total - (res.data.length - newCollection.length)
        };
      }
      if (res.pageInfo) {
        return {
          data: newCollection,
          pageInfo: res.pageInfo
        };
      }
      throw new Error("Found getList result in cache without total or pageInfo");
    }, { updatedAt });
  };
  var mutation = useMutation(__assign20(__assign20({ mutationFn: function(_a12) {
    var _b = _a12 === void 0 ? {} : _a12, _c = _b.resource, callTimeResource = _c === void 0 ? resource : _c, _d = _b.ids, callTimeIds = _d === void 0 ? paramsRef.current.ids : _d, _e = _b.meta, callTimeMeta = _e === void 0 ? paramsRef.current.meta : _e;
    if (!callTimeResource) {
      throw new Error("useDeleteMany mutation requires a non-empty resource");
    }
    if (!callTimeIds) {
      throw new Error("useDeleteMany mutation requires an array of ids");
    }
    if (callTimeIds.length === 0) {
      return Promise.resolve([]);
    }
    return dataProvider.deleteMany(callTimeResource, {
      ids: callTimeIds,
      meta: callTimeMeta
    }).then(function(_a13) {
      var data = _a13.data;
      return data || [];
    });
  } }, mutationOptions), { onMutate: function(variables) {
    return __awaiter8(void 0, void 0, void 0, function() {
      var userContext;
      return __generator8(this, function(_a12) {
        switch (_a12.label) {
          case 0:
            if (!mutationOptions.onMutate) return [3, 2];
            return [4, mutationOptions.onMutate(variables)];
          case 1:
            userContext = _a12.sent() || {};
            return [2, __assign20({ snapshot: snapshot.current }, userContext)];
          case 2:
            return [2, { snapshot: snapshot.current }];
        }
      });
    });
  }, onError: function(error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var key = _a12[0], value = _a12[1];
        queryClient.setQueryData(key, value);
      });
    }
    if (mutationOptions.onError && !hasCallTimeOnError.current) {
      return mutationOptions.onError(error, variables, context);
    }
  }, onSuccess: function(data, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "pessimistic") {
      var _a12 = variables.resource, callTimeResource = _a12 === void 0 ? resource : _a12, _b = variables.ids, callTimeIds = _b === void 0 ? ids : _b;
      updateCache({
        resource: callTimeResource,
        ids: callTimeIds
      });
      if (mutationOptions.onSuccess && !hasCallTimeOnSuccess.current) {
        mutationOptions.onSuccess(data, variables, context);
      }
    }
  }, onSettled: function(data, error, variables, context) {
    if (variables === void 0) {
      variables = {};
    }
    if (mode.current === "optimistic" || mode.current === "undoable") {
      context.snapshot.forEach(function(_a12) {
        var queryKey = _a12[0];
        queryClient.invalidateQueries({ queryKey });
      });
    }
    if (mutationOptions.onSettled && !hasCallTimeOnSettled.current) {
      return mutationOptions.onSettled(data, error, variables, context);
    }
  } }));
  var mutate = function(callTimeResource, callTimeParams, callTimeOptions) {
    if (callTimeResource === void 0) {
      callTimeResource = resource;
    }
    if (callTimeParams === void 0) {
      callTimeParams = {};
    }
    if (callTimeOptions === void 0) {
      callTimeOptions = {};
    }
    return __awaiter8(void 0, void 0, void 0, function() {
      var mutationMode2, otherCallTimeOptions, _a12, callTimeIds, queryKeys;
      return __generator8(this, function(_b) {
        switch (_b.label) {
          case 0:
            mutationMode2 = callTimeOptions.mutationMode, otherCallTimeOptions = __rest15(callTimeOptions, ["mutationMode"]);
            hasCallTimeOnError.current = !!callTimeOptions.onError;
            hasCallTimeOnSuccess.current = !!callTimeOptions.onSuccess;
            hasCallTimeOnSettled.current = !!callTimeOptions.onSettled;
            paramsRef.current = params;
            if (mutationMode2) {
              mode.current = mutationMode2;
            }
            if (mode.current === "pessimistic") {
              return [2, mutation.mutate(__assign20({ resource: callTimeResource }, callTimeParams), {
                onSuccess: otherCallTimeOptions.onSuccess,
                onSettled: otherCallTimeOptions.onSettled,
                onError: otherCallTimeOptions.onError
              })];
            }
            _a12 = callTimeParams.ids, callTimeIds = _a12 === void 0 ? ids : _a12;
            if (!callTimeIds) {
              throw new Error("useDeleteMany mutation requires an array of ids");
            }
            queryKeys = [
              [callTimeResource, "getList"],
              [callTimeResource, "getInfiniteList"],
              [callTimeResource, "getMany"],
              [callTimeResource, "getManyReference"]
            ];
            snapshot.current = queryKeys.reduce(function(prev, queryKey) {
              return prev.concat(queryClient.getQueriesData({ queryKey }));
            }, []);
            return [4, Promise.all(snapshot.current.map(function(_a13) {
              var queryKey = _a13[0];
              return queryClient.cancelQueries({ queryKey });
            }))];
          case 1:
            _b.sent();
            updateCache({
              resource: callTimeResource,
              ids: callTimeIds
            });
            setTimeout(function() {
              if (otherCallTimeOptions.onSuccess) {
                otherCallTimeOptions.onSuccess(callTimeIds, __assign20({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              } else if (mutationOptions.onSuccess) {
                mutationOptions.onSuccess(callTimeIds, __assign20({ resource: callTimeResource }, callTimeParams), { snapshot: snapshot.current });
              }
            }, 0);
            if (mode.current === "optimistic") {
              return [2, mutation.mutate(__assign20({ resource: callTimeResource }, callTimeParams), {
                onSettled: otherCallTimeOptions.onSettled,
                onError: otherCallTimeOptions.onError
              })];
            } else {
              addUndoableMutation(function(_a13) {
                var isUndo = _a13.isUndo;
                if (isUndo) {
                  snapshot.current.forEach(function(_a14) {
                    var key = _a14[0], value = _a14[1];
                    queryClient.setQueryData(key, value);
                  });
                } else {
                  mutation.mutate(__assign20({ resource: callTimeResource }, callTimeParams), {
                    onSettled: otherCallTimeOptions.onSettled,
                    onError: otherCallTimeOptions.onError
                  });
                }
              });
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  var mutationResult = (0, import_react57.useMemo)(function() {
    return __assign20({ isLoading: mutation.isPending }, mutation);
  }, [mutation]);
  return [useEvent(mutate), mutationResult];
};

// node_modules/ra-core/dist/esm/dataProvider/useInfiniteGetList.js
var import_react58 = __toESM(require_react());
var __assign21 = function() {
  __assign21 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign21.apply(this, arguments);
};
var __rest16 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var MAX_DATA_LENGTH_TO_CACHE2 = 100;
var useInfiniteGetList = function(resource, params, options) {
  var _a11, _b, _c, _d, _e;
  if (params === void 0) {
    params = {};
  }
  if (options === void 0) {
    options = {};
  }
  var _f = params.pagination, pagination = _f === void 0 ? { page: 1, perPage: 25 } : _f, _g = params.sort, sort = _g === void 0 ? { field: "id", order: "DESC" } : _g, _h = params.filter, filter = _h === void 0 ? {} : _h, meta = params.meta;
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var _j = options.onSuccess, onSuccess = _j === void 0 ? noop10 : _j, _k = options.onError, onError = _k === void 0 ? noop10 : _k, _l = options.onSettled, onSettled = _l === void 0 ? noop10 : _l, queryOptions2 = __rest16(options, ["onSuccess", "onError", "onSettled"]);
  var onSuccessEvent = useEvent(onSuccess);
  var onErrorEvent = useEvent(onError);
  var onSettledEvent = useEvent(onSettled);
  var result = useInfiniteQuery(__assign21(__assign21({ queryKey: [
    resource,
    "getInfiniteList",
    { pagination, sort, filter, meta }
  ], queryFn: function(queryParams) {
    var _a12 = queryParams.pageParam, pageParam = _a12 === void 0 ? pagination.page : _a12;
    return dataProvider.getList(resource, {
      pagination: {
        page: pageParam,
        perPage: pagination.perPage
      },
      sort,
      filter,
      meta,
      signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0
    }).then(function(_a13) {
      var data = _a13.data, pageInfo = _a13.pageInfo, total = _a13.total, meta2 = _a13.meta;
      return {
        data,
        total,
        pageParam,
        pageInfo,
        meta: meta2
      };
    });
  }, initialPageParam: pagination.page }, queryOptions2), { getNextPageParam: function(lastLoadedPage) {
    if (lastLoadedPage.pageInfo) {
      return lastLoadedPage.pageInfo.hasNextPage ? lastLoadedPage.pageParam + 1 : void 0;
    }
    var totalPages = Math.ceil((lastLoadedPage.total || 0) / pagination.perPage);
    return lastLoadedPage.pageParam < totalPages ? Number(lastLoadedPage.pageParam) + 1 : void 0;
  }, getPreviousPageParam: function(lastLoadedPage) {
    if (lastLoadedPage.pageInfo) {
      return lastLoadedPage.pageInfo.hasPreviousPage ? lastLoadedPage.pageParam - 1 : void 0;
    }
    return lastLoadedPage.pageParam === 1 ? void 0 : lastLoadedPage.pageParam - 1;
  } }));
  var metaValue = (0, import_react58.useRef)(meta);
  var resourceValue = (0, import_react58.useRef)(resource);
  (0, import_react58.useEffect)(function() {
    metaValue.current = meta;
  }, [meta]);
  (0, import_react58.useEffect)(function() {
    resourceValue.current = resource;
  }, [resource]);
  (0, import_react58.useEffect)(function() {
    if (result.data === void 0 || result.error != null || result.isFetching)
      return;
    var allPagesDataLength = result.data.pages.reduce(function(acc, page) {
      return acc + page.data.length;
    }, 0);
    if (allPagesDataLength <= MAX_DATA_LENGTH_TO_CACHE2) {
      result.data.pages.forEach(function(page) {
        page.data.forEach(function(record) {
          queryClient.setQueryData([
            resourceValue.current,
            "getOne",
            { id: String(record.id), meta: metaValue.current }
          ], function(oldRecord) {
            return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;
          });
        });
      });
    }
    onSuccessEvent(result.data);
  }, [
    onSuccessEvent,
    queryClient,
    result.data,
    result.error,
    result.isFetching
  ]);
  (0, import_react58.useEffect)(function() {
    if (result.error == null || result.isFetching)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error, result.isFetching]);
  (0, import_react58.useEffect)(function() {
    if (result.status === "pending" || result.isFetching)
      return;
    onSettledEvent(result.data, result.error);
  }, [
    onSettledEvent,
    result.data,
    result.error,
    result.status,
    result.isFetching
  ]);
  return result.data ? __assign21(__assign21({}, result), { data: result.data, total: (_c = (_b = (_a11 = result.data) === null || _a11 === void 0 ? void 0 : _a11.pages[0]) === null || _b === void 0 ? void 0 : _b.total) !== null && _c !== void 0 ? _c : void 0, meta: (_e = (_d = result.data) === null || _d === void 0 ? void 0 : _d.pages[0]) === null || _e === void 0 ? void 0 : _e.meta }) : result;
};
var noop10 = function() {
  return void 0;
};

// node_modules/ra-core/dist/esm/dataProvider/undo/TakeUndoableMutationContext.js
var import_react59 = __toESM(require_react());
var TakeUndoableMutationContext = (0, import_react59.createContext)(function() {
});

// node_modules/ra-core/dist/esm/dataProvider/undo/UndoableMutationsContextProvider.js
var React23 = __toESM(require_react());
var import_react60 = __toESM(require_react());
var __spreadArray12 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var UndoableMutationsContextProvider = function(_a11) {
  var children = _a11.children;
  var _b = (0, import_react60.useState)([]), mutations = _b[0], setMutations = _b[1];
  var addMutation = (0, import_react60.useCallback)(function(mutation) {
    setMutations(function(mutations2) {
      return __spreadArray12(__spreadArray12([], mutations2, true), [mutation], false);
    });
  }, []);
  var takeMutation = (0, import_react60.useCallback)(function() {
    if (mutations.length === 0)
      return;
    var mutation = mutations[0], rest = mutations.slice(1);
    setMutations(rest);
    return mutation;
  }, [mutations]);
  return React23.createElement(
    TakeUndoableMutationContext.Provider,
    { value: takeMutation },
    React23.createElement(AddUndoableMutationContext.Provider, { value: addMutation }, children)
  );
};

// node_modules/ra-core/dist/esm/dataProvider/undo/useTakeUndoableMutation.js
var import_react61 = __toESM(require_react());
var useTakeUndoableMutation = function() {
  return (0, import_react61.useContext)(TakeUndoableMutationContext);
};

// node_modules/ra-core/dist/esm/controller/button/useDeleteWithUndoController.js
var __assign22 = function() {
  __assign22 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign22.apply(this, arguments);
};
var __rest17 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useDeleteWithUndoController = function(props) {
  var record = props.record, _a11 = props.redirect, redirectTo = _a11 === void 0 ? "list" : _a11, onClick = props.onClick, _b = props.mutationOptions, mutationOptions = _b === void 0 ? {} : _b, successMessage = props.successMessage;
  var mutationMeta = mutationOptions.meta, otherMutationOptions = __rest17(mutationOptions, ["meta"]);
  var resource = useResourceContext(props);
  var notify = useNotify();
  var unselect = useUnselect(resource);
  var redirect = useRedirect();
  var translate = useTranslate();
  var _c = useDelete(resource, void 0, {
    onSuccess: function() {
      notify(successMessage !== null && successMessage !== void 0 ? successMessage : "resources.".concat(resource, ".notifications.deleted"), {
        type: "info",
        messageArgs: {
          smart_count: 1,
          _: translate("ra.notification.deleted", {
            smart_count: 1
          })
        },
        undoable: true
      });
      record && unselect([record.id]);
      redirect(redirectTo, resource);
    },
    onError: function(error) {
      notify(typeof error === "string" ? error : (error === null || error === void 0 ? void 0 : error.message) || "ra.notification.http_error", {
        type: "error",
        messageArgs: {
          _: typeof error === "string" ? error : (error === null || error === void 0 ? void 0 : error.message) ? error.message : void 0
        }
      });
    }
  }), deleteOne = _c[0], isPending = _c[1].isPending;
  var handleDelete = (0, import_react62.useCallback)(function(event) {
    event.stopPropagation();
    if (!record) {
      throw new Error("The record cannot be deleted because no record has been passed");
    }
    deleteOne(resource, {
      id: record.id,
      previousData: record,
      meta: mutationMeta
    }, __assign22({ mutationMode: "undoable" }, otherMutationOptions));
    if (typeof onClick === "function") {
      onClick(event);
    }
  }, [
    deleteOne,
    mutationMeta,
    otherMutationOptions,
    onClick,
    record,
    resource
  ]);
  return { isPending, isLoading: isPending, handleDelete };
};
var useDeleteWithUndoController_default = useDeleteWithUndoController;

// node_modules/ra-core/dist/esm/controller/button/useDeleteWithConfirmController.js
var import_react63 = __toESM(require_react());
var __assign23 = function() {
  __assign23 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign23.apply(this, arguments);
};
var __rest18 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useDeleteWithConfirmController = function(props) {
  var record = props.record, _a11 = props.redirect, redirectTo = _a11 === void 0 ? "list" : _a11, mutationMode = props.mutationMode, onClick = props.onClick, _b = props.mutationOptions, mutationOptions = _b === void 0 ? {} : _b, successMessage = props.successMessage;
  var mutationMeta = mutationOptions.meta, otherMutationOptions = __rest18(mutationOptions, ["meta"]);
  var resource = useResourceContext(props);
  var _c = (0, import_react63.useState)(false), open = _c[0], setOpen = _c[1];
  var notify = useNotify();
  var unselect = useUnselect(resource);
  var redirect = useRedirect();
  var translate = useTranslate();
  var _d = useDelete(resource, void 0, {
    onSuccess: function() {
      setOpen(false);
      notify(successMessage !== null && successMessage !== void 0 ? successMessage : "resources.".concat(resource, ".notifications.deleted"), {
        type: "info",
        messageArgs: {
          smart_count: 1,
          _: translate("ra.notification.deleted", {
            smart_count: 1
          })
        },
        undoable: mutationMode === "undoable"
      });
      record && unselect([record.id]);
      redirect(redirectTo, resource);
    },
    onError: function(error) {
      setOpen(false);
      notify(typeof error === "string" ? error : (error === null || error === void 0 ? void 0 : error.message) || "ra.notification.http_error", {
        type: "error",
        messageArgs: {
          _: typeof error === "string" ? error : (error === null || error === void 0 ? void 0 : error.message) ? error.message : void 0
        }
      });
    }
  }), deleteOne = _d[0], isPending = _d[1].isPending;
  var handleDialogOpen = function(e) {
    setOpen(true);
    e.stopPropagation();
  };
  var handleDialogClose = function(e) {
    setOpen(false);
    e.stopPropagation();
  };
  var handleDelete = (0, import_react63.useCallback)(function(event) {
    event.stopPropagation();
    if (!record) {
      throw new Error("The record cannot be deleted because no record has been passed");
    }
    deleteOne(resource, {
      id: record.id,
      previousData: record,
      meta: mutationMeta
    }, __assign23({ mutationMode }, otherMutationOptions));
    if (typeof onClick === "function") {
      onClick(event);
    }
  }, [
    deleteOne,
    mutationMeta,
    mutationMode,
    otherMutationOptions,
    onClick,
    record,
    resource
  ]);
  return {
    open,
    isPending,
    isLoading: isPending,
    handleDialogOpen,
    handleDialogClose,
    handleDelete
  };
};
var useDeleteWithConfirmController_default = useDeleteWithConfirmController;

// node_modules/ra-core/dist/esm/controller/create/CreateBase.js
var React26 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/create/useCreateController.js
var import_react69 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/saveContext/SaveContext.js
var import_react64 = __toESM(require_react());
var SaveContext = (0, import_react64.createContext)({});

// node_modules/ra-core/dist/esm/controller/saveContext/SaveContextProvider.js
var React24 = __toESM(require_react());
var SaveContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React24.createElement(SaveContext.Provider, { value }, children);
};

// node_modules/ra-core/dist/esm/controller/saveContext/usePickSaveContext.js
var import_react65 = __toESM(require_react());
var import_pick = __toESM(require_pick());
var usePickSaveContext = function(context) {
  var value = (0, import_react65.useMemo)(
    function() {
      return (0, import_pick.default)(context, [
        "save",
        "saving",
        "mutationMode",
        "registerMutationMiddleware",
        "unregisterMutationMiddleware"
      ]);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      context.save,
      context.saving,
      context.mutationMode,
      context.registerMutationMiddleware,
      context.unregisterMutationMiddleware
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  );
  return value;
};

// node_modules/ra-core/dist/esm/controller/saveContext/useSaveContext.js
var import_react66 = __toESM(require_react());
var useSaveContext = function(_props) {
  return (0, import_react66.useContext)(SaveContext);
};

// node_modules/ra-core/dist/esm/controller/saveContext/useMutationMiddlewares.js
var import_react67 = __toESM(require_react());
var __spreadArray13 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useMutationMiddlewares = function() {
  var callbacks = (0, import_react67.useRef)([]);
  var registerMutationMiddleware = (0, import_react67.useCallback)(function(callback) {
    callbacks.current.push(callback);
  }, []);
  var unregisterMutationMiddleware = (0, import_react67.useCallback)(function(callback) {
    callbacks.current = callbacks.current.filter(function(cb) {
      return cb !== callback;
    });
  }, []);
  var getMutateWithMiddlewares = (0, import_react67.useCallback)(function(fn) {
    var currentCallbacks = __spreadArray13([], callbacks.current, true);
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var index = currentCallbacks.length - 1;
      var next = function() {
        var newArgs = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          newArgs[_i2] = arguments[_i2];
        }
        index--;
        if (index >= 0) {
          return currentCallbacks[index].apply(currentCallbacks, __spreadArray13(__spreadArray13([], newArgs, false), [next], false));
        } else {
          return fn.apply(void 0, newArgs);
        }
      };
      if (currentCallbacks.length > 0) {
        return currentCallbacks[index].apply(currentCallbacks, __spreadArray13(__spreadArray13([], args, false), [next], false));
      }
      return fn.apply(void 0, args);
    };
  }, []);
  var functions = (0, import_react67.useMemo)(function() {
    return {
      registerMutationMiddleware,
      getMutateWithMiddlewares,
      unregisterMutationMiddleware
    };
  }, [
    registerMutationMiddleware,
    getMutateWithMiddlewares,
    unregisterMutationMiddleware
  ]);
  return functions;
};

// node_modules/ra-core/dist/esm/controller/saveContext/useRegisterMutationMiddleware.js
var import_react68 = __toESM(require_react());
var useRegisterMutationMiddleware = function(callback) {
  var _a11 = useSaveContext(), registerMutationMiddleware = _a11.registerMutationMiddleware, unregisterMutationMiddleware = _a11.unregisterMutationMiddleware;
  (0, import_react68.useEffect)(function() {
    if (!registerMutationMiddleware || !unregisterMutationMiddleware) {
      return;
    }
    registerMutationMiddleware(callback);
    return function() {
      unregisterMutationMiddleware(callback);
    };
  }, [callback, registerMutationMiddleware, unregisterMutationMiddleware]);
};

// node_modules/ra-core/dist/esm/controller/create/useCreateController.js
var __assign24 = function() {
  __assign24 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign24.apply(this, arguments);
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator9 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest19 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useCreateController = function(props) {
  if (props === void 0) {
    props = {};
  }
  var disableAuthentication = props.disableAuthentication, record = props.record, redirectTo = props.redirect, transform2 = props.transform, _a11 = props.mutationOptions, mutationOptions = _a11 === void 0 ? {} : _a11;
  var resource = useResourceContext(props);
  if (!resource) {
    throw new Error("useCreateController requires a non-empty resource prop or context");
  }
  var isPendingAuthenticated = useAuthenticated({
    enabled: !disableAuthentication
  }).isPending;
  var isPendingCanAccess = useRequireAccess({
    action: "create",
    resource,
    // If disableAuthentication is true then isPendingAuthenticated will always be true so this hook is disabled
    enabled: !isPendingAuthenticated
  }).isPending;
  var _b = useResourceDefinition(props), hasEdit = _b.hasEdit, hasShow = _b.hasShow;
  var finalRedirectTo = redirectTo !== null && redirectTo !== void 0 ? redirectTo : getDefaultRedirectRoute(hasShow, hasEdit);
  var translate = useTranslate();
  var notify = useNotify();
  var redirect = useRedirect();
  var onSuccess = mutationOptions.onSuccess, onError = mutationOptions.onError, meta = mutationOptions.meta, otherMutationOptions = __rest19(mutationOptions, ["onSuccess", "onError", "meta"]);
  var _c = useMutationMiddlewares(), registerMutationMiddleware = _c.registerMutationMiddleware, getMutateWithMiddlewares = _c.getMutateWithMiddlewares, unregisterMutationMiddleware = _c.unregisterMutationMiddleware;
  var _d = useCreate(resource, void 0, __assign24(__assign24({ onSuccess: function(data, variables, context) {
    return __awaiter9(void 0, void 0, void 0, function() {
      return __generator9(this, function(_a12) {
        if (onSuccess) {
          return [2, onSuccess(data, variables, context)];
        }
        notify("resources.".concat(resource, ".notifications.created"), {
          type: "info",
          messageArgs: {
            smart_count: 1,
            _: translate("ra.notification.created", {
              smart_count: 1
            })
          }
        });
        redirect(finalRedirectTo, resource, data.id, data);
        return [
          2
          /*return*/
        ];
      });
    });
  }, onError: function(error, variables, context) {
    var _a12;
    if (onError) {
      return onError(error, variables, context);
    }
    var validationErrors = (_a12 = error === null || error === void 0 ? void 0 : error.body) === null || _a12 === void 0 ? void 0 : _a12.errors;
    var hasValidationErrors = !!validationErrors && Object.keys(validationErrors).length > 0;
    if (!hasValidationErrors) {
      notify(typeof error === "string" ? error : error.message || "ra.notification.http_error", {
        type: "error",
        messageArgs: {
          _: typeof error === "string" ? error : error instanceof Error || typeof error === "object" && error !== null && error.hasOwnProperty("message") ? (
            // @ts-ignore
            error.message
          ) : void 0
        }
      });
    }
  } }, otherMutationOptions), { returnPromise: true, getMutateWithMiddlewares })), create = _d[0], saving = _d[1].isPending;
  var save = (0, import_react69.useCallback)(function(data, _a12) {
    if (_a12 === void 0) {
      _a12 = {};
    }
    var transformFromSave = _a12.transform, metaFromSave = _a12.meta, callTimeOptions = __rest19(_a12, ["transform", "meta"]);
    return Promise.resolve(transformFromSave ? transformFromSave(data) : transform2 ? transform2(data) : data).then(function(data2) {
      return __awaiter9(void 0, void 0, void 0, function() {
        var error_1;
        var _a13;
        return __generator9(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              _b2.trys.push([0, 2, , 3]);
              return [4, create(resource, { data: data2, meta: metaFromSave !== null && metaFromSave !== void 0 ? metaFromSave : meta }, callTimeOptions)];
            case 1:
              _b2.sent();
              return [3, 3];
            case 2:
              error_1 = _b2.sent();
              if ((error_1 instanceof HttpError_default || typeof error_1 === "object" && error_1 !== null && error_1.hasOwnProperty("body")) && ((_a13 = error_1.body) === null || _a13 === void 0 ? void 0 : _a13.errors) != null) {
                return [2, error_1.body.errors];
              }
              return [3, 3];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    });
  }, [create, meta, resource, transform2]);
  var getResourceLabel = useGetResourceLabel();
  var defaultTitle = translate("ra.page.create", {
    name: getResourceLabel(resource, 1)
  });
  return {
    isFetching: false,
    isLoading: false,
    isPending: disableAuthentication ? false : isPendingCanAccess,
    saving,
    defaultTitle,
    save,
    record,
    resource,
    redirect: finalRedirectTo,
    registerMutationMiddleware,
    unregisterMutationMiddleware
  };
};
var getDefaultRedirectRoute = function(hasShow, hasEdit) {
  if (hasEdit) {
    return "edit";
  }
  if (hasShow) {
    return "show";
  }
  return "list";
};

// node_modules/ra-core/dist/esm/controller/create/CreateContextProvider.js
var React25 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/create/CreateContext.js
var import_react70 = __toESM(require_react());
var CreateContext = (0, import_react70.createContext)(null);
CreateContext.displayName = "CreateContext";

// node_modules/ra-core/dist/esm/controller/create/CreateContextProvider.js
var __assign25 = function() {
  __assign25 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign25.apply(this, arguments);
};
var CreateContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React25.createElement(
    CreateContext.Provider,
    { value },
    React25.createElement(
      SaveContextProvider,
      { value: __assign25(__assign25({}, usePickSaveContext(value)), { mutationMode: "pessimistic" }) },
      React25.createElement(RecordContextProvider, { value: value && value.record }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/create/CreateBase.js
var __rest20 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CreateBase = function(_a11) {
  var children = _a11.children, _b = _a11.loading, loading = _b === void 0 ? null : _b, props = __rest20(_a11, ["children", "loading"]);
  var controllerProps = useCreateController(props);
  var isAuthPending = useIsAuthPending({
    resource: controllerProps.resource,
    action: "create"
  });
  if (isAuthPending && !props.disableAuthentication) {
    return loading;
  }
  return (
    // We pass props.resource here as we don't need to create a new ResourceContext if the props is not provided
    React26.createElement(
      OptionalResourceContextProvider,
      { value: props.resource },
      React26.createElement(CreateContextProvider, { value: controllerProps }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/create/CreateController.js
var __rest21 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CreateController = function(_a11) {
  var children = _a11.children, props = __rest21(_a11, ["children"]);
  var controllerProps = useCreateController(props);
  return children(controllerProps);
};

// node_modules/ra-core/dist/esm/controller/create/useCreateContext.js
var import_react71 = __toESM(require_react());
var useCreateContext = function() {
  var context = (0, import_react71.useContext)(CreateContext);
  if (!context) {
    throw new Error("useCreateContext must be used inside a CreateContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/edit/EditBase.js
var React31 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/edit/useEditController.js
var import_react72 = __toESM(require_react());
var __assign26 = function() {
  __assign26 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign26.apply(this, arguments);
};
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator10 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest22 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useEditController = function(props) {
  if (props === void 0) {
    props = {};
  }
  var _a11 = props.disableAuthentication, disableAuthentication = _a11 === void 0 ? false : _a11, propsId = props.id, _b = props.mutationMode, mutationMode = _b === void 0 ? "undoable" : _b, _c = props.mutationOptions, mutationOptions = _c === void 0 ? {} : _c, _d = props.queryOptions, queryOptions2 = _d === void 0 ? {} : _d, _e = props.redirect, redirectTo = _e === void 0 ? DefaultRedirect : _e, transform2 = props.transform;
  var resource = useResourceContext(props);
  if (!resource) {
    throw new Error("useEditController requires a non-empty resource prop or context");
  }
  var isPendingAuthenticated = useAuthenticated({
    enabled: !disableAuthentication
  }).isPending;
  var isPendingCanAccess = useRequireAccess({
    action: "edit",
    resource,
    // If disableAuthentication is true then isPendingAuthenticated will always be true so this hook is disabled
    enabled: !isPendingAuthenticated
  }).isPending;
  var getRecordRepresentation = useGetRecordRepresentation(resource);
  var translate = useTranslate();
  var notify = useNotify();
  var redirect = useRedirect();
  var refresh = useRefresh();
  var routeId = useParams().id;
  if (!routeId && !propsId) {
    throw new Error("useEditController requires an id prop or a route with an /:id? parameter.");
  }
  var id = propsId !== null && propsId !== void 0 ? propsId : routeId;
  var queryMeta = queryOptions2.meta, otherQueryOptions = __rest22(queryOptions2, ["meta"]);
  var mutationMeta = mutationOptions.meta, onSuccess = mutationOptions.onSuccess, onError = mutationOptions.onError, otherMutationOptions = __rest22(mutationOptions, ["meta", "onSuccess", "onError"]);
  var _f = useMutationMiddlewares(), registerMutationMiddleware = _f.registerMutationMiddleware, getMutateWithMiddlewares = _f.getMutateWithMiddlewares, unregisterMutationMiddleware = _f.unregisterMutationMiddleware;
  var _g = useGetOne(resource, { id, meta: queryMeta }, __assign26({ enabled: !isPendingAuthenticated && !isPendingCanAccess || disableAuthentication, onError: function() {
    notify("ra.notification.item_doesnt_exist", {
      type: "error"
    });
    redirect("list", resource);
    refresh();
  }, refetchOnReconnect: false, refetchOnWindowFocus: false, retry: false }, otherQueryOptions)), record = _g.data, error = _g.error, isLoading = _g.isLoading, isFetching = _g.isFetching, isPending = _g.isPending, refetch2 = _g.refetch;
  if (record && record.id && record.id != id) {
    throw new Error("useEditController: Fetched record's id attribute (".concat(record.id, ") must match the requested 'id' (").concat(id, ")"));
  }
  var getResourceLabel = useGetResourceLabel();
  var recordRepresentation = getRecordRepresentation(record);
  var defaultTitle = translate("ra.page.edit", {
    name: getResourceLabel(resource, 1),
    id,
    record,
    recordRepresentation: typeof recordRepresentation === "string" ? recordRepresentation : ""
  });
  var recordCached = { id, previousData: record };
  var _h = useUpdate(resource, recordCached, __assign26(__assign26({ onSuccess: function(data, variables, context) {
    return __awaiter10(void 0, void 0, void 0, function() {
      return __generator10(this, function(_a12) {
        if (onSuccess) {
          return [2, onSuccess(data, variables, context)];
        }
        notify("resources.".concat(resource, ".notifications.updated"), {
          type: "info",
          messageArgs: {
            smart_count: 1,
            _: translate("ra.notification.updated", {
              smart_count: 1
            })
          },
          undoable: mutationMode === "undoable"
        });
        redirect(redirectTo, resource, data.id, data);
        return [
          2
          /*return*/
        ];
      });
    });
  }, onError: function(error2, variables, context) {
    var _a12;
    if (onError) {
      return onError(error2, variables, context);
    }
    var validationErrors = (_a12 = error2 === null || error2 === void 0 ? void 0 : error2.body) === null || _a12 === void 0 ? void 0 : _a12.errors;
    var hasValidationErrors = !!validationErrors && Object.keys(validationErrors).length > 0;
    if (!hasValidationErrors || mutationMode !== "pessimistic") {
      notify(typeof error2 === "string" ? error2 : error2.message || "ra.notification.http_error", {
        type: "error",
        messageArgs: {
          _: typeof error2 === "string" ? error2 : error2 instanceof Error || typeof error2 === "object" && error2 !== null && error2.hasOwnProperty("message") ? (
            // @ts-ignore
            error2.message
          ) : void 0
        }
      });
    }
  } }, otherMutationOptions), { mutationMode, returnPromise: mutationMode === "pessimistic", getMutateWithMiddlewares })), update = _h[0], saving = _h[1].isPending;
  var save = (0, import_react72.useCallback)(function(data, _a12) {
    var _b2 = _a12 === void 0 ? {} : _a12, onSuccessFromSave = _b2.onSuccess, onErrorFromSave = _b2.onError, transformFromSave = _b2.transform, metaFromSave = _b2.meta;
    return Promise.resolve(transformFromSave ? transformFromSave(data, {
      previousData: recordCached.previousData
    }) : transform2 ? transform2(data, {
      previousData: recordCached.previousData
    }) : data).then(function(data2) {
      return __awaiter10(void 0, void 0, void 0, function() {
        var error_1;
        var _a13;
        return __generator10(this, function(_b3) {
          switch (_b3.label) {
            case 0:
              _b3.trys.push([0, 2, , 3]);
              return [4, update(resource, {
                id,
                data: data2,
                meta: metaFromSave !== null && metaFromSave !== void 0 ? metaFromSave : mutationMeta
              }, {
                onError: onErrorFromSave,
                onSuccess: onSuccessFromSave
              })];
            case 1:
              _b3.sent();
              return [3, 3];
            case 2:
              error_1 = _b3.sent();
              if (((_a13 = error_1.body) === null || _a13 === void 0 ? void 0 : _a13.errors) != null) {
                return [2, error_1.body.errors];
              }
              return [3, 3];
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    });
  }, [
    id,
    mutationMeta,
    resource,
    transform2,
    update,
    recordCached.previousData
  ]);
  return {
    defaultTitle,
    error,
    isFetching,
    isLoading,
    isPending,
    mutationMode,
    record,
    redirect: redirectTo,
    refetch: refetch2,
    registerMutationMiddleware,
    resource,
    save,
    saving,
    unregisterMutationMiddleware
  };
};
var DefaultRedirect = "list";

// node_modules/ra-core/dist/esm/controller/edit/EditContextProvider.js
var React30 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/record/WithRecord.js
var React27 = __toESM(require_react());
var WithRecord = function(_a11) {
  var render = _a11.render;
  var record = useRecordContext();
  return record ? React27.createElement(React27.Fragment, null, render(record)) : null;
};

// node_modules/ra-core/dist/esm/controller/record/OptionalRecordContextProvider.js
var React28 = __toESM(require_react());
var OptionalRecordContextProvider = function(_a11) {
  var value = _a11.value, children = _a11.children;
  return value ? React28.createElement(RecordContextProvider, { value }, children) : children;
};

// node_modules/ra-core/dist/esm/controller/record/RecordRepresentation.js
var React29 = __toESM(require_react());
var RecordRepresentation = function(props) {
  var record = useRecordContext(props);
  var resource = useResourceContext(props);
  var getRecordRepresentation = useGetRecordRepresentation(resource);
  return React29.createElement(React29.Fragment, null, getRecordRepresentation(record));
};

// node_modules/ra-core/dist/esm/controller/edit/EditContext.js
var import_react73 = __toESM(require_react());
var EditContext = (0, import_react73.createContext)(null);
EditContext.displayName = "EditContext";

// node_modules/ra-core/dist/esm/controller/edit/EditContextProvider.js
var EditContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React30.createElement(
    EditContext.Provider,
    { value },
    React30.createElement(
      SaveContextProvider,
      { value: usePickSaveContext(value) },
      React30.createElement(RecordContextProvider, { value: value && value.record }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/edit/EditBase.js
var __rest23 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var EditBase = function(_a11) {
  var children = _a11.children, _b = _a11.loading, loading = _b === void 0 ? null : _b, props = __rest23(_a11, ["children", "loading"]);
  var controllerProps = useEditController(props);
  var isAuthPending = useIsAuthPending({
    resource: controllerProps.resource,
    action: "edit"
  });
  if (isAuthPending && !props.disableAuthentication) {
    return loading;
  }
  return (
    // We pass props.resource here as we don't need to create a new ResourceContext if the props is not provided
    React31.createElement(
      OptionalResourceContextProvider,
      { value: props.resource },
      React31.createElement(EditContextProvider, { value: controllerProps }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/edit/EditController.js
var __rest24 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var EditController = function(_a11) {
  var children = _a11.children, props = __rest24(_a11, ["children"]);
  var controllerProps = useEditController(props);
  return children(controllerProps);
};

// node_modules/ra-core/dist/esm/controller/edit/useEditContext.js
var import_react74 = __toESM(require_react());
var useEditContext = function() {
  var context = (0, import_react74.useContext)(EditContext);
  if (!context) {
    throw new Error("useEditContext must be used inside an EditContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/field/ReferenceFieldBase.js
var React32 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/field/ReferenceFieldContext.js
var import_react75 = __toESM(require_react());
var ReferenceFieldContext = (0, import_react75.createContext)(null);
var ReferenceFieldContextProvider = ReferenceFieldContext.Provider;
var useReferenceFieldContext = function() {
  var context = (0, import_react75.useContext)(ReferenceFieldContext);
  if (!context) {
    throw new Error("useReferenceFieldContext must be used inside a ReferenceFieldContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/field/useReferenceFieldController.js
var import_react76 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/useReference.js
var __rest25 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useReference = function(_a11) {
  var reference = _a11.reference, id = _a11.id, _b = _a11.options, options = _b === void 0 ? {} : _b;
  var meta = options.meta, otherQueryOptions = __rest25(options, ["meta"]);
  var _c = useGetManyAggregate(reference, { ids: [id], meta }, otherQueryOptions), data = _c.data, error = _c.error, isLoading = _c.isLoading, isFetching = _c.isFetching, isPending = _c.isPending, refetch2 = _c.refetch;
  return {
    referenceRecord: error ? void 0 : data ? data[0] : void 0,
    refetch: refetch2,
    error,
    isLoading,
    isFetching,
    isPending
  };
};

// node_modules/ra-core/dist/esm/controller/field/useReferenceFieldController.js
var __assign27 = function() {
  __assign27 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign27.apply(this, arguments);
};
var useReferenceFieldController = function(options) {
  var link = options.link, reference = options.reference, queryOptions2 = options.queryOptions;
  if (!reference) {
    throw new Error('useReferenceFieldController: missing reference prop. You must provide a reference, e.g. reference="posts".');
  }
  var id = useFieldValue(options);
  var referenceRecordQuery = useReference({
    reference,
    id,
    options: __assign27(__assign27({}, queryOptions2), { enabled: ((queryOptions2 === null || queryOptions2 === void 0 ? void 0 : queryOptions2.enabled) == null || (queryOptions2 === null || queryOptions2 === void 0 ? void 0 : queryOptions2.enabled) === true) && id != null })
  });
  var path = useGetPathForRecord({
    record: referenceRecordQuery.referenceRecord,
    resource: reference,
    link
  });
  var result = (0, import_react76.useMemo)(function() {
    return __assign27(__assign27({}, referenceRecordQuery), { link: path });
  }, [path, referenceRecordQuery]);
  return result;
};

// node_modules/ra-core/dist/esm/controller/field/ReferenceFieldBase.js
var ReferenceFieldBase = function(props) {
  var children = props.children;
  var controllerProps = useReferenceFieldController(props);
  return React32.createElement(
    ResourceContextProvider,
    { value: props.reference },
    React32.createElement(
      ReferenceFieldContextProvider,
      { value: controllerProps },
      React32.createElement(RecordContextProvider, { value: controllerProps.referenceRecord }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/field/useReferenceArrayFieldController.js
var import_get5 = __toESM(require_get());

// node_modules/ra-core/dist/esm/controller/list/InfiniteListBase.js
var React34 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/list/useInfiniteListController.js
var import_react81 = __toESM(require_react());

// node_modules/ra-core/dist/esm/export/defaultExporter.js
var import_dist = __toESM(require_dist());

// node_modules/ra-core/dist/esm/export/downloadCSV.js
var downloadCSV = function(csv, filename) {
  if (filename === void 0) {
    filename = "export";
  }
  var fakeLink = document.createElement("a");
  fakeLink.style.display = "none";
  document.body.appendChild(fakeLink);
  var blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
  if (window.navigator && window.navigator.msSaveOrOpenBlob) {
    window.navigator.msSaveOrOpenBlob(blob, "".concat(filename, ".csv"));
  } else {
    fakeLink.setAttribute("href", URL.createObjectURL(blob));
    fakeLink.setAttribute("download", "".concat(filename, ".csv"));
    fakeLink.click();
  }
};

// node_modules/ra-core/dist/esm/export/defaultExporter.js
var defaultExporter = function(data, _, __, resource) {
  return (0, import_dist.default)(data, function(err, csv) {
    return downloadCSV(csv, resource);
  });
};

// node_modules/ra-core/dist/esm/export/ExporterContext.js
var import_react77 = __toESM(require_react());
var ExporterContext = (0, import_react77.createContext)(defaultExporter);
ExporterContext.displayName = "ExporterContext";

// node_modules/ra-core/dist/esm/export/getRelatedIds.js
var getRelatedIds = function(records, field) {
  return Array.from(new Set(records.filter(function(record) {
    return record[field] != null;
  }).map(function(record) {
    return record[field];
  }).reduce(function(ids, value) {
    return ids.concat(value);
  }, [])));
};

// node_modules/ra-core/dist/esm/export/fetchRelatedRecords.js
var fetchRelatedRecords = function(dataProvider) {
  return function(data, field, resource) {
    return dataProvider.getMany(resource, { ids: getRelatedIds(data, field) }).then(function(_a11) {
      var data2 = _a11.data;
      return data2.reduce(function(acc, post) {
        acc[post.id] = post;
        return acc;
      }, {});
    });
  };
};

// node_modules/ra-core/dist/esm/controller/list/useRecordSelection.js
var import_react78 = __toESM(require_react());
var __spreadArray14 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useRecordSelection = function(args) {
  var _a11 = args.resource, resource = _a11 === void 0 ? "" : _a11, _b = args.disableSyncWithStore, disableSyncWithStore = _b === void 0 ? false : _b;
  var storeKey = "".concat(resource, ".selectedIds");
  var _c = (0, import_react78.useState)(defaultSelection), localIds = _c[0], setLocalIds = _c[1];
  var _d = useStore(storeKey, defaultSelection), storeIds = _d[0], setStoreIds = _d[1];
  var resetStore = useRemoveFromStore(storeKey);
  var ids = disableSyncWithStore ? localIds : storeIds;
  var setIds = disableSyncWithStore ? setLocalIds : setStoreIds;
  var reset = (0, import_react78.useCallback)(function() {
    if (disableSyncWithStore) {
      setLocalIds(defaultSelection);
    } else {
      resetStore();
    }
  }, [disableSyncWithStore, resetStore]);
  var selectionModifiers = (0, import_react78.useMemo)(function() {
    return {
      select: function(idsToAdd) {
        if (!idsToAdd)
          return;
        setIds(__spreadArray14([], idsToAdd, true));
      },
      unselect: function(idsToRemove) {
        if (!idsToRemove || idsToRemove.length === 0)
          return;
        setIds(function(ids2) {
          if (!Array.isArray(ids2))
            return [];
          return ids2.filter(function(id) {
            return !idsToRemove.includes(id);
          });
        });
      },
      toggle: function(id) {
        if (typeof id === "undefined")
          return;
        setIds(function(ids2) {
          if (!Array.isArray(ids2))
            return __spreadArray14([], ids2, true);
          var index = ids2.indexOf(id);
          return index > -1 ? __spreadArray14(__spreadArray14([], ids2.slice(0, index), true), ids2.slice(index + 1), true) : __spreadArray14(__spreadArray14([], ids2, true), [id], false);
        });
      },
      clearSelection: function() {
        reset();
      }
    };
  }, [setIds, reset]);
  return [ids, selectionModifiers];
};
var defaultSelection = [];

// node_modules/ra-core/dist/esm/controller/list/useListParams.js
var import_react80 = __toESM(require_react());
var import_query_string2 = __toESM(require_query_string());
var import_debounce3 = __toESM(require_debounce());

// node_modules/ra-core/dist/esm/util/hooks.js
var import_react79 = __toESM(require_react());
var import_isEqual2 = __toESM(require_isEqual());
function useSafeSetState(initialState2) {
  var _a11 = (0, import_react79.useState)(initialState2), state = _a11[0], setState = _a11[1];
  var mountedRef = (0, import_react79.useRef)(false);
  (0, import_react79.useEffect)(function() {
    mountedRef.current = true;
    return function() {
      mountedRef.current = false;
    };
  }, []);
  var safeSetState = (0, import_react79.useCallback)(function(args) {
    if (mountedRef.current) {
      return setState(args);
    }
  }, [mountedRef, setState]);
  return [state, safeSetState];
}
function usePrevious(value) {
  var ref = (0, import_react79.useRef)();
  (0, import_react79.useEffect)(function() {
    ref.current = value;
  });
  return ref.current;
}
function useDeepCompareEffect(callback, inputs) {
  var cleanupRef = (0, import_react79.useRef)();
  (0, import_react79.useEffect)(function() {
    if (!(0, import_isEqual2.default)(previousInputs, inputs)) {
      cleanupRef.current = callback();
    }
    return cleanupRef.current;
  });
  var previousInputs = usePrevious(inputs);
}
function useTimeout(ms, key) {
  if (ms === void 0) {
    ms = 0;
  }
  if (key === void 0) {
    key = "";
  }
  var _a11 = (0, import_react79.useState)(false), ready = _a11[0], setReady = _a11[1];
  (0, import_react79.useEffect)(function() {
    setReady(false);
    var timer2 = setTimeout(function() {
      setReady(true);
    }, ms);
    return function() {
      clearTimeout(timer2);
    };
  }, [key, ms, setReady]);
  return ready;
}
function useIsMounted() {
  var isMounted = (0, import_react79.useRef)(true);
  (0, import_react79.useEffect)(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}

// node_modules/ra-core/dist/esm/controller/list/useListParams.js
var __assign28 = function() {
  __assign28 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign28.apply(this, arguments);
};
var __spreadArray15 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useListParams = function(_a11) {
  var _b = _a11.debounce, debounce5 = _b === void 0 ? 500 : _b, _c = _a11.disableSyncWithLocation, disableSyncWithLocation = _c === void 0 ? false : _c, filterDefaultValues = _a11.filterDefaultValues, _d = _a11.perPage, perPage = _d === void 0 ? 10 : _d, resource = _a11.resource, _e = _a11.sort, sort = _e === void 0 ? defaultSort2 : _e, _f = _a11.storeKey, storeKey = _f === void 0 ? disableSyncWithLocation ? false : "".concat(resource, ".listParams") : _f;
  var location = useLocation();
  var navigate = useNavigate();
  var _g = (0, import_react80.useState)(defaultParams), localParams = _g[0], setLocalParams = _g[1];
  var _h = useStore(storeKey || "".concat(resource, ".listParams"), defaultParams), params = _h[0], setParams = _h[1];
  var tempParams = (0, import_react80.useRef)();
  var isMounted = useIsMounted();
  var requestSignature = [
    location.search,
    resource,
    storeKey,
    JSON.stringify(!storeKey ? localParams : params),
    JSON.stringify(filterDefaultValues),
    JSON.stringify(sort),
    perPage,
    disableSyncWithLocation
  ];
  var queryFromLocation = disableSyncWithLocation ? {} : parseQueryFromLocation(location);
  var query = (0, import_react80.useMemo)(
    function() {
      return getQuery({
        queryFromLocation,
        params: !storeKey ? localParams : params,
        filterDefaultValues,
        sort,
        perPage
      });
    },
    requestSignature
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  (0, import_react80.useEffect)(function() {
    if (Object.keys(queryFromLocation).length > 0) {
      setParams(query);
    }
  }, [location.search]);
  var changeParams = (0, import_react80.useCallback)(function(action) {
    if (!isMounted.current)
      return;
    if (!tempParams.current) {
      tempParams.current = queryReducer_default(query, action);
      setTimeout(function() {
        if (!tempParams.current) {
          return;
        }
        if (disableSyncWithLocation && !storeKey) {
          setLocalParams(tempParams.current);
        } else if (disableSyncWithLocation && !!storeKey) {
          setParams(tempParams.current);
        } else {
          navigate({
            search: "?".concat((0, import_query_string2.stringify)(__assign28(__assign28({}, tempParams.current), { filter: JSON.stringify(tempParams.current.filter), displayedFilters: JSON.stringify(tempParams.current.displayedFilters) })))
          }, {
            state: {
              _scrollToTop: action.type === SET_PAGE
            }
          });
        }
        tempParams.current = void 0;
      }, 0);
    } else {
      tempParams.current = queryReducer_default(tempParams.current, action);
    }
  }, __spreadArray15(__spreadArray15([], requestSignature, true), [navigate], false));
  var setSort = (0, import_react80.useCallback)(function(sort2) {
    return changeParams({
      type: SET_SORT,
      payload: sort2
    });
  }, [changeParams]);
  var setPage = (0, import_react80.useCallback)(function(newPage) {
    return changeParams({ type: SET_PAGE, payload: newPage });
  }, [changeParams]);
  var setPerPage = (0, import_react80.useCallback)(function(newPerPage) {
    return changeParams({ type: SET_PER_PAGE, payload: newPerPage });
  }, [changeParams]);
  var filterValues = query.filter || emptyObject;
  var displayedFilterValues = query.displayedFilters || emptyObject;
  var debouncedSetFilters = (0, import_debounce3.default)(function(filter, displayedFilters) {
    changeParams({
      type: SET_FILTER,
      payload: {
        filter: removeEmpty_default(filter),
        displayedFilters
      }
    });
  }, debounce5);
  var setFilters = (0, import_react80.useCallback)(
    function(filter, displayedFilters, debounce6) {
      if (displayedFilters === void 0) {
        displayedFilters = void 0;
      }
      if (debounce6 === void 0) {
        debounce6 = false;
      }
      return debounce6 ? debouncedSetFilters(filter, displayedFilters) : changeParams({
        type: SET_FILTER,
        payload: {
          filter: removeEmpty_default(filter),
          displayedFilters
        }
      });
    },
    [changeParams]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  var hideFilter = (0, import_react80.useCallback)(function(filterName) {
    changeParams({
      type: HIDE_FILTER,
      payload: filterName
    });
  }, [changeParams]);
  var showFilter = (0, import_react80.useCallback)(function(filterName, defaultValue) {
    changeParams({
      type: SHOW_FILTER,
      payload: {
        filterName,
        defaultValue
      }
    });
  }, [changeParams]);
  return [
    __assign28(__assign28({ filterValues, requestSignature }, query), { displayedFilters: displayedFilterValues }),
    {
      changeParams,
      setPage,
      setPerPage,
      setSort,
      setFilters,
      hideFilter,
      showFilter
    }
  ];
};
var parseObject = function(query, field) {
  if (query[field] && typeof query[field] === "string") {
    try {
      query[field] = JSON.parse(query[field]);
    } catch (err) {
      delete query[field];
    }
  }
};
var parseQueryFromLocation = function(_a11) {
  var search = _a11.search;
  var query = (0, import_query_string2.parse)(search);
  parseObject(query, "filter");
  parseObject(query, "displayedFilters");
  return query;
};
var hasCustomParams = function(params) {
  return params && params.filter && (Object.keys(params.filter).length > 0 || params.order != null || params.page !== 1 || params.perPage != null || params.sort != null);
};
var getQuery = function(_a11) {
  var queryFromLocation = _a11.queryFromLocation, params = _a11.params, filterDefaultValues = _a11.filterDefaultValues, sort = _a11.sort, perPage = _a11.perPage;
  var query = Object.keys(queryFromLocation).length > 0 ? queryFromLocation : hasCustomParams(params) ? __assign28({}, params) : { filter: filterDefaultValues || {} };
  if (!query.sort) {
    query.sort = sort.field;
    query.order = sort.order;
  }
  if (query.perPage == null) {
    query.perPage = perPage;
  }
  if (query.page == null) {
    query.page = 1;
  }
  return __assign28(__assign28({}, query), { page: getNumberOrDefault(query.page, 1), perPage: getNumberOrDefault(query.perPage, 10) });
};
var getNumberOrDefault = function(possibleNumber, defaultValue) {
  if (typeof possibleNumber === "undefined") {
    return defaultValue;
  }
  var parsedNumber = typeof possibleNumber === "string" ? parseInt(possibleNumber, 10) : possibleNumber;
  return isNaN(parsedNumber) ? defaultValue : parsedNumber;
};
var emptyObject = {};
var defaultSort2 = {
  field: "id",
  order: SORT_ASC
};
var defaultParams = {};

// node_modules/ra-core/dist/esm/controller/list/useSelectAll.js
var __assign29 = function() {
  __assign29 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign29.apply(this, arguments);
};
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator11 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest26 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useSelectAll = function(params) {
  var sort = params.sort, filter = params.filter;
  var resource = useResourceContext(params);
  if (!resource) {
    throw new Error("useSelectAll should be used inside a ResourceContextProvider or passed a resource prop");
  }
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var _a11 = useRecordSelection({ resource }), select = _a11[1].select;
  var notify = useNotify();
  var handleSelectAll = useEvent(function(_a12) {
    var _b = _a12 === void 0 ? {} : _a12, _c = _b.queryOptions, queryOptions2 = _c === void 0 ? {} : _c, _d = _b.limit, limit = _d === void 0 ? 250 : _d;
    return __awaiter11(void 0, void 0, void 0, function() {
      var meta, onSuccess, onError, otherQueryOptions, results, allIds, error_1;
      var _e;
      return __generator11(this, function(_f) {
        switch (_f.label) {
          case 0:
            meta = queryOptions2.meta, onSuccess = queryOptions2.onSuccess, onError = queryOptions2.onError, otherQueryOptions = __rest26(queryOptions2, ["meta", "onSuccess", "onError"]);
            _f.label = 1;
          case 1:
            _f.trys.push([1, 3, , 4]);
            return [4, queryClient.fetchQuery(__assign29({ queryKey: [
              resource,
              "getList",
              {
                pagination: { page: 1, perPage: limit },
                sort,
                filter,
                meta
              }
            ], queryFn: function() {
              return dataProvider.getList(resource, {
                pagination: {
                  page: 1,
                  perPage: limit
                },
                sort,
                filter,
                meta
              });
            } }, otherQueryOptions))];
          case 2:
            results = _f.sent();
            allIds = ((_e = results.data) === null || _e === void 0 ? void 0 : _e.map(function(_a13) {
              var id = _a13.id;
              return id;
            })) || [];
            select(allIds);
            if (allIds.length === limit) {
              notify("ra.message.select_all_limit_reached", {
                messageArgs: { max: limit },
                type: "warning"
              });
            }
            if (onSuccess) {
              onSuccess(results);
            }
            return [2, results.data];
          case 3:
            error_1 = _f.sent();
            if (onError) {
              onError(error_1);
            } else {
              notify("ra.notification.http_error", { type: "warning" });
            }
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
  return handleSelectAll;
};

// node_modules/ra-core/dist/esm/controller/list/useInfiniteListController.js
var __assign30 = function() {
  __assign30 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign30.apply(this, arguments);
};
var __rest27 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray16 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useInfiniteListController = function(props) {
  if (props === void 0) {
    props = {};
  }
  var _a11 = props.debounce, debounce5 = _a11 === void 0 ? 500 : _a11, _b = props.disableAuthentication, disableAuthentication = _b === void 0 ? false : _b, _c = props.disableSyncWithLocation, disableSyncWithLocation = _c === void 0 ? false : _c, _d = props.exporter, exporter = _d === void 0 ? defaultExporter : _d, filter = props.filter, filterDefaultValues = props.filterDefaultValues, _e = props.perPage, perPage = _e === void 0 ? 10 : _e, queryOptions2 = props.queryOptions, sort = props.sort, storeKey = props.storeKey;
  var resource = useResourceContext(props);
  var _f = queryOptions2 !== null && queryOptions2 !== void 0 ? queryOptions2 : {}, meta = _f.meta, otherQueryOptions = __rest27(_f, ["meta"]);
  if (!resource) {
    throw new Error("<InfiniteList> was called outside of a ResourceContext and without a resource prop. You must set the resource prop.");
  }
  if (filter && (0, import_react81.isValidElement)(filter)) {
    throw new Error("<InfiniteList> received a React element as `filter` props. If you intended to set the list filter elements, use the `filters` (with an s) prop instead. The `filter` prop is internal and should not be set by the developer.");
  }
  var isPendingAuthenticated = useAuthenticated({
    enabled: !disableAuthentication
  }).isPending;
  var isPendingCanAccess = useRequireAccess({
    action: "list",
    resource,
    // If disableAuthentication is true then isPendingAuthenticated will always be true so this hook is disabled
    enabled: !isPendingAuthenticated
  }).isPending;
  var translate = useTranslate();
  var notify = useNotify();
  var _g = useListParams({
    debounce: debounce5,
    disableSyncWithLocation,
    filterDefaultValues,
    perPage,
    resource,
    sort,
    storeKey
  }), query = _g[0], queryModifiers = _g[1];
  var _h = useRecordSelection({ resource }), selectedIds = _h[0], selectionModifiers = _h[1];
  var _j = useInfiniteGetList(resource, {
    pagination: {
      page: query.page,
      perPage: query.perPage
    },
    sort: { field: query.sort, order: query.order },
    filter: __assign30(__assign30({}, query.filter), filter),
    meta
  }, __assign30({ enabled: !isPendingAuthenticated && !isPendingCanAccess || disableAuthentication, placeholderData: function(previousData) {
    return previousData;
  }, retry: false, onError: function(error2) {
    return notify((error2 === null || error2 === void 0 ? void 0 : error2.message) || "ra.notification.http_error", {
      type: "error",
      messageArgs: {
        _: error2 === null || error2 === void 0 ? void 0 : error2.message
      }
    });
  } }, otherQueryOptions)), data = _j.data, total = _j.total, error = _j.error, isLoading = _j.isLoading, isPending = _j.isPending, isFetching = _j.isFetching, hasNextPage2 = _j.hasNextPage, hasPreviousPage2 = _j.hasPreviousPage, fetchNextPage = _j.fetchNextPage, isFetchingNextPage = _j.isFetchingNextPage, fetchPreviousPage = _j.fetchPreviousPage, isFetchingPreviousPage = _j.isFetchingPreviousPage, refetch2 = _j.refetch;
  var onSelectAll = useSelectAll({
    resource,
    sort: { field: query.sort, order: query.order },
    filter: __assign30(__assign30({}, query.filter), filter)
  });
  (0, import_react81.useEffect)(function() {
    if (query.page <= 0 || !isFetching && query.page > 1 && (data == null || (data === null || data === void 0 ? void 0 : data.pages.length) === 0)) {
      queryModifiers.setPage(1);
      return;
    }
    if (total == null) {
      return;
    }
    var totalPages = Math.ceil(total / query.perPage) || 1;
    if (!isFetching && query.page > totalPages) {
      queryModifiers.setPage(totalPages);
    }
  }, [isFetching, query.page, query.perPage, data, queryModifiers, total]);
  var currentSort = (0, import_react81.useMemo)(function() {
    return {
      field: query.sort,
      order: query.order
    };
  }, [query.sort, query.order]);
  var getResourceLabel = useGetResourceLabel();
  var defaultTitle = translate("ra.page.list", {
    name: getResourceLabel(resource, 2)
  });
  var unwrappedData = (0, import_react81.useMemo)(function() {
    var _a12;
    return (_a12 = data === null || data === void 0 ? void 0 : data.pages) === null || _a12 === void 0 ? void 0 : _a12.reduce(function(acc, page) {
      return __spreadArray16(__spreadArray16([], acc, true), page.data, true);
    }, []);
  }, [data]);
  return {
    sort: currentSort,
    data: unwrappedData,
    defaultTitle,
    displayedFilters: query.displayedFilters,
    error,
    exporter,
    filter,
    filterValues: query.filterValues,
    hideFilter: queryModifiers.hideFilter,
    isFetching,
    isLoading,
    isPending,
    onSelect: selectionModifiers.select,
    onSelectAll,
    onToggleItem: selectionModifiers.toggle,
    onUnselectItems: selectionModifiers.clearSelection,
    page: query.page,
    perPage: query.perPage,
    refetch: refetch2,
    resource,
    selectedIds,
    setFilters: queryModifiers.setFilters,
    setPage: queryModifiers.setPage,
    setPerPage: queryModifiers.setPerPage,
    setSort: queryModifiers.setSort,
    showFilter: queryModifiers.showFilter,
    total,
    hasNextPage: hasNextPage2,
    hasPreviousPage: hasPreviousPage2,
    fetchNextPage,
    isFetchingNextPage,
    fetchPreviousPage,
    isFetchingPreviousPage
  };
};

// node_modules/ra-core/dist/esm/controller/list/ListContextProvider.js
var React33 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/list/ListContext.js
var import_react82 = __toESM(require_react());
var ListContext = (0, import_react82.createContext)(null);
ListContext.displayName = "ListContext";

// node_modules/ra-core/dist/esm/controller/list/ListFilterContext.js
var import_react83 = __toESM(require_react());
var import_pick2 = __toESM(require_pick());
var ListFilterContext = (0, import_react83.createContext)(void 0);
var usePickFilterContext = function(context) {
  return (0, import_react83.useMemo)(
    function() {
      return (0, import_pick2.default)(context, [
        "displayedFilters",
        "filterValues",
        "hideFilter",
        "setFilters",
        "showFilter",
        "resource"
      ]);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      context.displayedFilters,
      context.filterValues,
      context.hideFilter,
      context.setFilters,
      context.showFilter
    ]
  );
};
ListFilterContext.displayName = "ListFilterContext";

// node_modules/ra-core/dist/esm/controller/list/ListSortContext.js
var import_react84 = __toESM(require_react());
var import_pick3 = __toESM(require_pick());
var ListSortContext = (0, import_react84.createContext)(void 0);
var usePickSortContext = function(context) {
  return (0, import_react84.useMemo)(
    function() {
      return (0, import_pick3.default)(context, ["sort", "setSort", "resource"]);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [context.sort, context.setSort]
  );
};
ListSortContext.displayName = "ListSortContext";

// node_modules/ra-core/dist/esm/controller/list/ListPaginationContext.js
var import_react85 = __toESM(require_react());
var import_pick4 = __toESM(require_pick());
var ListPaginationContext = (0, import_react85.createContext)(void 0);
ListPaginationContext.displayName = "ListPaginationContext";
var usePickPaginationContext = function(context) {
  return (0, import_react85.useMemo)(
    function() {
      return (0, import_pick4.default)(context, [
        "isLoading",
        "isPending",
        "hasPreviousPage",
        "hasNextPage",
        "page",
        "perPage",
        "setPage",
        "setPerPage",
        "total",
        "resource"
      ]);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      context.isLoading,
      context.isPending,
      context.hasPreviousPage,
      context.hasNextPage,
      context.page,
      context.perPage,
      context.setPage,
      context.setPerPage,
      context.total
    ]
  );
};

// node_modules/ra-core/dist/esm/controller/list/ListContextProvider.js
var ListContextProvider = function(_a11) {
  var value = _a11.value, children = _a11.children;
  return React33.createElement(
    ListContext.Provider,
    { value },
    React33.createElement(
      ListFilterContext.Provider,
      { value: usePickFilterContext(value) },
      React33.createElement(
        ListSortContext.Provider,
        { value: usePickSortContext(value) },
        React33.createElement(ListPaginationContext.Provider, { value: usePickPaginationContext(value) }, children)
      )
    )
  );
};

// node_modules/ra-core/dist/esm/controller/list/InfinitePaginationContext.js
var import_react86 = __toESM(require_react());
var InfinitePaginationContext = (0, import_react86.createContext)({
  hasNextPage: false,
  fetchNextPage: function() {
    return Promise.reject("not implemented");
  },
  isFetchingNextPage: false,
  hasPreviousPage: false,
  fetchPreviousPage: function() {
    return Promise.reject("not implemented");
  },
  isFetchingPreviousPage: false
});
InfinitePaginationContext.displayName = "InfinitePaginationContext";

// node_modules/ra-core/dist/esm/controller/list/InfiniteListBase.js
var __rest28 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var InfiniteListBase = function(_a11) {
  var children = _a11.children, _b = _a11.loading, loading = _b === void 0 ? null : _b, props = __rest28(_a11, ["children", "loading"]);
  var controllerProps = useInfiniteListController(props);
  var isAuthPending = useIsAuthPending({
    resource: controllerProps.resource,
    action: "list"
  });
  if (isAuthPending && !props.disableAuthentication) {
    return loading;
  }
  return (
    // We pass props.resource here as we don't need to create a new ResourceContext if the props is not provided
    React34.createElement(
      OptionalResourceContextProvider,
      { value: props.resource },
      React34.createElement(
        ListContextProvider,
        { value: controllerProps },
        React34.createElement(InfinitePaginationContext.Provider, { value: {
          hasNextPage: controllerProps.hasNextPage,
          fetchNextPage: controllerProps.fetchNextPage,
          isFetchingNextPage: controllerProps.isFetchingNextPage,
          hasPreviousPage: controllerProps.hasPreviousPage,
          fetchPreviousPage: controllerProps.fetchPreviousPage,
          isFetchingPreviousPage: controllerProps.isFetchingPreviousPage
        } }, children)
      )
    )
  );
};

// node_modules/ra-core/dist/esm/controller/list/ListBase.js
var React35 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/list/useListController.js
var import_react87 = __toESM(require_react());
var __assign31 = function() {
  __assign31 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign31.apply(this, arguments);
};
var __rest29 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useListController = function(props) {
  if (props === void 0) {
    props = {};
  }
  var _a11 = props.debounce, debounce5 = _a11 === void 0 ? 500 : _a11, _b = props.disableAuthentication, disableAuthentication = _b === void 0 ? false : _b, _c = props.disableSyncWithLocation, disableSyncWithLocation = _c === void 0 ? false : _c, _d = props.exporter, exporter = _d === void 0 ? defaultExporter : _d, filter = props.filter, filterDefaultValues = props.filterDefaultValues, _e = props.perPage, perPage = _e === void 0 ? 10 : _e, _f = props.queryOptions, queryOptions2 = _f === void 0 ? {} : _f, _g = props.sort, sort = _g === void 0 ? defaultSort3 : _g, storeKey = props.storeKey;
  var resource = useResourceContext(props);
  var meta = queryOptions2.meta, otherQueryOptions = __rest29(queryOptions2, ["meta"]);
  if (!resource) {
    throw new Error("useListController requires a non-empty resource prop or context");
  }
  if (filter && ((0, import_react87.isValidElement)(filter) || Array.isArray(filter) && filter.some(import_react87.isValidElement))) {
    throw new Error("useListController received a React element as `filter` props. If you intended to set the list filter elements, use the `filters` (with an s) prop instead. The `filter` prop is internal and should not be set by the developer.");
  }
  var isPendingAuthenticated = useAuthenticated({
    enabled: !disableAuthentication
  }).isPending;
  var isPendingCanAccess = useRequireAccess({
    action: "list",
    resource,
    // If disableAuthentication is true then isPendingAuthenticated will always be true so this hook is disabled
    enabled: !isPendingAuthenticated
  }).isPending;
  var translate = useTranslate();
  var notify = useNotify();
  var _h = useListParams({
    debounce: debounce5,
    disableSyncWithLocation,
    filterDefaultValues,
    perPage,
    resource,
    sort,
    storeKey
  }), query = _h[0], queryModifiers = _h[1];
  var _j = useRecordSelection({
    resource,
    disableSyncWithStore: storeKey === false
  }), selectedIds = _j[0], selectionModifiers = _j[1];
  var _k = useGetList(resource, {
    pagination: {
      page: query.page,
      perPage: query.perPage
    },
    sort: { field: query.sort, order: query.order },
    filter: __assign31(__assign31({}, query.filter), filter),
    meta
  }, __assign31({ enabled: !isPendingAuthenticated && !isPendingCanAccess || disableAuthentication, placeholderData: function(previousData) {
    return previousData;
  }, retry: false, onError: function(error2) {
    return notify((error2 === null || error2 === void 0 ? void 0 : error2.message) || "ra.notification.http_error", {
      type: "error",
      messageArgs: {
        _: error2 === null || error2 === void 0 ? void 0 : error2.message
      }
    });
  } }, otherQueryOptions)), data = _k.data, pageInfo = _k.pageInfo, total = _k.total, responseMeta = _k.meta, error = _k.error, isLoading = _k.isLoading, isFetching = _k.isFetching, isPending = _k.isPending, refetch2 = _k.refetch;
  (0, import_react87.useEffect)(function() {
    if (query.page <= 0 || !isFetching && query.page > 1 && (data == null || (data === null || data === void 0 ? void 0 : data.length) === 0)) {
      queryModifiers.setPage(1);
      return;
    }
    if (total == null) {
      return;
    }
    var totalPages = Math.ceil(total / query.perPage) || 1;
    if (!isFetching && query.page > totalPages) {
      queryModifiers.setPage(totalPages);
    }
  }, [isFetching, query.page, query.perPage, data, queryModifiers, total]);
  var currentSort = (0, import_react87.useMemo)(function() {
    return {
      field: query.sort,
      order: query.order
    };
  }, [query.sort, query.order]);
  var getResourceLabel = useGetResourceLabel();
  var defaultTitle = translate("ra.page.list", {
    name: getResourceLabel(resource, 2)
  });
  var onSelectAll = useSelectAll({
    resource,
    sort: { field: query.sort, order: query.order },
    filter: __assign31(__assign31({}, query.filter), filter)
  });
  return {
    sort: currentSort,
    data,
    meta: responseMeta,
    defaultTitle,
    displayedFilters: query.displayedFilters,
    error,
    exporter,
    filter,
    filterValues: query.filterValues,
    hideFilter: queryModifiers.hideFilter,
    isFetching,
    isLoading,
    isPending,
    onSelect: selectionModifiers.select,
    onSelectAll,
    onToggleItem: selectionModifiers.toggle,
    onUnselectItems: selectionModifiers.clearSelection,
    page: query.page,
    perPage: query.perPage,
    refetch: refetch2,
    resource,
    selectedIds,
    setFilters: queryModifiers.setFilters,
    setPage: queryModifiers.setPage,
    setPerPage: queryModifiers.setPerPage,
    setSort: queryModifiers.setSort,
    showFilter: queryModifiers.showFilter,
    total,
    hasNextPage: pageInfo ? pageInfo.hasNextPage : total != null ? query.page * query.perPage < total : void 0,
    hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : query.page > 1
  };
};
var defaultSort3 = {
  field: "id",
  order: SORT_ASC
};
var injectedProps = [
  "sort",
  "data",
  "defaultTitle",
  "displayedFilters",
  "error",
  "exporter",
  "filterValues",
  "hasNextPage",
  "hasPreviousPage",
  "hideFilter",
  "isFetching",
  "isLoading",
  "isPending",
  "onSelect",
  "onSelectAll",
  "onToggleItem",
  "onUnselectItems",
  "page",
  "perPage",
  "refetch",
  "refresh",
  "resource",
  "selectedIds",
  "setFilters",
  "setPage",
  "setPerPage",
  "setSort",
  "showFilter",
  "total",
  "totalPages"
];
var getListControllerProps = function(props) {
  return injectedProps.reduce(function(acc, key) {
    var _a11;
    return __assign31(__assign31({}, acc), (_a11 = {}, _a11[key] = props[key], _a11));
  }, {});
};
var sanitizeListRestProps = function(props) {
  return Object.keys(props).filter(function(propName) {
    return !injectedProps.includes(propName);
  }).reduce(function(acc, key) {
    var _a11;
    return __assign31(__assign31({}, acc), (_a11 = {}, _a11[key] = props[key], _a11));
  }, {});
};

// node_modules/ra-core/dist/esm/controller/list/ListBase.js
var __rest30 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ListBase = function(_a11) {
  var children = _a11.children, _b = _a11.loading, loading = _b === void 0 ? null : _b, props = __rest30(_a11, ["children", "loading"]);
  var controllerProps = useListController(props);
  var isAuthPending = useIsAuthPending({
    resource: controllerProps.resource,
    action: "list"
  });
  if (isAuthPending && !props.disableAuthentication) {
    return loading;
  }
  return (
    // We pass props.resource here as we don't need to create a new ResourceContext if the props is not provided
    React35.createElement(
      OptionalResourceContextProvider,
      { value: props.resource },
      React35.createElement(ListContextProvider, { value: controllerProps }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/list/ListController.js
var __rest31 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ListController = function(_a11) {
  var children = _a11.children, props = __rest31(_a11, ["children"]);
  var controllerProps = useListController(props);
  return children(controllerProps);
};

// node_modules/ra-core/dist/esm/controller/list/useExpanded.js
var import_react88 = __toESM(require_react());
var __spreadArray17 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useExpanded = function(resource, id, single) {
  if (single === void 0) {
    single = false;
  }
  var _a11 = useStore("".concat(resource, ".datagrid.expanded"), []), expandedIds = _a11[0], setExpandedIds = _a11[1];
  var expanded = Array.isArray(expandedIds) ? (
    // eslint-disable-next-line eqeqeq
    expandedIds.map(function(el) {
      return el == id;
    }).indexOf(true) !== -1
  ) : false;
  var toggleExpanded = (0, import_react88.useCallback)(function() {
    setExpandedIds(function(ids) {
      if (!Array.isArray(ids)) {
        return [id];
      }
      var index = ids.findIndex(function(el) {
        return el == id;
      });
      return index > -1 ? single ? [] : __spreadArray17(__spreadArray17([], ids.slice(0, index), true), ids.slice(index + 1), true) : single ? [id] : __spreadArray17(__spreadArray17([], ids, true), [id], false);
    });
  }, [setExpandedIds, id, single]);
  return [expanded, toggleExpanded];
};
var useExpandAll = function(resource, ids) {
  var _a11 = useStore("".concat(resource, ".datagrid.expanded"), []), expandedIds = _a11[0], setExpandedIds = _a11[1];
  var isExpanded = Array.isArray(expandedIds) ? (
    // eslint-disable-next-line eqeqeq
    expandedIds.some(function(id) {
      return ids.some(function(id2) {
        return id2 == id;
      });
    })
  ) : false;
  var toggleExpandedAll = (0, import_react88.useCallback)(function() {
    var unaffectedExpandedIds = expandedIds.filter(
      // eslint-disable-next-line eqeqeq
      function(expanded_id) {
        return !ids.some(function(id) {
          return id == expanded_id;
        });
      }
    );
    setExpandedIds(isExpanded ? unaffectedExpandedIds : unaffectedExpandedIds.concat(ids));
  }, [expandedIds, setExpandedIds, isExpanded, ids]);
  return [isExpanded, toggleExpandedAll];
};

// node_modules/ra-core/dist/esm/controller/list/useInfinitePaginationContext.js
var import_react89 = __toESM(require_react());
var useInfinitePaginationContext = function() {
  return (0, import_react89.useContext)(InfinitePaginationContext);
};

// node_modules/ra-core/dist/esm/controller/list/useList.js
var import_react90 = __toESM(require_react());
var import_get4 = __toESM(require_get());
var import_isEqual3 = __toESM(require_isEqual());
var __assign32 = function() {
  __assign32 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign32.apply(this, arguments);
};
var __rest32 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var refetch = function() {
  throw new Error("refetch is not available for a ListContext built from useList based on local data");
};
var useList = function(props) {
  var _a11;
  var data = props.data, error = props.error, _b = props.filter, filter = _b === void 0 ? defaultFilter2 : _b, _c = props.isFetching, isFetching = _c === void 0 ? false : _c, _d = props.isLoading, isLoading = _d === void 0 ? false : _d, _e = props.isPending, isPending = _e === void 0 ? false : _e, _f = props.page, initialPage = _f === void 0 ? 1 : _f, _g = props.perPage, initialPerPage = _g === void 0 ? 1e3 : _g, initialSort = props.sort, _h = props.filterCallback, filterCallback = _h === void 0 ? function(record) {
    return Boolean(record);
  } : _h;
  var resource = useResourceContext(props);
  var _j = (0, import_react90.useState)(isFetching), fetchingState = _j[0], setFetchingState = _j[1];
  var _k = (0, import_react90.useState)(isLoading), loadingState = _k[0], setLoadingState = _k[1];
  var _l = (0, import_react90.useState)(isPending), pendingState = _l[0], setPendingState = _l[1];
  var _m = (0, import_react90.useState)(function() {
    return {
      data,
      total: data ? data.length : void 0
    };
  }), finalItems = _m[0], setFinalItems = _m[1];
  var _o = usePaginationState_default({
    page: initialPage,
    perPage: initialPerPage
  }), page = _o.page, setPage = _o.setPage, perPage = _o.perPage, setPerPage = _o.setPerPage;
  var _p = useSortState_default(initialSort), sort = _p.sort, setSortState = _p.setSort;
  var setSort = (0, import_react90.useCallback)(function(sort2) {
    setSortState(sort2);
    setPage(1);
  }, [setPage, setSortState]);
  var _q = useRecordSelection(resource ? {
    resource
  } : { disableSyncWithStore: true }), selectedIds = _q[0], selectionModifiers = _q[1];
  var filterRef = (0, import_react90.useRef)(filter);
  var _r = (0, import_react90.useState)({}), displayedFilters = _r[0], setDisplayedFilters = _r[1];
  var _s = (0, import_react90.useState)(filter), filterValues = _s[0], setFilterValues = _s[1];
  var hideFilter = (0, import_react90.useCallback)(function(filterName) {
    setDisplayedFilters(function(previousState) {
      var _a12 = previousState, _b2 = filterName, _ = _a12[_b2], newState = __rest32(_a12, [typeof _b2 === "symbol" ? _b2 : _b2 + ""]);
      return newState;
    });
    setFilterValues(function(previousState) {
      var _a12 = previousState, _b2 = filterName, _ = _a12[_b2], newState = __rest32(_a12, [typeof _b2 === "symbol" ? _b2 : _b2 + ""]);
      return newState;
    });
  }, [setDisplayedFilters, setFilterValues]);
  var showFilter = (0, import_react90.useCallback)(function(filterName, defaultValue) {
    setDisplayedFilters(function(previousState) {
      var _a12;
      return __assign32(__assign32({}, previousState), (_a12 = {}, _a12[filterName] = true, _a12));
    });
    setFilterValues(function(previousState) {
      var _a12;
      return removeEmpty_default(__assign32(__assign32({}, previousState), (_a12 = {}, _a12[filterName] = defaultValue, _a12)));
    });
  }, [setDisplayedFilters, setFilterValues]);
  var setFilters = (0, import_react90.useCallback)(function(filters, displayedFilters2) {
    if (displayedFilters2 === void 0) {
      displayedFilters2 = void 0;
    }
    setFilterValues(removeEmpty_default(filters));
    if (displayedFilters2) {
      setDisplayedFilters(displayedFilters2);
    }
    setPage(1);
  }, [setDisplayedFilters, setFilterValues, setPage]);
  (0, import_react90.useEffect)(function() {
    if (!(0, import_isEqual3.default)(filter, filterRef.current)) {
      filterRef.current = filter;
      setFilterValues(filter);
    }
  }, [filter]);
  (0, import_react90.useEffect)(
    function() {
      if (isPending || !data)
        return;
      var tempData = data;
      if (filterValues) {
        var flattenFilterValues_1 = flattenObject(filterValues);
        tempData = data.filter(function(record) {
          return Object.entries(flattenFilterValues_1).every(function(_a12) {
            var filterName = _a12[0], filterValue = _a12[1];
            var recordValue = (0, import_get4.default)(record, filterName);
            var result = Array.isArray(recordValue) ? Array.isArray(filterValue) ? recordValue.some(function(item) {
              return filterValue.includes(item);
            }) : recordValue.includes(filterValue) : Array.isArray(filterValue) ? filterValue.includes(recordValue) : filterName === "q" ? Object.keys(record).some(function(key) {
              return typeof record[key] === "string" && record[key].toLowerCase().includes(filterValue.toLowerCase());
            }) : filterValue == recordValue;
            return result;
          });
        }).filter(filterCallback);
      }
      var filteredLength = tempData.length;
      if (sort.field) {
        tempData = tempData.sort(function(a, b) {
          if ((0, import_get4.default)(a, sort.field) > (0, import_get4.default)(b, sort.field)) {
            return sort.order === "ASC" ? 1 : -1;
          }
          if ((0, import_get4.default)(a, sort.field) < (0, import_get4.default)(b, sort.field)) {
            return sort.order === "ASC" ? -1 : 1;
          }
          return 0;
        });
      }
      tempData = tempData.slice((page - 1) * perPage, page * perPage);
      setFinalItems({
        data: tempData,
        total: filteredLength
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(data),
      filterValues,
      isPending,
      page,
      perPage,
      setFinalItems,
      sort.field,
      sort.order
    ]
  );
  (0, import_react90.useEffect)(function() {
    if (isFetching !== fetchingState) {
      setFetchingState(isFetching);
    }
  }, [isFetching, fetchingState, setFetchingState]);
  (0, import_react90.useEffect)(function() {
    if (isLoading !== loadingState) {
      setLoadingState(isLoading);
    }
  }, [isLoading, loadingState, setLoadingState]);
  (0, import_react90.useEffect)(function() {
    if (isPending !== pendingState) {
      setPendingState(isPending);
    }
  }, [isPending, pendingState, setPendingState]);
  var onSelectAll = (0, import_react90.useCallback)(function() {
    var allIds = (data === null || data === void 0 ? void 0 : data.map(function(_a12) {
      var id = _a12.id;
      return id;
    })) || [];
    selectionModifiers.select(allIds);
  }, [data, selectionModifiers]);
  return {
    sort,
    data: pendingState ? void 0 : (_a11 = finalItems === null || finalItems === void 0 ? void 0 : finalItems.data) !== null && _a11 !== void 0 ? _a11 : [],
    defaultTitle: "",
    error: error !== null && error !== void 0 ? error : null,
    displayedFilters,
    filterValues,
    hasNextPage: (finalItems === null || finalItems === void 0 ? void 0 : finalItems.total) == null ? false : page * perPage < finalItems.total,
    hasPreviousPage: page > 1,
    hideFilter,
    isFetching: fetchingState,
    isLoading: loadingState,
    isPending: pendingState,
    onSelect: selectionModifiers.select,
    onSelectAll,
    onToggleItem: selectionModifiers.toggle,
    onUnselectItems: selectionModifiers.clearSelection,
    page,
    perPage,
    resource: "",
    refetch,
    selectedIds,
    setFilters,
    setPage,
    setPerPage,
    setSort,
    showFilter,
    total: finalItems === null || finalItems === void 0 ? void 0 : finalItems.total
  };
};
var defaultFilter2 = {};

// node_modules/ra-core/dist/esm/controller/list/useListContext.js
var import_react91 = __toESM(require_react());
var useListContext = function() {
  var context = (0, import_react91.useContext)(ListContext);
  if (!context) {
    throw new Error("useListContext must be used inside a ListContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/list/useListContextWithProps.js
var import_react92 = __toESM(require_react());
var import_defaults = __toESM(require_defaults());
var useListContextWithProps = function(props) {
  var context = (0, import_react92.useContext)(ListContext);
  return (0, import_react92.useMemo)(function() {
    return (0, import_defaults.default)({}, props != null ? extractListContextProps(props) : {}, context);
  }, [context, props]);
};
var extractListContextProps = function(_a11) {
  var sort = _a11.sort, data = _a11.data, defaultTitle = _a11.defaultTitle, displayedFilters = _a11.displayedFilters, exporter = _a11.exporter, filterValues = _a11.filterValues, hasCreate = _a11.hasCreate, hideFilter = _a11.hideFilter, isFetching = _a11.isFetching, isLoading = _a11.isLoading, isPending = _a11.isPending, onSelect = _a11.onSelect, onSelectAll = _a11.onSelectAll, onToggleItem = _a11.onToggleItem, onUnselectItems = _a11.onUnselectItems, page = _a11.page, perPage = _a11.perPage, refetch2 = _a11.refetch, resource = _a11.resource, selectedIds = _a11.selectedIds, setFilters = _a11.setFilters, setPage = _a11.setPage, setPerPage = _a11.setPerPage, setSort = _a11.setSort, showFilter = _a11.showFilter, total = _a11.total;
  return {
    sort,
    data,
    defaultTitle,
    displayedFilters,
    exporter,
    filterValues,
    hasCreate,
    hideFilter,
    isFetching,
    isLoading,
    isPending,
    onSelect,
    onSelectAll,
    onToggleItem,
    onUnselectItems,
    page,
    perPage,
    refetch: refetch2,
    resource,
    selectedIds,
    setFilters,
    setPage,
    setPerPage,
    setSort,
    showFilter,
    total
  };
};

// node_modules/ra-core/dist/esm/controller/list/useListFilterContext.js
var import_react93 = __toESM(require_react());
var useListFilterContext = function() {
  var context = (0, import_react93.useContext)(ListFilterContext);
  if (!context) {
    throw new Error("useListFilterContext must be used inside a ListFilterContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/list/useListPaginationContext.js
var import_react94 = __toESM(require_react());
var useListPaginationContext = function() {
  var context = (0, import_react94.useContext)(ListPaginationContext);
  if (!context) {
    throw new Error("useListPaginationContext must be used inside a ListPaginationContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/list/useListSortContext.js
var import_react95 = __toESM(require_react());
var useListSortContext = function() {
  var context = (0, import_react95.useContext)(ListSortContext);
  if (!context) {
    throw new Error("useListSortContext must be used inside a ListSortContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/list/useUnselect.js
var import_react96 = __toESM(require_react());
var useUnselect = function(resource) {
  var _a11 = useRecordSelection(resource ? { resource } : { disableSyncWithStore: true }), unselect = _a11[1].unselect;
  return (0, import_react96.useCallback)(function(ids) {
    unselect(ids);
  }, [unselect]);
};

// node_modules/ra-core/dist/esm/controller/list/useUnselectAll.js
var import_react97 = __toESM(require_react());
var useUnselectAll = function(resource) {
  var _a11 = useRecordSelection(resource ? { resource } : { disableSyncWithStore: true }), clearSelection = _a11[1].clearSelection;
  return (0, import_react97.useCallback)(function() {
    clearSelection();
  }, [clearSelection]);
};

// node_modules/ra-core/dist/esm/controller/list/WithListContext.js
var WithListContext = function(_a11) {
  var render = _a11.render;
  return render(useListContext()) || null;
};

// node_modules/ra-core/dist/esm/controller/field/useReferenceArrayFieldController.js
var __assign33 = function() {
  __assign33 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign33.apply(this, arguments);
};
var __rest33 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var emptyArray = [];
var defaultFilter3 = {};
var useReferenceArrayFieldController = function(props) {
  var _a11 = props.filter, filter = _a11 === void 0 ? defaultFilter3 : _a11, _b = props.page, page = _b === void 0 ? 1 : _b, _c = props.perPage, perPage = _c === void 0 ? 1e3 : _c, record = props.record, reference = props.reference, sort = props.sort, source = props.source, _d = props.queryOptions, queryOptions2 = _d === void 0 ? {} : _d;
  var notify = useNotify();
  var value = (0, import_get5.default)(record, source);
  var meta = queryOptions2.meta, otherQueryOptions = __rest33(queryOptions2, ["meta"]);
  var ids = Array.isArray(value) ? value : emptyArray;
  var _e = useGetManyAggregate(reference, { ids, meta }, __assign33({ onError: function(error2) {
    return notify(typeof error2 === "string" ? error2 : (error2 === null || error2 === void 0 ? void 0 : error2.message) || "ra.notification.http_error", {
      type: "error",
      messageArgs: {
        _: typeof error2 === "string" ? error2 : (error2 === null || error2 === void 0 ? void 0 : error2.message) ? error2.message : void 0
      }
    });
  } }, otherQueryOptions)), data = _e.data, error = _e.error, isLoading = _e.isLoading, isFetching = _e.isFetching, isPending = _e.isPending, refetch2 = _e.refetch;
  var listProps = useList({
    data,
    error,
    filter,
    isFetching,
    isLoading,
    isPending,
    page,
    perPage,
    sort
  });
  return __assign33(__assign33({}, listProps), { defaultTitle: void 0, refetch: refetch2, resource: reference });
};

// node_modules/ra-core/dist/esm/controller/field/useReferenceManyFieldController.js
var import_react98 = __toESM(require_react());
var import_get6 = __toESM(require_get());
var import_isEqual4 = __toESM(require_isEqual());
var import_debounce4 = __toESM(require_debounce());
var __assign34 = function() {
  __assign34 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign34.apply(this, arguments);
};
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator12 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest34 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useReferenceManyFieldController = function(props) {
  var _a11;
  var _b = props.debounce, debounce5 = _b === void 0 ? 500 : _b, reference = props.reference, record = props.record, target = props.target, _c = props.filter, filter = _c === void 0 ? defaultFilter4 : _c, _d = props.source, source = _d === void 0 ? "id" : _d, initialPage = props.page, initialPerPage = props.perPage, _e = props.sort, initialSort = _e === void 0 ? { field: "id", order: "DESC" } : _e, _f = props.queryOptions, queryOptions2 = _f === void 0 ? {} : _f;
  var notify = useNotify();
  var resource = useResourceContext(props);
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var storeKey = (_a11 = props.storeKey) !== null && _a11 !== void 0 ? _a11 : "".concat(resource, ".").concat(record === null || record === void 0 ? void 0 : record.id, ".").concat(reference);
  var meta = queryOptions2.meta, otherQueryOptions = __rest34(queryOptions2, ["meta"]);
  var _g = usePaginationState_default({
    page: initialPage,
    perPage: initialPerPage
  }), page = _g.page, setPage = _g.setPage, perPage = _g.perPage, setPerPage = _g.setPerPage;
  var _h = useSortState_default(initialSort), sort = _h.sort, setSortState = _h.setSort;
  var setSort = (0, import_react98.useCallback)(function(sort2) {
    setSortState(sort2);
    setPage(1);
  }, [setPage, setSortState]);
  var _j = useRecordSelection({
    resource: storeKey
  }), selectedIds = _j[0], selectionModifiers = _j[1];
  var filterRef = (0, import_react98.useRef)(filter);
  var _k = (0, import_react98.useState)({}), displayedFilters = _k[0], setDisplayedFilters = _k[1];
  var _l = (0, import_react98.useState)(filter), filterValues = _l[0], setFilterValues = _l[1];
  var hideFilter = (0, import_react98.useCallback)(function(filterName) {
    setDisplayedFilters(function(previousState) {
      var _a12 = previousState, _b2 = filterName, _ = _a12[_b2], newState = __rest34(_a12, [typeof _b2 === "symbol" ? _b2 : _b2 + ""]);
      return newState;
    });
    setFilterValues(function(previousState) {
      var _a12 = previousState, _b2 = filterName, _ = _a12[_b2], newState = __rest34(_a12, [typeof _b2 === "symbol" ? _b2 : _b2 + ""]);
      return newState;
    });
  }, [setDisplayedFilters, setFilterValues]);
  var showFilter = (0, import_react98.useCallback)(function(filterName, defaultValue) {
    setDisplayedFilters(function(previousState) {
      var _a12;
      return __assign34(__assign34({}, previousState), (_a12 = {}, _a12[filterName] = true, _a12));
    });
    setFilterValues(function(previousState) {
      var _a12;
      return __assign34(__assign34({}, previousState), (_a12 = {}, _a12[filterName] = defaultValue, _a12));
    });
  }, [setDisplayedFilters, setFilterValues]);
  var debouncedSetFilters = (0, import_react98.useCallback)((0, import_debounce4.default)(function(filters, displayedFilters2) {
    setFilterValues(removeEmpty_default(filters));
    setDisplayedFilters(displayedFilters2);
    setPage(1);
  }, debounce5), [setDisplayedFilters, setFilterValues, setPage]);
  var setFilters = (0, import_react98.useCallback)(function(filters, displayedFilters2, debounce6) {
    if (debounce6 === void 0) {
      debounce6 = false;
    }
    if (debounce6) {
      debouncedSetFilters(filters, displayedFilters2);
    } else {
      setFilterValues(removeEmpty_default(filters));
      setDisplayedFilters(displayedFilters2);
      setPage(1);
    }
  }, [setDisplayedFilters, setFilterValues, setPage, debouncedSetFilters]);
  (0, import_react98.useEffect)(function() {
    if (!(0, import_isEqual4.default)(filter, filterRef.current)) {
      filterRef.current = filter;
      setFilterValues(filter);
    }
  }, [filter]);
  var _m = useGetManyReference(reference, {
    target,
    id: (0, import_get6.default)(record, source),
    pagination: { page, perPage },
    sort,
    filter: filterValues,
    meta
  }, __assign34({ enabled: (0, import_get6.default)(record, source) != null, placeholderData: function(previousData) {
    return previousData;
  }, onError: function(error2) {
    return notify(typeof error2 === "string" ? error2 : (error2 === null || error2 === void 0 ? void 0 : error2.message) || "ra.notification.http_error", {
      type: "error",
      messageArgs: {
        _: typeof error2 === "string" ? error2 : (error2 === null || error2 === void 0 ? void 0 : error2.message) ? error2.message : void 0
      }
    });
  } }, otherQueryOptions)), data = _m.data, total = _m.total, responseMeta = _m.meta, pageInfo = _m.pageInfo, error = _m.error, isFetching = _m.isFetching, isLoading = _m.isLoading, isPending = _m.isPending, refetch2 = _m.refetch;
  var onSelectAll = useEvent(function(_a12) {
    var _b2 = _a12 === void 0 ? {} : _a12, _c2 = _b2.limit, limit = _c2 === void 0 ? 250 : _c2, _d2 = _b2.queryOptions, queryOptions3 = _d2 === void 0 ? {} : _d2;
    return __awaiter12(void 0, void 0, void 0, function() {
      var meta2, onSuccess, onError, results, allIds, error_1;
      var _e2;
      return __generator12(this, function(_f2) {
        switch (_f2.label) {
          case 0:
            meta2 = queryOptions3.meta, onSuccess = queryOptions3.onSuccess, onError = queryOptions3.onError;
            _f2.label = 1;
          case 1:
            _f2.trys.push([1, 3, , 4]);
            return [4, queryClient.fetchQuery({
              queryKey: [
                resource,
                "getManyReference",
                {
                  target,
                  id: (0, import_get6.default)(record, source),
                  pagination: { page: 1, perPage: limit },
                  sort,
                  filter,
                  meta: meta2
                }
              ],
              queryFn: function() {
                return dataProvider.getManyReference(reference, {
                  target,
                  id: (0, import_get6.default)(record, source),
                  pagination: { page: 1, perPage: limit },
                  sort,
                  filter,
                  meta: meta2
                });
              }
            })];
          case 2:
            results = _f2.sent();
            allIds = ((_e2 = results.data) === null || _e2 === void 0 ? void 0 : _e2.map(function(_a13) {
              var id = _a13.id;
              return id;
            })) || [];
            selectionModifiers.select(allIds);
            if (allIds.length === limit) {
              notify("ra.message.select_all_limit_reached", {
                messageArgs: { max: limit },
                type: "warning"
              });
            }
            if (onSuccess) {
              onSuccess(results);
            }
            return [2, results.data];
          case 3:
            error_1 = _f2.sent();
            if (onError) {
              onError(error_1);
            }
            notify("ra.notification.http_error", { type: "warning" });
            return [3, 4];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
  return {
    sort,
    data,
    meta: responseMeta,
    defaultTitle: void 0,
    displayedFilters,
    error,
    filterValues,
    hideFilter,
    isFetching,
    isLoading,
    isPending,
    onSelect: selectionModifiers.select,
    onSelectAll,
    onToggleItem: selectionModifiers.toggle,
    onUnselectItems: selectionModifiers.clearSelection,
    page,
    perPage,
    refetch: refetch2,
    resource: reference,
    selectedIds,
    setFilters,
    setPage,
    setPerPage,
    hasNextPage: pageInfo ? pageInfo.hasNextPage : total != null ? page * perPage < total : void 0,
    hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : page > 1,
    setSort,
    showFilter,
    total
  };
};
var defaultFilter4 = {};

// node_modules/ra-core/dist/esm/controller/field/useReferenceOneFieldController.js
var import_get7 = __toESM(require_get());
var __assign35 = function() {
  __assign35 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign35.apply(this, arguments);
};
var __rest35 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useReferenceOneFieldController = function(props) {
  var reference = props.reference, record = props.record, target = props.target, _a11 = props.source, source = _a11 === void 0 ? "id" : _a11, _b = props.sort, sort = _b === void 0 ? { field: "id", order: "ASC" } : _b, _c = props.filter, filter = _c === void 0 ? {} : _c, _d = props.queryOptions, queryOptions2 = _d === void 0 ? {} : _d;
  var notify = useNotify();
  var meta = queryOptions2.meta, otherQueryOptions = __rest35(queryOptions2, ["meta"]);
  var _e = useGetManyReference(reference, {
    target,
    id: (0, import_get7.default)(record, source),
    pagination: { page: 1, perPage: 1 },
    sort,
    filter,
    meta
  }, __assign35({ enabled: !!record, onError: function(error2) {
    return notify(typeof error2 === "string" ? error2 : error2.message || "ra.notification.http_error", {
      type: "error",
      messageArgs: {
        _: typeof error2 === "string" ? error2 : (error2 === null || error2 === void 0 ? void 0 : error2.message) ? error2.message : void 0
      }
    });
  } }, otherQueryOptions)), data = _e.data, error = _e.error, isFetching = _e.isFetching, isLoading = _e.isLoading, isPending = _e.isPending, refetch2 = _e.refetch;
  return {
    referenceRecord: data ? data[0] : void 0,
    error,
    isFetching,
    isLoading,
    isPending,
    refetch: refetch2
  };
};

// node_modules/ra-core/dist/esm/controller/input/referenceDataStatus.js
var isMatchingReferencesError = function(matchingReferences) {
  return matchingReferences && matchingReferences.error !== void 0;
};
var getStatusForInput = function(_a11) {
  var field = _a11.field, matchingReferences = _a11.matchingReferences, referenceRecord = _a11.referenceRecord, _b = _a11.translate, translate = _b === void 0 ? function(x) {
    return x;
  } : _b;
  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {
    _: matchingReferences.error
  }) : null;
  var selectedReferenceError = field.value && !referenceRecord ? translate("ra.input.references.single_missing", {
    _: "ra.input.references.single_missing"
  }) : null;
  return {
    waiting: field.value && selectedReferenceError && !matchingReferences || !field.value && !matchingReferences,
    error: field.value && selectedReferenceError && matchingReferencesError || !field.value && matchingReferencesError ? field.value ? selectedReferenceError : matchingReferencesError : null,
    warning: selectedReferenceError || matchingReferencesError,
    choices: Array.isArray(matchingReferences) ? matchingReferences : [referenceRecord].filter(function(choice) {
      return choice;
    })
  };
};
var REFERENCES_STATUS_READY = "REFERENCES_STATUS_READY";
var REFERENCES_STATUS_INCOMPLETE = "REFERENCES_STATUS_INCOMPLETE";
var REFERENCES_STATUS_EMPTY = "REFERENCES_STATUS_EMPTY";
var getSelectedReferencesStatus = function(field, referenceRecords) {
  return !field.value || field.value.length === referenceRecords.length ? REFERENCES_STATUS_READY : referenceRecords.length > 0 ? REFERENCES_STATUS_INCOMPLETE : REFERENCES_STATUS_EMPTY;
};
var getStatusForArrayInput = function(_a11) {
  var field = _a11.field, matchingReferences = _a11.matchingReferences, referenceRecords = _a11.referenceRecords, _b = _a11.translate, translate = _b === void 0 ? function(x) {
    return x;
  } : _b;
  var selectedReferencesDataStatus = getSelectedReferencesStatus(field, referenceRecords);
  var matchingReferencesError = isMatchingReferencesError(matchingReferences) ? translate(matchingReferences.error, {
    _: matchingReferences.error
  }) : null;
  var choices2 = Array.isArray(matchingReferences) ? referenceRecords.concat(matchingReferences.filter(function(choice) {
    return referenceRecords.findIndex(function(c) {
      return c.id === choice.id;
    }) === -1;
  })) : referenceRecords;
  return {
    waiting: !matchingReferences && field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY || !matchingReferences && !field.value,
    error: matchingReferencesError && (!field.value || field.value && selectedReferencesDataStatus === REFERENCES_STATUS_EMPTY) ? translate("ra.input.references.all_missing", {
      _: "ra.input.references.all_missing"
    }) : null,
    warning: matchingReferencesError || field.value && selectedReferencesDataStatus !== REFERENCES_STATUS_READY ? matchingReferencesError || translate("ra.input.references.many_missing", {
      _: "ra.input.references.many_missing"
    }) : null,
    choices: choices2
  };
};

// node_modules/ra-core/dist/esm/controller/input/useReferenceArrayInputController.js
var import_react101 = __toESM(require_react());

// node_modules/react-hook-form/dist/index.esm.mjs
var import_react99 = __toESM(require_react(), 1);
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
var isObjectType = (value) => typeof value === "object";
var isObject2 = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject2(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject2 = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject2(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray2 = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray2 || isObject2(data))) {
    copy = isArray2 ? [] : {};
    if (!isArray2 && !isPlainObject2(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get7 = (object, path, defaultValue) => {
  if (!path || !isObject2(object)) {
    return defaultValue;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set4 = (object, path, value) => {
  let index = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index < length) {
    const key = tempPath[index];
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = object[key];
      newValue = isObject2(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
};
var EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
var VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
var INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
var HookFormContext = import_react99.default.createContext(null);
var useFormContext = () => import_react99.default.useContext(HookFormContext);
var FormProvider = (props) => {
  const { children, ...data } = props;
  return import_react99.default.createElement(HookFormContext.Provider, { value: data }, children);
};
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value) => isObject2(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = import_react99.default.useRef(props);
  _props.current = props;
  import_react99.default.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = import_react99.default.useState(control._formState);
  const _mounted = import_react99.default.useRef(true);
  const _localProxyFormState = import_react99.default.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = import_react99.default.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: (value) => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value
    }),
    subject: control._subjects.state
  });
  import_react99.default.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return import_react99.default.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get7(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get7(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const _name = import_react99.default.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = import_react99.default.useState(control._getWatch(name, defaultValue));
  import_react99.default.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get7(control._formValues, name, get7(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _registerProps = import_react99.default.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  const fieldState = import_react99.default.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get7(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get7(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get7(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get7(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get7(formState.errors, name)
    }
  }), [formState, name]);
  const field = import_react99.default.useMemo(() => ({
    name,
    value,
    ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange: (event) => _registerProps.current.onChange({
      target: {
        value: getEventValue(event),
        name
      },
      type: EVENTS.CHANGE
    }),
    onBlur: () => _registerProps.current.onBlur({
      target: {
        value: get7(control._formValues, name),
        name
      },
      type: EVENTS.BLUR
    }),
    ref: (elm) => {
      const field2 = get7(control._fields, name);
      if (field2 && elm) {
        field2._f.ref = {
          focus: () => elm.focus(),
          select: () => elm.select(),
          setCustomValidity: (message2) => elm.setCustomValidity(message2),
          reportValidity: () => elm.reportValidity()
        };
      }
    }
  }), [
    name,
    control._formValues,
    disabled,
    formState.disabled,
    value,
    control._fields
  ]);
  import_react99.default.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name2, value2) => {
      const field2 = get7(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get7(control._options.defaultValues, name));
      set4(control._defaultValues, name, value2);
      if (isUndefined(get7(control._formValues, name))) {
        set4(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  import_react99.default.useEffect(() => {
    control._updateDisabledField({
      disabled,
      fields: control._fields,
      name
    });
  }, [disabled, name, control]);
  return import_react99.default.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
var appendErrors = (name, validateAllFieldCriteria, errors, type, message2) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message2 || true
  }
} : {};
var generateId = () => {
  const d = typeof performance === "undefined" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16 + d) % 16 | 0;
    return (c == "x" ? r : r & 3 | 8).toString(16);
  });
};
var getFocusFieldName = (name, index, options = {}) => options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.` : "";
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
var iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get7(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject2(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get7(errors, name));
  set4(fieldArrayErrors, "root", error[name]);
  set4(errors, name, fieldArrayErrors);
  return errors;
};
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value) => isString(value);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value) => value instanceof RegExp;
var defaultResult = {
  value: false,
  isValid: false
};
var validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject2(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required: required2, maxLength: maxLength2, minLength: minLength2, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount } = field._f;
  const inputValue = get7(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message2) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message2) ? "" : message2 || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty3 = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message2 = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message: message2,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message2)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required2 && (!isRadioOrCheckbox2 && (isEmpty3 || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message: message2 } = isMessage(required2) ? { value: !!required2, message: required2 } : getValueAndMessage(required2);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message: message2,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (!isEmpty3 && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength2 || minLength2) && !isEmpty3 && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength2);
    const minLengthOutput = getValueAndMessage(minLength2);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty3 && isString(inputValue)) {
    const { value: patternValue, message: message2 } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message: message2,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message2)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message2);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject2(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var appendAt = (data, value) => [
  ...data,
  ...convertToArrayPayload(value)
];
var fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => void 0) : void 0;
function insert(data, index, value) {
  return [
    ...data.slice(0, index),
    ...convertToArrayPayload(value),
    ...data.slice(index)
  ];
}
var moveArrayAt = (data, from, to) => {
  if (!Array.isArray(data)) {
    return [];
  }
  if (isUndefined(data[to])) {
    data[to] = void 0;
  }
  data.splice(to, 0, data.splice(from, 1)[0]);
  return data;
};
var prependAt = (data, value) => [
  ...convertToArrayPayload(value),
  ...convertToArrayPayload(data)
];
function removeAtIndexes(data, indexes) {
  let i = 0;
  const temp = [...data];
  for (const index of indexes) {
    temp.splice(index - i, 1);
    i++;
  }
  return compact(temp).length ? temp : [];
}
var removeArrayAt = (data, index) => isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));
var swapArrayAt = (data, indexA, indexB) => {
  [data[indexA], data[indexB]] = [data[indexB], data[indexA]];
};
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index = 0;
  while (index < length) {
    object = isUndefined(object) ? index++ : object[updatePath[index++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset2(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index = paths.length - 1;
  const key = paths[index];
  if (childObject) {
    delete childObject[key];
  }
  if (index !== 0 && (isObject2(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset2(object, paths.slice(0, -1));
  }
  return object;
}
var updateAt = (fieldValues, index, value) => {
  fieldValues[index] = value;
  return fieldValues;
};
function useFieldArray(props) {
  const methods = useFormContext();
  const { control = methods.control, name, keyName = "id", shouldUnregister, rules } = props;
  const [fields, setFields] = import_react99.default.useState(control._getFieldArray(name));
  const ids = import_react99.default.useRef(control._getFieldArray(name).map(generateId));
  const _fieldIds = import_react99.default.useRef(fields);
  const _name = import_react99.default.useRef(name);
  const _actioned = import_react99.default.useRef(false);
  _name.current = name;
  _fieldIds.current = fields;
  control._names.array.add(name);
  rules && control.register(name, rules);
  useSubscribe({
    next: ({ values, name: fieldArrayName }) => {
      if (fieldArrayName === _name.current || !fieldArrayName) {
        const fieldValues = get7(values, _name.current);
        if (Array.isArray(fieldValues)) {
          setFields(fieldValues);
          ids.current = fieldValues.map(generateId);
        }
      }
    },
    subject: control._subjects.array
  });
  const updateValues = import_react99.default.useCallback((updatedFieldArrayValues) => {
    _actioned.current = true;
    control._updateFieldArray(name, updatedFieldArrayValues);
  }, [control, name]);
  const append = (value, options) => {
    const appendValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);
    control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);
    ids.current = appendAt(ids.current, appendValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {
      argA: fillEmptyArray(value)
    });
  };
  const prepend = (value, options) => {
    const prependValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);
    control._names.focus = getFocusFieldName(name, 0, options);
    ids.current = prependAt(ids.current, prependValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {
      argA: fillEmptyArray(value)
    });
  };
  const remove = (index) => {
    const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);
    ids.current = removeArrayAt(ids.current, index);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    !Array.isArray(get7(control._fields, name)) && set4(control._fields, name, void 0);
    control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {
      argA: index
    });
  };
  const insert$1 = (index, value, options) => {
    const insertValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);
    control._names.focus = getFocusFieldName(name, index, options);
    ids.current = insert(ids.current, index, insertValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, insert, {
      argA: index,
      argB: fillEmptyArray(value)
    });
  };
  const swap = (indexA, indexB) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    swapArrayAt(updatedFieldArrayValues, indexA, indexB);
    swapArrayAt(ids.current, indexA, indexB);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {
      argA: indexA,
      argB: indexB
    }, false);
  };
  const move = (from, to) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    moveArrayAt(updatedFieldArrayValues, from, to);
    moveArrayAt(ids.current, from, to);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {
      argA: from,
      argB: to
    }, false);
  };
  const update = (index, value) => {
    const updateValue = cloneObject(value);
    const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);
    ids.current = [...updatedFieldArrayValues].map((item, i) => !item || i === index ? generateId() : ids.current[i]);
    updateValues(updatedFieldArrayValues);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {
      argA: index,
      argB: updateValue
    }, true, false);
  };
  const replace = (value) => {
    const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));
    ids.current = updatedFieldArrayValues.map(generateId);
    updateValues([...updatedFieldArrayValues]);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name, [...updatedFieldArrayValues], (data) => data, {}, true, false);
  };
  import_react99.default.useEffect(() => {
    control._state.action = false;
    isWatched(name, control._names) && control._subjects.state.next({
      ...control._formState
    });
    if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {
      if (control._options.resolver) {
        control._executeSchema([name]).then((result) => {
          const error = get7(result.errors, name);
          const existingError = get7(control._formState.errors, name);
          if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {
            error ? set4(control._formState.errors, name, error) : unset2(control._formState.errors, name);
            control._subjects.state.next({
              errors: control._formState.errors
            });
          }
        });
      } else {
        const field = get7(control._fields, name);
        if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {
          validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error) => !isEmptyObject(error) && control._subjects.state.next({
            errors: updateFieldArrayRootError(control._formState.errors, error, name)
          }));
        }
      }
    }
    control._subjects.values.next({
      name,
      values: { ...control._formValues }
    });
    control._names.focus && iterateFieldsByAction(control._fields, (ref, key) => {
      if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {
        ref.focus();
        return 1;
      }
      return;
    });
    control._names.focus = "";
    control._updateValid();
    _actioned.current = false;
  }, [fields, name, control]);
  import_react99.default.useEffect(() => {
    !get7(control._formValues, name) && control._updateFieldArray(name);
    return () => {
      (control._options.shouldUnregister || shouldUnregister) && control.unregister(name);
    };
  }, [name, control, keyName, shouldUnregister]);
  return {
    swap: import_react99.default.useCallback(swap, [updateValues, name, control]),
    move: import_react99.default.useCallback(move, [updateValues, name, control]),
    prepend: import_react99.default.useCallback(prepend, [updateValues, name, control]),
    append: import_react99.default.useCallback(append, [updateValues, name, control]),
    remove: import_react99.default.useCallback(remove, [updateValues, name, control]),
    insert: import_react99.default.useCallback(insert$1, [updateValues, name, control]),
    update: import_react99.default.useCallback(update, [updateValues, name, control]),
    replace: import_react99.default.useCallback(replace, [updateValues, name, control]),
    fields: import_react99.default.useMemo(() => fields.map((field, index) => ({
      ...field,
      [keyName]: ids.current[index] || generateId()
    })), [fields, keyName])
  };
}
var createSubject = () => {
  let _observers2 = [];
  const next = (value) => {
    for (const observer of _observers2) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers2.push(observer);
    return {
      unsubscribe: () => {
        _observers2 = _observers2.filter((o) => o !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers2 = [];
  };
  return {
    get observers() {
      return _observers2;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject2(val1) && isObject2(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject2(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject2(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject2(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject2(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get7(_fields, name);
    field && set4(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject2(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject2(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get7(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get7(_fields, fieldName);
    const foundError = get7(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get7(ref, name)).length && unset2(ref, name);
var defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject2(_options.defaultValues) || isObject2(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer2 = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce5 = (callback) => (wait) => {
    clearTimeout(timer2);
    timer2 = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
      const isValid2 = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set4(_formState.validatingFields, name, isValidating) : unset2(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get7(_fields, name))) {
        const fieldValues = method(get7(_fields, name), args.argA, args.argB);
        shouldSetValues && set4(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get7(_formState.errors, name))) {
        const errors = method(get7(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set4(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get7(_formState.touchedFields, name))) {
        const touchedFields = method(get7(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set4(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set4(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set4(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get7(_fields, name);
    if (field) {
      const defaultValue = get7(_formValues, name, isUndefined(value) ? get7(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set4(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!_options.disabled) {
      const disabledField = !!(get7(_fields, name) && get7(_fields, name)._f && get7(_fields, name)._f.disabled);
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = disabledField || deepEqual(get7(_defaultValues, name), fieldValue);
        isPreviousDirty = !!(!disabledField && get7(_formState.dirtyFields, name));
        isCurrentFieldPristine || disabledField ? unset2(_formState.dirtyFields, name) : set4(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get7(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set4(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid2, error, fieldState) => {
    const previousFieldError = get7(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid2) && _formState.isValid !== isValid2;
    if (_options.delayError && error) {
      delayErrorCallback = debounce5(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer2);
      delayErrorCallback = null;
      error ? set4(_formState.errors, name, error) : unset2(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema(names);
    if (names) {
      for (const name of names) {
        const error = get7(errors, name);
        error ? set4(_formState.errors, name, error) : unset2(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get7(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set4(_formState.errors, _f.name, fieldError[_f.name]) : unset2(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get7(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set4(_formValues, name, data), !deepEqual(getValues2(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get7(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get7(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get7(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set4(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get7(_fields, fieldName);
      (_names.array.has(name) || isObject2(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get7(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set4(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name : void 0,
      values: { ..._formValues }
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get7(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get7(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid2;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get7(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get7(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set4(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (_options.mode === "onBlur" && isBlurEvent) {
            _updateValid();
          } else if (!isBlurEvent) {
            _updateValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid2 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid2 = false;
          } else if (_proxyFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid2, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get7(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get7(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get7(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || _proxyFormState.isValid && isValid2 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid2 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues2 = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get7(values, fieldNames) : fieldNames.map((name) => get7(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get7((formState || _formState).errors, name),
    isDirty: !!get7((formState || _formState).dirtyFields, name),
    error: get7((formState || _formState).errors, name),
    isValidating: !!get7(_formState.validatingFields, name),
    isTouched: !!get7((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset2(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get7(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get7(_formState.errors, name) || {};
    const { ref: currentRef, message: message2, type, ...restOfErrorTree } = currentError;
    set4(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset2(_fields, fieldName);
        unset2(_formValues, fieldName);
      }
      !options.keepError && unset2(_formState.errors, fieldName);
      !options.keepDirty && unset2(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset2(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset2(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset2(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = ({ disabled, name, field, fields }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
      updateTouchAndDirty(name, getFieldValue(field ? field._f : get7(fields, name)._f), false, false, true);
    }
  };
  const register = (name, options = {}) => {
    let field = get7(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
    set4(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get7(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set4(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get7(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get7(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get7(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e) => {
    let onValidError = void 0;
    if (e) {
      e.preventDefault && e.preventDefault();
      e.persist && e.persist();
    }
    let fieldValues = cloneObject(_formValues);
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        set4(fieldValues, name, void 0);
      }
    }
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset2(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get7(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get7(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set4(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset2(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset2(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get7(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset2(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get7(_formState.dirtyFields, fieldName) ? set4(values, fieldName, get7(_formValues, fieldName)) : setValue(fieldName, get7(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get7(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = _options.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.values.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get7(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues: getValues2,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = import_react99.default.useRef(void 0);
  const _values = import_react99.default.useRef(void 0);
  const [formState, updateFormState] = import_react99.default.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  import_react99.default.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  import_react99.default.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty = control._getDirty();
      if (isDirty !== formState.isDirty) {
        control._subjects.state.next({
          isDirty
        });
      }
    }
  }, [control, formState.isDirty]);
  import_react99.default.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  import_react99.default.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  import_react99.default.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  import_react99.default.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}

// node_modules/ra-core/dist/esm/controller/input/useReferenceParams.js
var import_react100 = __toESM(require_react());
var import_debounce5 = __toESM(require_debounce());
var __assign36 = function() {
  __assign36 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign36.apply(this, arguments);
};
var useReferenceParams = function(_a11) {
  var resource = _a11.resource, filter = _a11.filter, _b = _a11.sort, sort = _b === void 0 ? defaultSort4 : _b, _c = _a11.page, page = _c === void 0 ? 1 : _c, _d = _a11.perPage, perPage = _d === void 0 ? 10 : _d, _e = _a11.debounce, debounce5 = _e === void 0 ? 500 : _e;
  var _f = (0, import_react100.useState)(defaultParams2), params = _f[0], setParams = _f[1];
  var tempParams = (0, import_react100.useRef)();
  var requestSignature = [
    resource,
    JSON.stringify(params),
    JSON.stringify(filter),
    JSON.stringify(sort),
    page,
    perPage
  ];
  var query = (0, import_react100.useMemo)(
    function() {
      return getQuery2({
        params,
        filterDefaultValues: filter,
        sort,
        page,
        perPage
      });
    },
    requestSignature
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  var changeParams = (0, import_react100.useCallback)(function(action) {
    if (!tempParams.current) {
      var newTempParams_1 = queryReducer(query, action);
      tempParams.current = newTempParams_1;
      setTimeout(function() {
        setParams(newTempParams_1);
        tempParams.current = void 0;
      }, 0);
    } else {
      tempParams.current = queryReducer(tempParams.current, action);
    }
  }, requestSignature);
  var setSort = (0, import_react100.useCallback)(
    function(sort2) {
      return changeParams({
        type: SET_SORT,
        payload: sort2
      });
    },
    requestSignature
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  var setPage = (0, import_react100.useCallback)(
    function(newPage) {
      return changeParams({ type: SET_PAGE, payload: newPage });
    },
    requestSignature
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  var setPerPage = (0, import_react100.useCallback)(
    function(newPerPage) {
      return changeParams({ type: SET_PER_PAGE, payload: newPerPage });
    },
    requestSignature
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  var filterValues = query.filter || emptyObject2;
  var displayedFilterValues = query.displayedFilters || emptyObject2;
  var debouncedSetFilters = (0, import_react100.useRef)((0, import_debounce5.default)(function(filter2, displayedFilters) {
    if (displayedFilters === void 0) {
      displayedFilters = void 0;
    }
    changeParams({
      type: SET_FILTER,
      payload: {
        filter: removeEmpty_default(filter2),
        displayedFilters
      }
    });
  }, debounce5));
  (0, import_react100.useEffect)(function() {
    return function() {
      debouncedSetFilters.current.cancel();
    };
  }, []);
  var setFilters = (0, import_react100.useCallback)(
    function(filter2, displayedFilters, debounce6) {
      if (displayedFilters === void 0) {
        displayedFilters = void 0;
      }
      if (debounce6 === void 0) {
        debounce6 = false;
      }
      debounce6 ? debouncedSetFilters.current(filter2, displayedFilters) : changeParams({
        type: SET_FILTER,
        payload: {
          filter: removeEmpty_default(filter2),
          displayedFilters
        }
      });
    },
    requestSignature
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  var hideFilter = (0, import_react100.useCallback)(function(filterName) {
    changeParams({
      type: HIDE_FILTER,
      payload: filterName
    });
  }, requestSignature);
  var showFilter = (0, import_react100.useCallback)(function(filterName, defaultValue) {
    changeParams({
      type: SHOW_FILTER,
      payload: {
        filterName,
        defaultValue
      }
    });
  }, requestSignature);
  return [
    __assign36(__assign36({ filterValues, requestSignature }, query), { displayedFilters: displayedFilterValues }),
    {
      changeParams,
      setPage,
      setPerPage,
      setSort,
      setFilters,
      hideFilter,
      showFilter
    }
  ];
};
var getQuery2 = function(_a11) {
  var params = _a11.params, filterDefaultValues = _a11.filterDefaultValues, sort = _a11.sort, page = _a11.page, perPage = _a11.perPage;
  var query = hasCustomParams2(params) ? __assign36({}, params) : { filter: filterDefaultValues || {} };
  if (!query.sort) {
    query.sort = sort.field;
    query.order = sort.order;
  }
  if (query.page == null) {
    query.page = page;
  }
  if (query.perPage == null) {
    query.perPage = perPage;
  }
  if (query.page == null) {
    query.page = 1;
  }
  return __assign36(__assign36({}, query), { page: getNumberOrDefault2(query.page, 1), perPage: getNumberOrDefault2(query.perPage, 10) });
};
var hasCustomParams2 = function(params) {
  return params && params.filter && (Object.keys(params.filter).length > 0 || params.order != null || params.page !== 1 || params.perPage != null || params.sort != null);
};
var getNumberOrDefault2 = function(possibleNumber, defaultValue) {
  if (typeof possibleNumber === "undefined") {
    return defaultValue;
  }
  var parsedNumber = typeof possibleNumber === "string" ? parseInt(possibleNumber, 10) : possibleNumber;
  return isNaN(parsedNumber) ? defaultValue : parsedNumber;
};
var emptyObject2 = {};
var defaultSort4 = {
  field: "id",
  order: SORT_ASC
};
var defaultParams2 = {};

// node_modules/ra-core/dist/esm/controller/input/useReferenceArrayInputController.js
var __assign37 = function() {
  __assign37 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign37.apply(this, arguments);
};
var __rest36 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray18 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useReferenceArrayInputController = function(props) {
  var _a11;
  var debounce5 = props.debounce, enableGetChoices = props.enableGetChoices, filter = props.filter, _b = props.page, initialPage = _b === void 0 ? 1 : _b, _c = props.perPage, initialPerPage = _c === void 0 ? 25 : _c, _d = props.sort, initialSort = _d === void 0 ? { field: "id", order: "DESC" } : _d, _e = props.queryOptions, queryOptions2 = _e === void 0 ? {} : _e, reference = props.reference, source = props.source;
  var getValues2 = useFormContext().getValues;
  var finalSource = useWrappedSource(source);
  var value = (_a11 = useWatch({ name: finalSource })) !== null && _a11 !== void 0 ? _a11 : getValues2(finalSource);
  var meta = queryOptions2.meta, otherQueryOptions = __rest36(queryOptions2, ["meta"]);
  var _f = useGetManyAggregate(reference, {
    ids: value || EmptyArray,
    meta
  }, {
    enabled: value != null && value.length > 0
  }), referenceRecords = _f.data, errorGetMany = _f.error, isLoadingGetMany = _f.isLoading, isFetchingGetMany = _f.isFetching, isPendingGetMany = _f.isPending, refetchGetMany = _f.refetch;
  var _g = useReferenceParams({
    resource: reference,
    page: initialPage,
    perPage: initialPerPage,
    sort: initialSort,
    debounce: debounce5,
    filter
  }), params = _g[0], paramsModifiers = _g[1];
  var finalReferenceRecords = referenceRecords ? referenceRecords.filter(Boolean) : [];
  var isGetMatchingEnabled = enableGetChoices ? enableGetChoices(params.filterValues) : true;
  var _h = useGetList(reference, {
    pagination: {
      page: params.page,
      perPage: params.perPage
    },
    sort: { field: params.sort, order: params.order },
    filter: __assign37(__assign37({}, params.filter), filter),
    meta
  }, __assign37({ retry: false, enabled: isGetMatchingEnabled, placeholderData: function(previousData) {
    return previousData;
  } }, otherQueryOptions)), matchingReferences = _h.data, total = _h.total, pageInfo = _h.pageInfo, errorGetList = _h.error, isLoadingGetList = _h.isLoading, isFetchingGetList = _h.isFetching, isPendingGetList = _h.isPending, refetchGetMatching = _h.refetch;
  var finalMatchingReferences = matchingReferences && matchingReferences.length > 0 ? mergeReferences(matchingReferences, finalReferenceRecords) : finalReferenceRecords.length > 0 ? finalReferenceRecords : matchingReferences;
  var refetch2 = (0, import_react101.useCallback)(function() {
    refetchGetMany();
    refetchGetMatching();
  }, [refetchGetMany, refetchGetMatching]);
  var currentSort = (0, import_react101.useMemo)(function() {
    return {
      field: params.sort,
      order: params.order
    };
  }, [params.sort, params.order]);
  return {
    sort: currentSort,
    allChoices: finalMatchingReferences,
    availableChoices: matchingReferences,
    selectedChoices: finalReferenceRecords,
    displayedFilters: params.displayedFilters,
    error: errorGetMany || errorGetList,
    filter,
    filterValues: params.filterValues,
    hideFilter: paramsModifiers.hideFilter,
    isFetching: isFetchingGetMany || isFetchingGetList,
    isLoading: isLoadingGetMany || isLoadingGetList,
    isPending: isPendingGetMany || isPendingGetList,
    page: params.page,
    perPage: params.perPage,
    refetch: refetch2,
    resource: reference,
    setFilters: paramsModifiers.setFilters,
    setPage: paramsModifiers.setPage,
    setPerPage: paramsModifiers.setPerPage,
    setSort: paramsModifiers.setSort,
    showFilter: paramsModifiers.showFilter,
    // we return source and not finalSource because child inputs (e.g. AutocompleteArrayInput) already call useInput and compute the final source
    source,
    total,
    hasNextPage: pageInfo ? pageInfo.hasNextPage : total != null ? params.page * params.perPage < total : void 0,
    hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,
    isFromReference: true
  };
};
var EmptyArray = [];
var mergeReferences = function(ref1, ref2) {
  var res = __spreadArray18([], ref1, true);
  var ids = ref1.map(function(ref) {
    return ref.id;
  });
  ref2.forEach(function(ref) {
    if (!ids.includes(ref.id)) {
      ids.push(ref.id);
      res.push(ref);
    }
  });
  return res;
};

// node_modules/ra-core/dist/esm/controller/input/useReferenceInputController.js
var import_react102 = __toESM(require_react());
var __assign38 = function() {
  __assign38 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign38.apply(this, arguments);
};
var __rest37 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var __spreadArray19 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useReferenceInputController = function(props) {
  var debounce5 = props.debounce, enableGetChoices = props.enableGetChoices, filter = props.filter, _a11 = props.page, initialPage = _a11 === void 0 ? 1 : _a11, _b = props.perPage, initialPerPage = _b === void 0 ? 25 : _b, initialSort = props.sort, _c = props.queryOptions, queryOptions2 = _c === void 0 ? {} : _c, reference = props.reference, source = props.source;
  var meta = queryOptions2.meta, otherQueryOptions = __rest37(queryOptions2, ["meta"]);
  var _d = useReferenceParams({
    resource: reference,
    page: initialPage,
    perPage: initialPerPage,
    sort: initialSort,
    debounce: debounce5,
    filter
  }), params = _d[0], paramsModifiers = _d[1];
  var finalSource = useWrappedSource(source);
  var currentValue = useWatch({ name: finalSource });
  var isGetMatchingEnabled = enableGetChoices ? enableGetChoices(params.filterValues) : true;
  var _e = useGetList(reference, {
    pagination: {
      page: params.page,
      perPage: params.perPage
    },
    sort: { field: params.sort, order: params.order },
    filter: __assign38(__assign38({}, params.filter), filter),
    meta
  }, __assign38({ enabled: isGetMatchingEnabled, placeholderData: function(previousData) {
    return previousData;
  } }, otherQueryOptions)), _f = _e.data, possibleValuesData = _f === void 0 ? [] : _f, total = _e.total, pageInfo = _e.pageInfo, isFetchingPossibleValues = _e.isFetching, isLoadingPossibleValues = _e.isLoading, isPendingPossibleValues = _e.isPending, errorPossibleValues = _e.error, refetchGetList = _e.refetch;
  var _g = useReference({
    id: currentValue,
    reference,
    // @ts-ignore the types of the queryOptions for the getMAny and getList are not compatible
    options: __assign38({ enabled: currentValue != null && currentValue !== "", meta }, otherQueryOptions)
  }), currentReferenceRecord = _g.referenceRecord, refetchReference = _g.refetch, errorReference = _g.error, isLoadingReference = _g.isLoading, isFetchingReference = _g.isFetching, isPendingReference = _g.isPending;
  var isPending = (
    // The reference query isn't enabled when there is no value yet but as it has no data, react-query will flag it as pending
    currentValue != null && currentValue !== "" && isPendingReference || isPendingPossibleValues
  );
  var _h = (0, import_react102.useState)(void 0), referenceRecord = _h[0], setReferenceRecord = _h[1];
  (0, import_react102.useEffect)(function() {
    setReferenceRecord(currentReferenceRecord);
  }, [currentReferenceRecord]);
  var finalData, finalTotal;
  if (!referenceRecord || possibleValuesData.find(function(record) {
    return record.id === referenceRecord.id;
  })) {
    finalData = possibleValuesData;
    finalTotal = total;
  } else {
    finalData = __spreadArray19([referenceRecord], possibleValuesData, true);
    finalTotal = total == null ? void 0 : total + 1;
  }
  var refetch2 = (0, import_react102.useCallback)(function() {
    refetchGetList();
    refetchReference();
  }, [refetchGetList, refetchReference]);
  var currentSort = (0, import_react102.useMemo)(function() {
    return {
      field: params.sort,
      order: params.order
    };
  }, [params.sort, params.order]);
  return {
    sort: currentSort,
    allChoices: finalData,
    availableChoices: possibleValuesData,
    selectedChoices: referenceRecord ? [referenceRecord] : [],
    displayedFilters: params.displayedFilters,
    error: errorReference || errorPossibleValues,
    filter: params.filter,
    filterValues: params.filterValues,
    hideFilter: paramsModifiers.hideFilter,
    isFetching: isFetchingReference || isFetchingPossibleValues,
    isLoading: isLoadingReference || isLoadingPossibleValues,
    isPending,
    page: params.page,
    perPage: params.perPage,
    refetch: refetch2,
    resource: reference,
    setFilters: paramsModifiers.setFilters,
    setPage: paramsModifiers.setPage,
    setPerPage: paramsModifiers.setPerPage,
    setSort: paramsModifiers.setSort,
    showFilter: paramsModifiers.showFilter,
    // we return source and not finalSource because child inputs (e.g. AutocompleteInput) already call useInput and compute the final source
    source,
    total: finalTotal,
    hasNextPage: pageInfo ? pageInfo.hasNextPage : total != null ? params.page * params.perPage < total : void 0,
    hasPreviousPage: pageInfo ? pageInfo.hasPreviousPage : params.page > 1,
    isFromReference: true
  };
};

// node_modules/ra-core/dist/esm/controller/input/ReferenceInputBase.js
var import_react123 = __toESM(require_react());

// node_modules/ra-core/dist/esm/form/choices/ChoicesContext.js
var import_react103 = __toESM(require_react());
var ChoicesContext = (0, import_react103.createContext)(void 0);

// node_modules/ra-core/dist/esm/form/choices/ChoicesContextProvider.js
var React37 = __toESM(require_react());
var ChoicesContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React37.createElement(ChoicesContext.Provider, { value }, children);
};

// node_modules/ra-core/dist/esm/form/choices/useChoicesContext.js
var import_react104 = __toESM(require_react());
var __rest38 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useChoicesContext = function(options) {
  var _a11, _b, _c;
  if (options === void 0) {
    options = {};
  }
  var context = (0, import_react104.useContext)(ChoicesContext);
  var choices2 = options.choices && isArrayOfStrings(options.choices) ? convertOptionsToChoices(options.choices) : options.choices;
  var _d = useList({
    data: choices2,
    isLoading: (_a11 = options.isLoading) !== null && _a11 !== void 0 ? _a11 : false,
    isPending: (_b = options.isPending) !== null && _b !== void 0 ? _b : false,
    isFetching: (_c = options.isFetching) !== null && _c !== void 0 ? _c : false,
    error: options.error,
    // When not in a ChoicesContext, paginating does not make sense (e.g. AutocompleteInput).
    perPage: Infinity
  }), data = _d.data, list = __rest38(_d, ["data"]);
  var result = (0, import_react104.useMemo)(function() {
    var _a12, _b2, _c2, _d2, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    if (options.choices || !context) {
      return {
        allChoices: data,
        availableChoices: (_a12 = options.availableChoices) !== null && _a12 !== void 0 ? _a12 : data,
        selectedChoices: (_b2 = options.selectedChoices) !== null && _b2 !== void 0 ? _b2 : data,
        displayedFilters: (_c2 = options.selectedChoices) !== null && _c2 !== void 0 ? _c2 : list.displayedFilters,
        error: options.error,
        filter: (_d2 = options.filter) !== null && _d2 !== void 0 ? _d2 : list.filter,
        filterValues: (_e = options.filterValues) !== null && _e !== void 0 ? _e : list.filterValues,
        hasNextPage: (_f = options.hasNextPage) !== null && _f !== void 0 ? _f : list.hasNextPage,
        hasPreviousPage: (_g = options.hasPreviousPage) !== null && _g !== void 0 ? _g : list.hasPreviousPage,
        hideFilter: (_h = options.hideFilter) !== null && _h !== void 0 ? _h : list.hideFilter,
        isLoading: (_j = list.isLoading) !== null && _j !== void 0 ? _j : false,
        isPending: (_k = list.isPending) !== null && _k !== void 0 ? _k : false,
        isFetching: (_l = list.isFetching) !== null && _l !== void 0 ? _l : false,
        page: (_m = options.page) !== null && _m !== void 0 ? _m : list.page,
        perPage: (_o = options.perPage) !== null && _o !== void 0 ? _o : list.perPage,
        refetch: (_p = options.refetch) !== null && _p !== void 0 ? _p : list.refetch,
        resource: (_q = options.resource) !== null && _q !== void 0 ? _q : list.resource,
        setFilters: (_r = options.setFilters) !== null && _r !== void 0 ? _r : list.setFilters,
        setPage: (_s = options.setPage) !== null && _s !== void 0 ? _s : list.setPage,
        setPerPage: (_t = options.setPerPage) !== null && _t !== void 0 ? _t : list.setPerPage,
        setSort: (_u = options.setSort) !== null && _u !== void 0 ? _u : list.setSort,
        showFilter: (_v = options.showFilter) !== null && _v !== void 0 ? _v : list.showFilter,
        sort: (_w = options.sort) !== null && _w !== void 0 ? _w : list.sort,
        source: options.source,
        total: (_x = options.total) !== null && _x !== void 0 ? _x : list.total,
        isFromReference: false
      };
    }
    return context;
  }, [context, data, list, options]);
  return result;
};
var isArrayOfStrings = function(choices2) {
  return Array.isArray(choices2) && choices2.every(function(choice) {
    return typeof choice === "string";
  });
};
var convertOptionsToChoices = function(options) {
  return options.map(function(choice) {
    return {
      id: choice,
      name: choice
    };
  });
};

// node_modules/ra-core/dist/esm/form/choices/useChoices.js
var React38 = __toESM(require_react());
var import_react105 = __toESM(require_react());
var import_get8 = __toESM(require_get());
var useChoices = function(_a11) {
  var _b = _a11.optionText, optionText = _b === void 0 ? "name" : _b, _c = _a11.optionValue, optionValue = _c === void 0 ? "id" : _c, _d = _a11.disableValue, disableValue = _d === void 0 ? "disabled" : _d, _e = _a11.translateChoice, translateChoice = _e === void 0 ? true : _e;
  var translate = useTranslate();
  var getChoiceText = (0, import_react105.useCallback)(function(choice) {
    if ((0, import_react105.isValidElement)(optionText)) {
      return React38.createElement(RecordContextProvider, { value: choice }, optionText);
    }
    var choiceName = typeof optionText === "function" ? optionText(choice) : (0, import_get8.default)(choice, optionText);
    return (0, import_react105.isValidElement)(choiceName) ? choiceName : translateChoice ? translate(String(choiceName), { _: choiceName }) : String(choiceName);
  }, [optionText, translate, translateChoice]);
  var getChoiceValue = (0, import_react105.useCallback)(function(choice) {
    return (0, import_get8.default)(choice, optionValue);
  }, [optionValue]);
  var getDisableValue = (0, import_react105.useCallback)(function(choice) {
    return (0, import_get8.default)(choice, disableValue);
  }, [disableValue]);
  return {
    getChoiceText,
    getChoiceValue,
    getDisableValue
  };
};

// node_modules/ra-core/dist/esm/form/Form.js
var React40 = __toESM(require_react());
var import_react112 = __toESM(require_react());

// node_modules/ra-core/dist/esm/form/groups/FormGroupsProvider.js
var React39 = __toESM(require_react());
var import_react107 = __toESM(require_react());

// node_modules/ra-core/dist/esm/form/groups/FormGroupsContext.js
var import_react106 = __toESM(require_react());
var FormGroupsContext = (0, import_react106.createContext)(void 0);

// node_modules/ra-core/dist/esm/form/groups/FormGroupsProvider.js
var __spreadArray20 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var FormGroupsProvider = function(_a11) {
  var children = _a11.children;
  var formGroups = (0, import_react107.useRef)({});
  var subscribers = (0, import_react107.useRef)({});
  var formContextValue = (0, import_react107.useMemo)(function() {
    return {
      /**
       * Register a subscriber function for the specified group. The subscriber
       * will be called whenever the group content changes (fields added or removed).
       */
      subscribe: function(group, subscriber) {
        if (!subscribers.current[group]) {
          subscribers.current[group] = [];
        }
        subscribers.current[group].push(subscriber);
        return function() {
          subscribers.current[group] = subscribers.current[group].filter(function(s) {
            return s !== subscriber;
          });
        };
      },
      getGroupFields: function(name) {
        return formGroups.current[name] || [];
      },
      registerGroup: function(name) {
        formGroups.current[name] = formGroups.current[name] || [];
      },
      unregisterGroup: function(name) {
        delete formGroups[name];
      },
      registerField: function(source, group) {
        if (group != null) {
          if (!(formGroups.current[group] || []).includes(source)) {
            formGroups.current[group] = __spreadArray20(__spreadArray20([], formGroups.current[group] || [], true), [
              source
            ], false);
            if (subscribers.current[group]) {
              subscribers.current[group].forEach(function(subscriber) {
                return subscriber();
              });
            }
          }
        }
      },
      unregisterField: function(source, group) {
        if (group != null) {
          if (!formGroups.current[group]) {
            console.warn("Invalid form group ".concat(group));
          } else {
            var fields = new Set(formGroups.current[group]);
            fields.delete(source);
            formGroups.current[group] = Array.from(fields);
            if (subscribers.current[group]) {
              subscribers.current[group].forEach(function(subscriber) {
                return subscriber();
              });
            }
          }
        }
      }
    };
  }, []);
  return React39.createElement(FormGroupsContext.Provider, { value: formContextValue }, children);
};

// node_modules/ra-core/dist/esm/form/useWarnWhenUnsavedChanges.js
var import_react108 = __toESM(require_react());
var useWarnWhenUnsavedChanges = function(enable, formRootPathname, control) {
  var translate = useTranslate();
  var _a11 = useFormState(control ? { control } : void 0), isSubmitSuccessful = _a11.isSubmitSuccessful, dirtyFields = _a11.dirtyFields;
  var isDirty = Object.keys(dirtyFields).length > 0;
  var _b = (0, import_react108.useState)(false), shouldNotify = _b[0], setShouldNotify = _b[1];
  var shouldNotBlock = !enable || !isDirty || isSubmitSuccessful;
  var blocker = useBlocker(function(_a12) {
    var currentLocation = _a12.currentLocation, nextLocation = _a12.nextLocation;
    if (shouldNotBlock)
      return false;
    var initialLocation = formRootPathname || currentLocation.pathname;
    var newLocationIsInsideCurrentLocation = nextLocation.pathname.startsWith(initialLocation);
    var newLocationIsShowView = nextLocation.pathname.startsWith("".concat(initialLocation, "/show"));
    var newLocationIsInsideForm = newLocationIsInsideCurrentLocation && !newLocationIsShowView;
    if (newLocationIsInsideForm)
      return false;
    return true;
  });
  (0, import_react108.useEffect)(function() {
    if (blocker.state === "blocked") {
      if (shouldNotBlock) {
        blocker.proceed();
        return;
      }
      setShouldNotify(true);
    }
  }, [blocker.state]);
  (0, import_react108.useEffect)(function() {
    if (shouldNotify) {
      var shouldProceed = window.confirm(translate("ra.message.unsaved_changes"));
      if (shouldProceed) {
        blocker.proceed && blocker.proceed();
      } else {
        blocker.reset && blocker.reset();
      }
    }
    setShouldNotify(false);
  }, [shouldNotify, translate]);
  (0, import_react108.useEffect)(function() {
    var beforeunload = function(e) {
      e.preventDefault();
      e.returnValue = true;
    };
    if (shouldNotBlock) {
      return;
    }
    window.addEventListener("beforeunload", beforeunload);
    return function() {
      window.removeEventListener("beforeunload", beforeunload);
    };
  }, [shouldNotBlock]);
};

// node_modules/ra-core/dist/esm/form/WarnWhenUnsavedChanges.js
var WarnWhenUnsavedChanges = function(_a11) {
  var _b = _a11.enable, enable = _b === void 0 ? true : _b, formRootPathName = _a11.formRootPathName, formControl = _a11.formControl;
  useWarnWhenUnsavedChanges(enable, formRootPathName, formControl);
  return null;
};

// node_modules/ra-core/dist/esm/form/useAugmentedForm.js
var import_react111 = __toESM(require_react());
var import_merge3 = __toESM(require_merge());

// node_modules/ra-core/dist/esm/form/getFormInitialValues.js
var import_merge2 = __toESM(require_merge());
function getFormInitialValues(defaultValues, record) {
  var finalInitialValues = (0, import_merge2.default)({}, getValues(defaultValues, record), record);
  return finalInitialValues;
}
function getValues(values, record) {
  if (typeof values === "object") {
    return values;
  }
  if (typeof values === "function") {
    return values(record);
  }
  return {};
}

// node_modules/ra-core/dist/esm/form/validation/getSimpleValidationResolver.js
var __assign39 = function() {
  __assign39 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign39.apply(this, arguments);
};
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator13 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var getSimpleValidationResolver = function(validate) {
  return function(data) {
    return __awaiter13(void 0, void 0, void 0, function() {
      var errors, transformedErrors;
      return __generator13(this, function(_a11) {
        switch (_a11.label) {
          case 0:
            return [4, validate(data)];
          case 1:
            errors = _a11.sent();
            if (!errors || isEmptyObject2(errors)) {
              return [2, { values: data, errors: {} }];
            }
            transformedErrors = transformErrorFields(errors);
            if (!transformedErrors || isEmptyObject2(transformedErrors)) {
              return [2, { values: data, errors: {} }];
            }
            return [2, {
              values: {},
              errors: transformedErrors
            }];
        }
      });
    });
  };
};
var transformErrorFields = function(error) {
  return Object.keys(error).reduce(function(acc, field) {
    var _a11, _b, _c;
    if (Array.isArray(error[field])) {
      var arrayHasErrors_1 = false;
      var transformedArrayErrors = error[field].map(function(item) {
        if (!isEmptyObject2(item)) {
          arrayHasErrors_1 = true;
        }
        return transformErrorFields(item);
      });
      if (!arrayHasErrors_1) {
        return acc;
      }
      return __assign39(__assign39({}, acc), (_a11 = {}, _a11[field] = transformedArrayErrors, _a11));
    }
    if (isEmptyObject2(error[field])) {
      return acc;
    }
    if (typeof error[field] === "object" && !isRaTranslationObj(error[field])) {
      return __assign39(__assign39({}, acc), (_b = {}, _b[field] = transformErrorFields(error[field]), _b));
    }
    return __assign39(__assign39({}, acc), (_c = {}, _c[field] = addTypeAndMessage(error[field]), _c));
  }, {});
};
var addTypeAndMessage = function(error) {
  return {
    type: "manual",
    message: isRaTranslationObj(error) ? error : { message: error }
  };
};
var isRaTranslationObj = function(obj) {
  return Object.keys(obj).includes("message") && Object.keys(obj).includes("args");
};
var isEmptyObject2 = function(obj) {
  return obj == null || Object.getOwnPropertyNames(obj).length === 0;
};

// node_modules/ra-core/dist/esm/form/validation/setSubmissionErrors.js
var setSubmissionErrors = function(errors, setError) {
  var setErrorFromObject = function(errors2, rootPath) {
    Object.entries(errors2).forEach(function(_a11) {
      var name = _a11[0], error = _a11[1];
      if (typeof error === "object") {
        setErrorFromObject(error, "".concat(rootPath).concat(name, "."));
        return;
      }
      setError("".concat(rootPath).concat(name), {
        type: "server",
        message: error.toString()
      });
    });
  };
  setErrorFromObject(errors, "");
};

// node_modules/ra-core/dist/esm/form/validation/useNotifyIsFormInvalid.js
var import_react109 = __toESM(require_react());
var useNotifyIsFormInvalid = function(control, enabled) {
  if (enabled === void 0) {
    enabled = true;
  }
  var _a11 = useFormState(control ? { control } : void 0), submitCount = _a11.submitCount, errors = _a11.errors;
  var submitCountRef = (0, import_react109.useRef)(submitCount);
  var notify = useNotify();
  (0, import_react109.useEffect)(function() {
    var _a12, _b;
    if (submitCount > submitCountRef.current && enabled) {
      submitCountRef.current = submitCount;
      if (Object.keys(errors).length > 0) {
        var serverError = typeof ((_b = (_a12 = errors.root) === null || _a12 === void 0 ? void 0 : _a12.serverError) === null || _b === void 0 ? void 0 : _b.message) === "string" ? errors.root.serverError.message : void 0;
        notify(serverError || "ra.message.invalid_form", {
          type: "error"
        });
      }
    }
  }, [errors, submitCount, notify, enabled]);
};

// node_modules/ra-core/dist/esm/form/sanitizeEmptyValues.js
var sanitizeEmptyValues = function(values, record) {
  if (record === void 0) {
    record = {};
  }
  var sanitizedValues = {};
  Object.keys(values).forEach(function(key) {
    if (values[key] == null || values[key] === "") {
      if (record.hasOwnProperty(key)) {
        sanitizedValues[key] = null;
      } else {
      }
    } else {
      sanitizedValues[key] = values[key];
    }
  });
  return sanitizedValues;
};

// node_modules/ra-core/dist/esm/form/useRecordFromLocation.js
var import_react110 = __toESM(require_react());
var import_query_string3 = __toESM(require_query_string());
var import_isEqual5 = __toESM(require_isEqual());
var useRecordFromLocation = function(props) {
  if (props === void 0) {
    props = {};
  }
  var searchSource = props.searchSource, stateSource = props.stateSource;
  var location = useLocation();
  var _a11 = (0, import_react110.useState)(function() {
    return getRecordFromLocation(location, {
      stateSource,
      searchSource
    });
  }), recordFromLocation = _a11[0], setRecordFromLocation = _a11[1];
  var previousRecordRef = (0, import_react110.useRef)(recordFromLocation);
  (0, import_react110.useEffect)(function() {
    var newRecordFromLocation = getRecordFromLocation(location, {
      stateSource,
      searchSource
    });
    if (!(0, import_isEqual5.default)(newRecordFromLocation, previousRecordRef.current)) {
      previousRecordRef.current = newRecordFromLocation;
      setRecordFromLocation(newRecordFromLocation);
    }
  }, [location, stateSource, searchSource]);
  return recordFromLocation;
};
var getRecordFromLocation = function(_a11, _b) {
  var state = _a11.state, search = _a11.search;
  var _c = _b === void 0 ? {} : _b, _d = _c.searchSource, searchSource = _d === void 0 ? "source" : _d, _e = _c.stateSource, stateSource = _e === void 0 ? "record" : _e;
  if (state && state[stateSource]) {
    return state[stateSource];
  }
  if (search) {
    try {
      var searchParams = (0, import_query_string3.parse)(search);
      var source = searchParams[searchSource];
      if (source) {
        if (Array.isArray(source)) {
          console.error("Failed to parse location ".concat(searchSource, " parameter '").concat(search, "'. To pre-fill some fields in the Create form, pass a stringified ").concat(searchSource, " parameter (e.g. '?").concat(searchSource, `={"title":"foo"}')`));
          return null;
        }
        return JSON.parse(source);
      }
    } catch (e) {
      console.error("Failed to parse location ".concat(searchSource, " parameter '").concat(search, "'. To pre-fill some fields in the Create form, pass a stringified ").concat(searchSource, " parameter (e.g. '?").concat(searchSource, `={"title":"foo"}')`));
    }
  }
  return null;
};

// node_modules/ra-core/dist/esm/form/useAugmentedForm.js
var __assign40 = function() {
  __assign40 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign40.apply(this, arguments);
};
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator14 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest39 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useAugmentedForm = function(props) {
  var _a11 = props.criteriaMode, criteriaMode = _a11 === void 0 ? "firstError" : _a11, defaultValues = props.defaultValues, formRootPathname = props.formRootPathname, resolver = props.resolver, _b = props.reValidateMode, reValidateMode = _b === void 0 ? "onChange" : _b, onSubmit = props.onSubmit, sanitizeEmptyValues2 = props.sanitizeEmptyValues, validate = props.validate, disableInvalidFormNotification = props.disableInvalidFormNotification, rest = __rest39(props, ["criteriaMode", "defaultValues", "formRootPathname", "resolver", "reValidateMode", "onSubmit", "sanitizeEmptyValues", "validate", "disableInvalidFormNotification"]);
  var saveContext = useSaveContext();
  var record = useRecordContext(props);
  var defaultValuesIncludingRecord = (0, import_react111.useMemo)(
    function() {
      return getFormInitialValues(defaultValues, record);
    },
    // eslint-disable-next-line
    [
      // eslint-disable-next-line
      JSON.stringify({
        defaultValues: typeof defaultValues === "function" ? "function" : defaultValues,
        record
      })
    ]
  );
  var finalResolver = resolver ? resolver : validate ? getSimpleValidationResolver(validate) : void 0;
  var form = useForm(__assign40({ criteriaMode, values: defaultValuesIncludingRecord, reValidateMode, resolver: finalResolver }, rest));
  var formRef = (0, import_react111.useRef)(form);
  useNotifyIsFormInvalid(form.control, !disableInvalidFormNotification);
  var recordFromLocation = useRecordFromLocation();
  var recordFromLocationApplied = (0, import_react111.useRef)(false);
  var reset = form.reset;
  (0, import_react111.useEffect)(function() {
    if (recordFromLocation && !recordFromLocationApplied.current) {
      reset((0, import_merge3.default)({}, defaultValuesIncludingRecord, recordFromLocation), {
        keepDefaultValues: true
      });
      recordFromLocationApplied.current = true;
    }
  }, [defaultValuesIncludingRecord, recordFromLocation, reset]);
  var handleSubmit = (0, import_react111.useCallback)(function(values, event) {
    return __awaiter14(void 0, void 0, void 0, function() {
      var errors, finalValues;
      return __generator14(this, function(_a12) {
        switch (_a12.label) {
          case 0:
            finalValues = sanitizeEmptyValues2 ? sanitizeEmptyValues(values, record) : values;
            if (!onSubmit) return [3, 2];
            return [4, onSubmit(finalValues, event)];
          case 1:
            errors = _a12.sent();
            _a12.label = 2;
          case 2:
            if (!(onSubmit == null && (saveContext === null || saveContext === void 0 ? void 0 : saveContext.save))) return [3, 4];
            return [4, saveContext.save(finalValues, event)];
          case 3:
            errors = _a12.sent();
            _a12.label = 4;
          case 4:
            if (errors != null) {
              setSubmissionErrors(errors, formRef.current.setError);
            }
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }, [onSubmit, saveContext, sanitizeEmptyValues2, record]);
  var formHandleSubmit = (0, import_react111.useCallback)(function(event) {
    if (!event.defaultPrevented) {
      event.stopPropagation();
      form.handleSubmit(handleSubmit)(event);
    }
    return;
  }, [form, handleSubmit]);
  return {
    form,
    handleSubmit,
    formHandleSubmit
  };
};

// node_modules/ra-core/dist/esm/form/Form.js
var __assign41 = function() {
  __assign41 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign41.apply(this, arguments);
};
function Form(props) {
  var children = props.children, id = props.id, className = props.className, _a11 = props.noValidate, noValidate = _a11 === void 0 ? false : _a11, formRootPathname = props.formRootPathname, warnWhenUnsavedChanges = props.warnWhenUnsavedChanges, _b = props.WarnWhenUnsavedChangesComponent, WarnWhenUnsavedChangesComponent = _b === void 0 ? WarnWhenUnsavedChanges : _b;
  var record = useRecordContext(props);
  var resource = useResourceContext(props);
  var _c = useAugmentedForm(props), form = _c.form, formHandleSubmit = _c.formHandleSubmit;
  var sourceContext = React40.useMemo(function() {
    return {
      getSource: function(source) {
        return source;
      },
      getLabel: function(source) {
        return "resources.".concat(resource, ".fields.").concat(source);
      }
    };
  }, [resource]);
  var dataRouterContext = (0, import_react112.useContext)(DataRouterContext);
  var dataRouterStateContext = (0, import_react112.useContext)(DataRouterStateContext);
  if (warnWhenUnsavedChanges && (!dataRouterContext || !dataRouterStateContext) && true) {
    console.error("Cannot use the warnWhenUnsavedChanges feature outside of a DataRouter. The warnWhenUnsavedChanges feature is disabled. Remove the warnWhenUnsavedChanges prop or convert your custom router to a Data Router.");
  }
  return React40.createElement(
    OptionalRecordContextProvider,
    { value: record },
    React40.createElement(
      SourceContextProvider,
      { value: sourceContext },
      React40.createElement(
        FormProvider,
        __assign41({}, form),
        React40.createElement(
          FormGroupsProvider,
          null,
          React40.createElement("form", { onSubmit: formHandleSubmit, noValidate, id, className }, children),
          warnWhenUnsavedChanges && dataRouterContext && dataRouterStateContext && React40.createElement(WarnWhenUnsavedChangesComponent, { enable: true, formRootPathName: formRootPathname, formControl: form.control })
        )
      )
    )
  );
}

// node_modules/ra-core/dist/esm/form/FormDataConsumer.js
var React41 = __toESM(require_react());
var import_get9 = __toESM(require_get());

// node_modules/ra-core/dist/esm/form/useFormValues.js
var __assign42 = function() {
  __assign42 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign42.apply(this, arguments);
};
var useFormValues = function() {
  var getValues2 = useFormContext().getValues;
  return __assign42(__assign42({}, useWatch()), getValues2());
};

// node_modules/ra-core/dist/esm/form/FormDataConsumer.js
var __assign43 = function() {
  __assign43 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign43.apply(this, arguments);
};
var FormDataConsumer = function(props) {
  var form = useFormContext();
  var isDirty = form.formState.isDirty;
  var formData = useFormValues();
  return React41.createElement(FormDataConsumerView, __assign43({ formData }, props));
};
var FormDataConsumerView = function(props) {
  var children = props.children, formData = props.formData, source = props.source;
  var result;
  var finalSource = useWrappedSource(source || "");
  var matches = ArraySourceRegex.exec(finalSource);
  if (matches) {
    var scopedFormData = (0, import_get9.default)(formData, matches[0]);
    result = children({ formData, scopedFormData });
  } else {
    result = children({ formData });
  }
  return result === void 0 ? null : result;
};
var ArraySourceRegex = new RegExp(/.+\.\d+$/);

// node_modules/ra-core/dist/esm/form/groups/FormGroupContext.js
var import_react113 = __toESM(require_react());
var FormGroupContext = (0, import_react113.createContext)(null);

// node_modules/ra-core/dist/esm/form/groups/FormGroupContextProvider.js
var React42 = __toESM(require_react());
var import_react115 = __toESM(require_react());

// node_modules/ra-core/dist/esm/form/groups/useFormGroups.js
var import_react114 = __toESM(require_react());
var useFormGroups = function() {
  var context = (0, import_react114.useContext)(FormGroupsContext);
  return context;
};

// node_modules/ra-core/dist/esm/form/groups/FormGroupContextProvider.js
var FormGroupContextProvider = function(_a11) {
  var children = _a11.children, name = _a11.name;
  var formGroups = useFormGroups();
  (0, import_react115.useEffect)(function() {
    if (!formGroups || !formGroups.registerGroup || !formGroups.unregisterGroup) {
      console.warn("The FormGroupContextProvider can only be used inside a FormContext such as provided by the SimpleForm and TabbedForm components");
      return;
    }
    formGroups.registerGroup(name);
    return function() {
      formGroups.unregisterGroup(name);
    };
  }, [formGroups, name]);
  return React42.createElement(FormGroupContext.Provider, { value: name }, children);
};

// node_modules/ra-core/dist/esm/form/groups/useFormGroup.js
var import_react116 = __toESM(require_react());
var import_get10 = __toESM(require_get());
var import_isEqual6 = __toESM(require_isEqual());
var useFormGroup = function(name) {
  var _a11 = useFormState(), dirtyFields = _a11.dirtyFields, touchedFields = _a11.touchedFields, validatingFields = _a11.validatingFields, errors = _a11.errors;
  var dirtyFieldsNames = Object.keys(dirtyFields);
  var touchedFieldsNames = Object.keys(touchedFields);
  var validatingFieldsNames = Object.keys(validatingFields);
  var errorsNames = Object.keys(errors);
  var formGroups = useFormGroups();
  var _b = (0, import_react116.useState)({
    errors: void 0,
    isDirty: false,
    isTouched: false,
    isValid: true,
    isValidating: true
  }), state = _b[0], setState = _b[1];
  var updateGroupState = useEvent(function() {
    if (!formGroups)
      return;
    var fields = formGroups.getGroupFields(name);
    var fieldStates = fields.map(function(field) {
      return {
        name: field,
        error: (0, import_get10.default)(errors, field, void 0),
        isDirty: (0, import_get10.default)(dirtyFields, field, false) !== false,
        isValid: (0, import_get10.default)(errors, field, void 0) == null,
        isValidating: (0, import_get10.default)(validatingFields, field, void 0) == null,
        isTouched: (0, import_get10.default)(touchedFields, field, false) !== false
      };
    }).filter(function(fieldState) {
      return fieldState != void 0;
    });
    var newState = getFormGroupState(fieldStates);
    setState(function(oldState) {
      if (!(0, import_isEqual6.default)(oldState, newState)) {
        return newState;
      }
      return oldState;
    });
  });
  (0, import_react116.useEffect)(
    function() {
      updateGroupState();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(dirtyFieldsNames),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(errorsNames),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(touchedFieldsNames),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(validatingFieldsNames),
      updateGroupState,
      name,
      formGroups
    ]
  );
  (0, import_react116.useEffect)(function() {
    if (!formGroups)
      return;
    var unsubscribe = formGroups.subscribe(name, function() {
      updateGroupState();
    });
    return unsubscribe;
  }, [formGroups, name, updateGroupState]);
  return state;
};
var getFormGroupState = function(fieldStates) {
  return fieldStates.reduce(function(acc, fieldState) {
    var errors = acc.errors || {};
    if (fieldState.error) {
      errors[fieldState.name] = fieldState.error;
    }
    var newState = {
      isDirty: acc.isDirty || fieldState.isDirty,
      errors,
      isTouched: acc.isTouched || fieldState.isTouched,
      isValid: acc.isValid && fieldState.isValid,
      isValidating: acc.isValidating && fieldState.isValidating
    };
    return newState;
  }, {
    isDirty: false,
    errors: void 0,
    isValid: true,
    isTouched: false,
    isValidating: false
  });
};

// node_modules/ra-core/dist/esm/form/groups/useFormGroupContext.js
var import_react117 = __toESM(require_react());
var useFormGroupContext = function() {
  var context = (0, import_react117.useContext)(FormGroupContext);
  return context;
};

// node_modules/ra-core/dist/esm/form/useApplyInputDefaultValues.js
var import_react118 = __toESM(require_react());
var import_get11 = __toESM(require_get());
var useApplyInputDefaultValues = function(_a11) {
  var inputProps = _a11.inputProps, isArrayInput = _a11.isArrayInput, fieldArrayInputControl = _a11.fieldArrayInputControl;
  var defaultValue = inputProps.defaultValue, source = inputProps.source;
  var finalSource = useWrappedSource(source);
  var record = useRecordContext(inputProps);
  var _b = useFormContext(), getValues2 = _b.getValues, resetField = _b.resetField, formState = _b.formState, reset = _b.reset;
  var recordValue = (0, import_get11.default)(record, finalSource);
  var formValue = (0, import_get11.default)(getValues2(), finalSource);
  var dirtyFields = formState.dirtyFields;
  var isDirty = Object.keys(dirtyFields).includes(finalSource);
  (0, import_react118.useEffect)(function() {
    if (defaultValue == null || formValue != null || recordValue != null || isDirty) {
      return;
    }
    var pathContainsIndex = finalSource.split(".").some(function(pathPart) {
      return numericRegex.test(pathPart);
    });
    if (pathContainsIndex) {
      var parentPath = finalSource.split(".").slice(0, -1).join(".");
      var parentValue = (0, import_get11.default)(getValues2(), parentPath);
      if (parentValue == null) {
        return;
      }
    }
    if (isArrayInput) {
      if (!fieldArrayInputControl) {
        throw new Error("useApplyInputDefaultValues: No fieldArrayInputControl passed in props for array input usage");
      }
      fieldArrayInputControl.replace(defaultValue);
      reset({}, { keepValues: true });
      return;
    }
    resetField(finalSource, { defaultValue });
  });
};
var numericRegex = /^\d+$/;

// node_modules/ra-core/dist/esm/form/useInput.js
var import_react120 = __toESM(require_react());
var import_get12 = __toESM(require_get());

// node_modules/ra-core/dist/esm/form/validation/useGetValidationErrorMessage.js
var __assign44 = function() {
  __assign44 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign44.apply(this, arguments);
};
var useGetValidationErrorMessage = function() {
  var translate = useTranslate();
  return function(error) {
    if (error.message != null) {
      var _a11 = error, message2 = _a11.message, args = _a11.args;
      return translate(message2, __assign44({ _: message2 }, args));
    }
    return translate(error, { _: error });
  };
};

// node_modules/ra-core/dist/esm/form/validation/useUnique.js
var import_react119 = __toESM(require_react());
var import_merge4 = __toESM(require_merge());
var import_set4 = __toESM(require_set());

// node_modules/ra-core/dist/esm/form/validation/validate.js
var import_memoize = __toESM(require_memoize());
var EMAIL_REGEX = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var isEmpty2 = function(value) {
  return typeof value === "undefined" || value === null || value === "" || Array.isArray(value) && value.length === 0;
};
function isValidationErrorMessageWithArgs(error) {
  return error ? error.hasOwnProperty("message") : false;
}
var getMessage = function(message2, messageArgs, value, values) {
  return typeof message2 === "function" ? message2({
    args: messageArgs,
    value,
    values
  }) : messageArgs ? {
    message: message2,
    args: messageArgs
  } : message2;
};
var memoize = function(fn) {
  return (0, import_memoize.default)(fn, function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return JSON.stringify(args);
  });
};
var isFunction2 = function(value) {
  return typeof value === "function";
};
var combine2Validators = function(validator1, validator2) {
  return function(value, values, meta) {
    var result1 = validator1(value, values, meta);
    if (!result1) {
      return validator2(value, values, meta);
    }
    if (typeof result1 === "string" || isValidationErrorMessageWithArgs(result1)) {
      return result1;
    }
    return result1.then(function(resolvedResult1) {
      if (!resolvedResult1) {
        return validator2(value, values, meta);
      }
      return resolvedResult1;
    });
  };
};
var composeValidators = function() {
  var validators = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    validators[_i] = arguments[_i];
  }
  var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction2);
  return allValidators.reduce(combine2Validators, function() {
    return null;
  });
};
var composeSyncValidators = function() {
  var validators = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    validators[_i] = arguments[_i];
  }
  return function(value, values, meta) {
    var allValidators = (Array.isArray(validators[0]) ? validators[0] : validators).filter(isFunction2);
    for (var _i2 = 0, allValidators_1 = allValidators; _i2 < allValidators_1.length; _i2++) {
      var validator = allValidators_1[_i2];
      var error = validator(value, values, meta);
      if (error) {
        return error;
      }
    }
  };
};
var required = memoize(function(message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.required";
  }
  return Object.assign(function(value, values) {
    return isEmpty2(value) ? getMessage(message2, void 0, value, values) : void 0;
  }, { isRequired: true });
});
var minLength = memoize(function(min2, message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.minLength";
  }
  return function(value, values) {
    return !isEmpty2(value) && value.length < min2 ? getMessage(message2, { min: min2 }, value, values) : void 0;
  };
});
var maxLength = memoize(function(max2, message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.maxLength";
  }
  return function(value, values) {
    return !isEmpty2(value) && value.length > max2 ? getMessage(message2, { max: max2 }, value, values) : void 0;
  };
});
var minValue = memoize(function(min2, message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.minValue";
  }
  return function(value, values) {
    return !isEmpty2(value) && value < min2 ? getMessage(message2, { min: min2 }, value, values) : void 0;
  };
});
var maxValue = memoize(function(max2, message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.maxValue";
  }
  return function(value, values) {
    return !isEmpty2(value) && value > max2 ? getMessage(message2, { max: max2 }, value, values) : void 0;
  };
});
var number = memoize(function(message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.number";
  }
  return function(value, values) {
    return !isEmpty2(value) && isNaN(Number(value)) ? getMessage(message2, void 0, value, values) : void 0;
  };
});
var regex = (0, import_memoize.default)(function(pattern, message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.regex";
  }
  return function(value, values) {
    return !isEmpty2(value) && typeof value === "string" && !pattern.test(value) ? getMessage(message2, { pattern }, value, values) : void 0;
  };
}, function(pattern, message2) {
  return pattern.toString() + message2;
});
var email = memoize(function(message2) {
  if (message2 === void 0) {
    message2 = "ra.validation.email";
  }
  return regex(EMAIL_REGEX, message2);
});
var oneOfTypeMessage = function(_a11) {
  var args = _a11.args;
  return {
    message: "ra.validation.oneOf",
    args
  };
};
var choices = memoize(function(list, message2) {
  if (message2 === void 0) {
    message2 = oneOfTypeMessage;
  }
  return function(value, values) {
    return !isEmpty2(value) && list.indexOf(value) === -1 ? getMessage(message2, { list }, value, values) : void 0;
  };
});
var isRequired = function(validate) {
  if (validate && validate.isRequired) {
    return true;
  }
  if (Array.isArray(validate)) {
    return !!validate.find(function(it) {
      return it.isRequired;
    });
  }
  return false;
};

// node_modules/ra-core/dist/esm/form/validation/useUnique.js
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator15 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useUnique = function(options) {
  var _a11;
  var dataProvider = useDataProvider();
  var translateLabel = useTranslateLabel();
  var resource = useResourceContext(options);
  if (!resource) {
    throw new Error("useUnique: missing resource prop or context");
  }
  var translate = useTranslate();
  var record = useRecordContext();
  var debouncedGetList = (0, import_react119.useRef)(
    // The initial value is here to set the correct type on useRef
    asyncDebounce(dataProvider.getList, (_a11 = options === null || options === void 0 ? void 0 : options.debounce) !== null && _a11 !== void 0 ? _a11 : DEFAULT_DEBOUNCE)
  );
  var validateUnique = (0, import_react119.useCallback)(function(callTimeOptions) {
    var _a12 = (0, import_merge4.default)({
      debounce: DEFAULT_DEBOUNCE,
      filter: {},
      message: "ra.validation.unique"
    }, options, callTimeOptions), message2 = _a12.message, filter = _a12.filter, interval = _a12.debounce;
    debouncedGetList.current = asyncDebounce(dataProvider.getList, interval);
    return function(value, allValues, props) {
      return __awaiter15(void 0, void 0, void 0, function() {
        var finalFilter, _a13, data, total, error_1;
        return __generator15(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (isEmpty2(value)) {
                return [2, void 0];
              }
              _b.label = 1;
            case 1:
              _b.trys.push([1, 3, , 4]);
              finalFilter = (0, import_set4.default)((0, import_merge4.default)({}, filter), props.source, value);
              return [4, debouncedGetList.current(resource, {
                filter: finalFilter,
                pagination: { page: 1, perPage: 1 },
                sort: { field: "id", order: "ASC" }
              })];
            case 2:
              _a13 = _b.sent(), data = _a13.data, total = _a13.total;
              if (typeof total !== "undefined" && total > 0 && !data.some(function(r) {
                return r.id === (record === null || record === void 0 ? void 0 : record.id);
              })) {
                return [2, {
                  message: message2,
                  args: {
                    source: props.source,
                    value,
                    field: translateLabel({
                      label: props.label,
                      source: props.source,
                      resource
                    })
                  }
                }];
              }
              return [3, 4];
            case 3:
              error_1 = _b.sent();
              return [2, translate("ra.notification.http_error")];
            case 4:
              return [2, void 0];
          }
        });
      });
    };
  }, [dataProvider, options, record, resource, translate, translateLabel]);
  return validateUnique;
};
var DEFAULT_DEBOUNCE = 1e3;

// node_modules/ra-core/dist/esm/form/validation/ValidationError.js
var React43 = __toESM(require_react());
var __assign45 = function() {
  __assign45 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign45.apply(this, arguments);
};
var ValidationErrorSpecialFormatPrefix = "@@react-admin@@";
var ValidationError = function(props) {
  var error = props.error;
  var errorMessage = error;
  var translate = useTranslate();
  if (typeof error === "string" && error.startsWith(ValidationErrorSpecialFormatPrefix)) {
    errorMessage = JSON.parse(error.substring(ValidationErrorSpecialFormatPrefix.length));
  }
  if (errorMessage.message) {
    var _a11 = errorMessage, message2 = _a11.message, args = _a11.args;
    return React43.createElement(React43.Fragment, null, translate(message2, __assign45({ _: message2 }, args)));
  }
  return React43.createElement(React43.Fragment, null, translate(errorMessage, { _: errorMessage }));
};

// node_modules/ra-core/dist/esm/form/useInput.js
var __assign46 = function() {
  __assign46 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign46.apply(this, arguments);
};
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator16 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest40 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var defaultFormat = function(value) {
  return value == null ? "" : value;
};
var defaultParse = function(value) {
  return value === "" ? null : value;
};
var useInput = function(props) {
  var defaultValue = props.defaultValue, _a11 = props.format, format2 = _a11 === void 0 ? defaultFormat : _a11, id = props.id, isRequiredOption = props.isRequired, name = props.name, initialOnBlur = props.onBlur, initialOnChange = props.onChange, _b = props.parse, parseProp = _b === void 0 ? defaultParse : _b, source = props.source, validate = props.validate, options = __rest40(props, ["defaultValue", "format", "id", "isRequired", "name", "onBlur", "onChange", "parse", "source", "validate"]);
  var finalSource = useWrappedSource(source);
  var finalName = name || finalSource;
  var formGroupName = useFormGroupContext();
  var formGroups = useFormGroups();
  var record = useRecordContext();
  var parse4 = useEvent(parseProp);
  var defaultId = (0, import_react120.useId)();
  if (!finalName && true) {
    console.warn("Input components require either a source or a name prop.");
  }
  (0, import_react120.useEffect)(function() {
    if (!formGroups || formGroupName == null) {
      return;
    }
    formGroups.registerField(finalSource, formGroupName);
    return function() {
      formGroups.unregisterField(finalSource, formGroupName);
    };
  }, [formGroups, formGroupName, finalSource]);
  var sanitizedValidate = Array.isArray(validate) ? composeValidators(validate) : validate;
  var _c = useController(__assign46({ name: finalName, defaultValue: (0, import_get12.default)(record, finalSource, defaultValue), rules: {
    validate: function(value, values) {
      return __awaiter16(void 0, void 0, void 0, function() {
        var error;
        return __generator16(this, function(_a12) {
          switch (_a12.label) {
            case 0:
              if (!sanitizedValidate)
                return [2, true];
              return [4, sanitizedValidate(value, values, __assign46(__assign46({}, props), { finalSource }))];
            case 1:
              error = _a12.sent();
              if (!error)
                return [2, true];
              return [2, "@@react-admin@@".concat(JSON.stringify(error))];
          }
        });
      });
    }
  } }, options)), controllerField = _c.field, fieldState = _c.fieldState, formState = _c.formState;
  useApplyInputDefaultValues({ inputProps: props });
  var onBlur = useEvent(function() {
    var event = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      event[_i] = arguments[_i];
    }
    controllerField.onBlur();
    if (initialOnBlur) {
      initialOnBlur.apply(void 0, event);
    }
  });
  var onChange = useEvent(function() {
    var _a12, _b2, _c2, _d, _e;
    var event = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      event[_i] = arguments[_i];
    }
    var eventOrValue = props.type === "checkbox" && ((_b2 = (_a12 = event[0]) === null || _a12 === void 0 ? void 0 : _a12.target) === null || _b2 === void 0 ? void 0 : _b2.value) === "on" ? event[0].target.checked : (_e = (_d = (_c2 = event[0]) === null || _c2 === void 0 ? void 0 : _c2.target) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : event[0];
    controllerField.onChange(parse4 ? parse4(eventOrValue) : eventOrValue);
    if (initialOnChange) {
      initialOnChange.apply(void 0, event);
    }
  });
  var field = __assign46(__assign46({}, controllerField), { value: format2 ? format2(controllerField.value) : controllerField.value, onBlur, onChange });
  return {
    id: id || defaultId,
    field,
    fieldState,
    formState,
    isRequired: isRequiredOption || isRequired(validate)
  };
};

// node_modules/ra-core/dist/esm/form/useSuggestions.js
var import_react121 = __toESM(require_react());
var import_set5 = __toESM(require_set());
var __spreadArray21 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var useSuggestions = function(_a11) {
  var allowCreate = _a11.allowCreate, choices2 = _a11.choices, _b = _a11.createText, createText = _b === void 0 ? "ra.action.create" : _b, _c = _a11.createValue, createValue2 = _c === void 0 ? "@@create" : _c, limitChoicesToValue = _a11.limitChoicesToValue, matchSuggestion = _a11.matchSuggestion, optionText = _a11.optionText, optionValue = _a11.optionValue, selectedItem = _a11.selectedItem, _d = _a11.suggestionLimit, suggestionLimit = _d === void 0 ? 0 : _d, translateChoice = _a11.translateChoice;
  var translate = useTranslate();
  var _e = useChoices({
    optionText,
    optionValue,
    translateChoice
  }), getChoiceText = _e.getChoiceText, getChoiceValue = _e.getChoiceValue;
  var getSuggestions = (0, import_react121.useCallback)(getSuggestionsFactory({
    allowCreate,
    choices: choices2,
    createText,
    createValue: createValue2,
    getChoiceText,
    getChoiceValue,
    limitChoicesToValue,
    matchSuggestion,
    optionText,
    optionValue,
    selectedItem,
    suggestionLimit
  }), [
    allowCreate,
    choices2,
    createText,
    createValue2,
    getChoiceText,
    getChoiceValue,
    limitChoicesToValue,
    matchSuggestion,
    optionText,
    optionValue,
    selectedItem,
    suggestionLimit,
    translate
  ]);
  return {
    getChoiceText,
    getChoiceValue,
    getSuggestions
  };
};
var escapeRegExp = function(value) {
  return value ? value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : "";
};
var defaultMatchSuggestion = function(getChoiceText) {
  return function(filter, suggestion, exact) {
    if (exact === void 0) {
      exact = false;
    }
    var suggestionText = getChoiceText(suggestion);
    var isReactElement = (0, import_react121.isValidElement)(suggestionText);
    var regex2 = escapeRegExp(filter);
    return isReactElement ? false : suggestionText && !!suggestionText.match(
      // We must escape any RegExp reserved characters to avoid errors
      // For example, the filter might contain * which must be escaped as \*
      new RegExp(exact ? "^".concat(regex2, "$") : regex2, "i")
    );
  };
};
var getSuggestionsFactory = function(_a11) {
  var _b = _a11.allowCreate, allowCreate = _b === void 0 ? false : _b, _c = _a11.choices, choices2 = _c === void 0 ? [] : _c, _d = _a11.createText, createText = _d === void 0 ? "ra.action.create" : _d, _e = _a11.createValue, createValue2 = _e === void 0 ? "@@create" : _e, _f = _a11.optionText, optionText = _f === void 0 ? "name" : _f, _g = _a11.optionValue, optionValue = _g === void 0 ? "id" : _g, getChoiceText = _a11.getChoiceText, getChoiceValue = _a11.getChoiceValue, _h = _a11.limitChoicesToValue, limitChoicesToValue = _h === void 0 ? false : _h, _j = _a11.matchSuggestion, matchSuggestion = _j === void 0 ? defaultMatchSuggestion(getChoiceText) : _j, selectedItem = _a11.selectedItem, _k = _a11.suggestionLimit, suggestionLimit = _k === void 0 ? 0 : _k;
  return function(filter) {
    var suggestions = [];
    if (selectedItem && !Array.isArray(selectedItem) && matchSuggestion(filter, selectedItem)) {
      if (limitChoicesToValue) {
        suggestions = choices2.filter(function(choice) {
          return getChoiceValue(choice) === getChoiceValue(selectedItem);
        });
      } else {
        suggestions = __spreadArray21([], choices2, true);
      }
    } else {
      suggestions = choices2.filter(function(choice) {
        return matchSuggestion(filter, choice) || selectedItem != null && (!Array.isArray(selectedItem) ? getChoiceValue(choice) === getChoiceValue(selectedItem) : selectedItem.some(function(selected) {
          return getChoiceValue(choice) === getChoiceValue(selected);
        }));
      });
    }
    suggestions = limitSuggestions(suggestions, suggestionLimit);
    var hasExactMatch = suggestions.some(function(suggestion) {
      return matchSuggestion(filter, suggestion, true);
    });
    if (allowCreate) {
      var filterIsSelectedItem = (
        // If the selectedItem is an array (for example AutocompleteArrayInput)
        // we shouldn't try to match
        !!selectedItem && !Array.isArray(selectedItem) ? matchSuggestion(filter, selectedItem, true) : false
      );
      if (!hasExactMatch && !filterIsSelectedItem) {
        suggestions.push(getSuggestion({
          optionText,
          optionValue,
          text: createText,
          value: createValue2
        }));
      }
    }
    var result = suggestions.filter(function(suggestion, index) {
      return suggestions.indexOf(suggestion) === index;
    });
    return result;
  };
};
var limitSuggestions = function(suggestions, limit) {
  if (limit === void 0) {
    limit = 0;
  }
  return Number.isInteger(limit) && limit > 0 ? suggestions.slice(0, limit) : suggestions;
};
var getSuggestion = function(_a11) {
  var _b = _a11.optionText, optionText = _b === void 0 ? "name" : _b, _c = _a11.optionValue, optionValue = _c === void 0 ? "id" : _c, _d = _a11.text, text = _d === void 0 ? "" : _d, _e = _a11.value, value = _e === void 0 ? null : _e;
  var suggestion = {};
  (0, import_set5.default)(suggestion, optionValue, value);
  if (typeof optionText === "string") {
    (0, import_set5.default)(suggestion, optionText, text);
  }
  return suggestion;
};

// node_modules/ra-core/dist/esm/form/FilterLiveForm.js
var React44 = __toESM(require_react());
var import_isEqual7 = __toESM(require_isEqual());
var import_cloneDeep2 = __toESM(require_cloneDeep());
var import_get13 = __toESM(require_get());
var import_set6 = __toESM(require_set());
var import_react122 = __toESM(require_react());
var __assign47 = function() {
  __assign47 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign47.apply(this, arguments);
};
var __rest41 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var FilterLiveForm = function(props) {
  var _a11 = useListContext(), filterValues = _a11.filterValues, setFilters = _a11.setFilters;
  var resource = useResourceContext(props);
  var _b = props.debounce, debounce5 = _b === void 0 ? 500 : _b, resolver = props.resolver, validate = props.validate, children = props.children, _c = props.formComponent, Component2 = _c === void 0 ? HTMLForm : _c, rest = __rest41(props, ["debounce", "resolver", "validate", "children", "formComponent"]);
  var finalResolver = resolver ? resolver : validate ? getSimpleValidationResolver(validate) : void 0;
  var formContext = useForm(__assign47({ mode: "onChange", defaultValues: filterValues, resolver: finalResolver }, rest));
  var handleSubmit = formContext.handleSubmit, getValues2 = formContext.getValues, reset = formContext.reset, watch = formContext.watch, formState = formContext.formState;
  var isValid2 = formState.isValid;
  var formChangesPending = React44.useRef(false);
  (0, import_react122.useEffect)(function() {
    var newValues = getFilterFormValues(getValues2(), filterValues);
    var previousValues = getValues2();
    if (formChangesPending.current) {
      formChangesPending.current = false;
      return;
    }
    if (!(0, import_isEqual7.default)(newValues, previousValues)) {
      reset(newValues);
    }
  }, [JSON.stringify(filterValues), getValues2, reset]);
  var onSubmit = function(values) {
    if (!isValid2) {
      return;
    }
    formChangesPending.current = true;
    setFilters(__assign47(__assign47({}, filterValues), values));
  };
  var debouncedOnSubmit = useDebouncedEvent(onSubmit, debounce5 || 0);
  (0, import_react122.useEffect)(function() {
    var unsubscribe = watch(function(values, _a12) {
      var name = _a12.name;
      if (name) {
        if ((0, import_get13.default)(values, name) === "") {
          var newValues = (0, import_cloneDeep2.default)(values);
          (0, import_set6.default)(newValues, name, "");
          debouncedOnSubmit(newValues);
        } else {
          debouncedOnSubmit(values);
        }
      }
    }).unsubscribe;
    return function() {
      return unsubscribe();
    };
  }, [watch, debouncedOnSubmit]);
  var sourceContext = React44.useMemo(function() {
    return {
      getSource: function(source) {
        return source;
      },
      getLabel: function(source) {
        return "resources.".concat(resource, ".fields.").concat(source);
      }
    };
  }, [resource]);
  return React44.createElement(
    FormProvider,
    __assign47({}, formContext),
    React44.createElement(
      FormGroupsProvider,
      null,
      React44.createElement(
        SourceContextProvider,
        { value: sourceContext },
        React44.createElement(Component2, { onSubmit: handleSubmit(onSubmit) }, children)
      )
    )
  );
};
var HTMLForm = function(props) {
  return React44.createElement("form", __assign47({}, props));
};
var getFilterFormValues = function(formValues, filterValues) {
  var _a11;
  return Object.keys(formValues).reduce(function(acc, key) {
    acc[key] = getInputValue(formValues, key, filterValues);
    return acc;
  }, (_a11 = (0, import_cloneDeep2.default)(filterValues)) !== null && _a11 !== void 0 ? _a11 : {});
};
var getInputValue = function(formValues, key, filterValues) {
  if (formValues[key] === void 0 || formValues[key] === null) {
    return (0, import_get13.default)(filterValues, key, "");
  }
  if (Array.isArray(formValues[key])) {
    return (0, import_get13.default)(filterValues, key, "");
  }
  if (formValues[key] instanceof Date) {
    return (0, import_get13.default)(filterValues, key, "");
  }
  if (typeof formValues[key] === "object") {
    var inputValues = Object.keys(formValues[key]).reduce(function(acc, innerKey) {
      var _a11;
      var nestedInputValue = getInputValue(formValues[key], innerKey, (_a11 = (filterValues || {})[key]) !== null && _a11 !== void 0 ? _a11 : {});
      acc[innerKey] = nestedInputValue;
      return acc;
    }, {});
    if (!Object.keys(inputValues).length)
      return "";
    return inputValues;
  }
  return (0, import_get13.default)(filterValues, key, "");
};

// node_modules/ra-core/dist/esm/controller/input/ReferenceInputBase.js
var __assign48 = function() {
  __assign48 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign48.apply(this, arguments);
};
var ReferenceInputBase = function(props) {
  var children = props.children, reference = props.reference, _a11 = props.sort, sort = _a11 === void 0 ? { field: "id", order: "DESC" } : _a11, _b = props.filter, filter = _b === void 0 ? {} : _b;
  var controllerProps = useReferenceInputController(__assign48(__assign48({}, props), { sort, filter }));
  return import_react123.default.createElement(
    ResourceContextProvider,
    { value: reference },
    import_react123.default.createElement(ChoicesContextProvider, { value: controllerProps }, children)
  );
};

// node_modules/ra-core/dist/esm/controller/show/ShowBase.js
var React47 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/show/useShowController.js
var __assign49 = function() {
  __assign49 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign49.apply(this, arguments);
};
var __rest42 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useShowController = function(props) {
  if (props === void 0) {
    props = {};
  }
  var _a11 = props.disableAuthentication, disableAuthentication = _a11 === void 0 ? false : _a11, propsId = props.id, _b = props.queryOptions, queryOptions2 = _b === void 0 ? {} : _b;
  var resource = useResourceContext(props);
  if (!resource) {
    throw new Error("useShowController requires a non-empty resource prop or context");
  }
  var isPendingAuthenticated = useAuthenticated({
    enabled: !disableAuthentication
  }).isPending;
  var isPendingCanAccess = useRequireAccess({
    action: "show",
    resource,
    // If disableAuthentication is true then isPendingAuthenticated will always be true so this hook is disabled
    enabled: !isPendingAuthenticated
  }).isPending;
  var getRecordRepresentation = useGetRecordRepresentation(resource);
  var translate = useTranslate();
  var notify = useNotify();
  var redirect = useRedirect();
  var refresh = useRefresh();
  var routeId = useParams().id;
  if (!routeId && !propsId) {
    throw new Error("useShowController requires an id prop or a route with an /:id? parameter.");
  }
  var id = propsId != null ? propsId : routeId;
  var meta = queryOptions2.meta, otherQueryOptions = __rest42(queryOptions2, ["meta"]);
  var _c = useGetOne(resource, { id, meta }, __assign49({ enabled: !isPendingAuthenticated && !isPendingCanAccess || disableAuthentication, onError: function() {
    notify("ra.notification.item_doesnt_exist", {
      type: "error"
    });
    redirect("list", resource);
    refresh();
  }, retry: false }, otherQueryOptions)), record = _c.data, error = _c.error, isLoading = _c.isLoading, isFetching = _c.isFetching, isPending = _c.isPending, refetch2 = _c.refetch;
  if (record && record.id && record.id != id) {
    throw new Error("useShowController: Fetched record's id attribute (".concat(record.id, ") must match the requested 'id' (").concat(id, ")"));
  }
  var getResourceLabel = useGetResourceLabel();
  var recordRepresentation = getRecordRepresentation(record);
  var defaultTitle = translate("ra.page.show", {
    name: getResourceLabel(resource, 1),
    id,
    record,
    recordRepresentation: typeof recordRepresentation === "string" ? recordRepresentation : ""
  });
  return {
    defaultTitle,
    error,
    isLoading,
    isFetching,
    isPending,
    record,
    refetch: refetch2,
    resource
  };
};

// node_modules/ra-core/dist/esm/controller/show/ShowContextProvider.js
var React46 = __toESM(require_react());

// node_modules/ra-core/dist/esm/controller/show/ShowContext.js
var import_react124 = __toESM(require_react());
var ShowContext = (0, import_react124.createContext)(null);
ShowContext.displayName = "ShowContext";

// node_modules/ra-core/dist/esm/controller/show/ShowContextProvider.js
var ShowContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return React46.createElement(
    ShowContext.Provider,
    { value },
    React46.createElement(RecordContextProvider, { value: value && value.record }, children)
  );
};

// node_modules/ra-core/dist/esm/controller/show/ShowBase.js
var __rest43 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ShowBase = function(_a11) {
  var children = _a11.children, _b = _a11.loading, loading = _b === void 0 ? null : _b, props = __rest43(_a11, ["children", "loading"]);
  var controllerProps = useShowController(props);
  var isAuthPending = useIsAuthPending({
    resource: controllerProps.resource,
    action: "show"
  });
  if (isAuthPending && !props.disableAuthentication) {
    return loading;
  }
  return (
    // We pass props.resource here as we don't need to create a new ResourceContext if the props is not provided
    React47.createElement(
      OptionalResourceContextProvider,
      { value: props.resource },
      React47.createElement(ShowContextProvider, { value: controllerProps }, children)
    )
  );
};

// node_modules/ra-core/dist/esm/controller/show/ShowController.js
var __rest44 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ShowController = function(_a11) {
  var children = _a11.children, props = __rest44(_a11, ["children"]);
  var controllerProps = useShowController(props);
  return children(controllerProps);
};

// node_modules/ra-core/dist/esm/controller/show/useShowContext.js
var import_react125 = __toESM(require_react());
var useShowContext = function() {
  var context = (0, import_react125.useContext)(ShowContext);
  if (!context) {
    throw new Error("useShowContext must be used inside a ShowContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/controller/usePrevNextController.js
var __assign50 = function() {
  __assign50 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign50.apply(this, arguments);
};
var __rest45 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var usePrevNextController = function(props) {
  var _a11, _b, _c, _d;
  var _e = props.linkType, linkType = _e === void 0 ? "edit" : _e, storeKey = props.storeKey, _f = props.limit, limit = _f === void 0 ? 1e3 : _f, _g = props.sort, initialSort = _g === void 0 ? { field: "id", order: SORT_ASC } : _g, _h = props.filter, permanentFilter = _h === void 0 ? {} : _h, _j = props.filterDefaultValues, filterDefaultValues = _j === void 0 ? {} : _j, _k = props.queryOptions, queryOptions2 = _k === void 0 ? {
    staleTime: 5 * 60 * 1e3
  } : _k;
  var record = useRecordContext(props);
  var resource = useResourceContext(props);
  var createPath = useCreatePath();
  if (!resource) {
    throw new Error("useNextPrevController was called outside of a ResourceContext and without a resource prop. You must set the resource prop.");
  }
  var storedParams = useStore(storeKey || "".concat(resource, ".listParams"), {
    filter: filterDefaultValues,
    order: initialSort.order,
    sort: initialSort.field,
    page: 1,
    perPage: 10,
    displayedFilters: {}
  })[0];
  var dataProvider = useDataProvider();
  var queryClient = useQueryClient();
  var pagination = { page: 1, perPage: limit };
  var sort = {
    field: storedParams.sort,
    order: storedParams.order
  };
  var filter = __assign50(__assign50({}, storedParams.filter), permanentFilter);
  var meta = queryOptions2.meta, otherQueryOptions = __rest45(queryOptions2, ["meta"]);
  var params = { pagination, sort, filter, meta };
  var queryData = queryClient.getQueryData([
    resource,
    "getList",
    __assign50(__assign50({}, params), { pagination: {
      page: storedParams.page,
      perPage: storedParams.perPage
    } })
  ]);
  var recordIndexInQueryData = (_a11 = queryData === null || queryData === void 0 ? void 0 : queryData.data) === null || _a11 === void 0 ? void 0 : _a11.findIndex(function(r) {
    return r.id === (record === null || record === void 0 ? void 0 : record.id);
  });
  var isRecordIndexFirstInNonFirstPage = recordIndexInQueryData === 0 && storedParams.page > 1;
  var isRecordIndexLastInNonLastPage = (queryData === null || queryData === void 0 ? void 0 : queryData.data) && (queryData === null || queryData === void 0 ? void 0 : queryData.total) ? recordIndexInQueryData === ((_b = queryData === null || queryData === void 0 ? void 0 : queryData.data) === null || _b === void 0 ? void 0 : _b.length) - 1 && storedParams.page < (queryData === null || queryData === void 0 ? void 0 : queryData.total) / storedParams.perPage : void 0;
  var canUseCacheData = record && (queryData === null || queryData === void 0 ? void 0 : queryData.data) && recordIndexInQueryData !== -1 && !isRecordIndexFirstInNonFirstPage && !isRecordIndexLastInNonLastPage;
  var _l = useQuery(__assign50({ queryKey: [resource, "getList", params], queryFn: function(queryParams) {
    return dataProvider.getList(resource, __assign50(__assign50({}, params), { signal: dataProvider.supportAbortSignal === true ? queryParams.signal : void 0 }));
  }, enabled: !canUseCacheData }, otherQueryOptions)), data = _l.data, error = _l.error, isFetching = _l.isFetching, isLoading = _l.isLoading, isPending = _l.isPending;
  var finalData = canUseCacheData ? queryData.data : (data === null || data === void 0 ? void 0 : data.data) || [];
  if (!record || isPending && !canUseCacheData)
    return {
      isFetching: true,
      isLoading: true,
      isPending: true,
      prevPath: void 0,
      nextPath: void 0,
      index: void 0,
      total: void 0,
      hasPrev: false,
      hasNext: false
    };
  var ids = finalData.map(function(record2) {
    return record2.id;
  });
  var index = ids.indexOf(record.id);
  var previousId = typeof ids[index - 1] !== "undefined" ? ids[index - 1] : null;
  var nextId = index !== -1 && index < ids.length - 1 ? ids[index + 1] : null;
  return {
    hasPrev: previousId !== null,
    hasNext: nextId !== null,
    prevPath: previousId !== null ? createPath({
      type: linkType,
      resource,
      id: previousId
    }) : void 0,
    nextPath: nextId !== null ? createPath({
      type: linkType,
      resource,
      id: nextId
    }) : void 0,
    index: index === -1 ? void 0 : index + (canUseCacheData ? ((_c = storedParams.perPage) !== null && _c !== void 0 ? _c : 0) * (((_d = storedParams.page) !== null && _d !== void 0 ? _d : 1) - 1) : 0),
    total: canUseCacheData ? queryData === null || queryData === void 0 ? void 0 : queryData.total : data === null || data === void 0 ? void 0 : data.total,
    error,
    isFetching: canUseCacheData ? false : isFetching,
    isLoading: canUseCacheData ? false : isLoading,
    isPending: canUseCacheData ? false : isPending
  };
};

// node_modules/ra-core/dist/esm/auth/useCanAccess.js
var __assign51 = function() {
  __assign51 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign51.apply(this, arguments);
};
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator17 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useCanAccess = function(params) {
  var authProvider = useAuthProvider_default();
  var resource = useResourceContext(params);
  if (!resource) {
    throw new Error("useCanAccess must be used inside a <Resource> component or provide a resource prop");
  }
  var record = useRecordContext(params);
  var authProviderHasCanAccess = !!(authProvider === null || authProvider === void 0 ? void 0 : authProvider.canAccess);
  var queryResult = useQuery(__assign51({ queryKey: ["auth", "canAccess", __assign51(__assign51({}, params), { record, resource })], queryFn: function(_a11) {
    var signal = _a11.signal;
    return __awaiter17(void 0, void 0, void 0, function() {
      return __generator17(this, function(_b) {
        if (!authProvider || !authProvider.canAccess) {
          return [2, true];
        }
        return [2, authProvider.canAccess(__assign51(__assign51({}, params), { record, resource, signal: authProvider.supportAbortSignal ? signal : void 0 }))];
      });
    });
  }, enabled: authProviderHasCanAccess }, params));
  var result = (0, import_react126.useMemo)(function() {
    return __assign51(__assign51({}, queryResult), { canAccess: queryResult.data });
  }, [queryResult]);
  return authProviderHasCanAccess ? result : emptyQueryObserverResult;
};
var emptyQueryObserverResult = {
  canAccess: true,
  data: true,
  dataUpdatedAt: 0,
  error: null,
  errorUpdatedAt: 0,
  errorUpdateCount: 0,
  failureCount: 0,
  failureReason: null,
  fetchStatus: "idle",
  isError: false,
  isInitialLoading: false,
  isLoading: false,
  isLoadingError: false,
  isFetched: true,
  isFetchedAfterMount: true,
  isFetching: false,
  isPaused: false,
  isPlaceholderData: false,
  isPending: false,
  isRefetchError: false,
  isRefetching: false,
  isStale: false,
  isSuccess: true,
  status: "success",
  refetch: function() {
    return Promise.resolve(emptyQueryObserverResult);
  }
};

// node_modules/ra-core/dist/esm/auth/CanAccess.js
var __rest46 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var CanAccess = function(_a11) {
  var children = _a11.children, _b = _a11.loading, loading = _b === void 0 ? null : _b, _c = _a11.accessDenied, accessDenied = _c === void 0 ? null : _c, _d = _a11.error, errorElement = _d === void 0 ? DEFAULT_ERROR : _d, props = __rest46(_a11, ["children", "loading", "accessDenied", "error"]);
  var _e = useCanAccess(props), canAccess = _e.canAccess, error = _e.error, isPending = _e.isPending;
  if (isPending) {
    return loading;
  }
  if (error) {
    return errorElement;
  }
  if (canAccess === false) {
    return accessDenied;
  }
  return children;
};
var CanAccessDefaultError = function() {
  var basename = useBasename();
  return React48.createElement(Navigate, { to: "".concat(basename, "/authentication-error") });
};
var DEFAULT_ERROR = React48.createElement(CanAccessDefaultError, null);

// node_modules/ra-core/dist/esm/auth/LogoutOnMount.js
var import_react127 = __toESM(require_react());
var LogoutOnMount = function() {
  var logout = useLogout_default();
  (0, import_react127.useEffect)(function() {
    logout();
  }, [logout]);
  return null;
};

// node_modules/ra-core/dist/esm/auth/useCanAccessResources.js
var import_react128 = __toESM(require_react());
var __assign52 = function() {
  __assign52 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign52.apply(this, arguments);
};
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator18 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest47 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useCanAccessResources = function(params) {
  var authProvider = useAuthProvider_default();
  var record = useRecordContext(params);
  var action = params.action, resources = params.resources, options = __rest47(params, ["action", "resources"]);
  var queryResult = useQuery(__assign52({ queryKey: ["auth", "canAccess", resources, action, record], queryFn: function(_a11) {
    var signal = _a11.signal;
    return __awaiter18(void 0, void 0, void 0, function() {
      var queries, result2;
      return __generator18(this, function(_b) {
        switch (_b.label) {
          case 0:
            return [4, Promise.all(resources.map(function(resource) {
              return __awaiter18(void 0, void 0, void 0, function() {
                var canAccess;
                return __generator18(this, function(_a12) {
                  switch (_a12.label) {
                    case 0:
                      if (!authProvider || !authProvider.canAccess) {
                        return [2, { canAccess: true, resource }];
                      }
                      return [4, authProvider.canAccess({
                        resource,
                        action,
                        record,
                        signal: authProvider.supportAbortSignal ? signal : void 0
                      })];
                    case 1:
                      canAccess = _a12.sent();
                      return [2, { canAccess, resource }];
                  }
                });
              });
            }))];
          case 1:
            queries = _b.sent();
            result2 = queries.reduce(function(acc, _a12) {
              var resource = _a12.resource, canAccess = _a12.canAccess;
              acc[resource] = canAccess;
              return acc;
            }, {});
            return [2, result2];
        }
      });
    });
  } }, options));
  var result = (0, import_react128.useMemo)(function() {
    return __assign52({ canAccess: queryResult.data }, queryResult);
  }, [queryResult]);
  var resultWithoutAuthProvider = (0, import_react128.useMemo)(function() {
    return {
      canAccess: resources.reduce(function(acc, resource) {
        acc[resource] = true;
        return acc;
      }, {}),
      isPending: false,
      isError: false,
      error: null
    };
  }, [resources]);
  return !authProvider || !authProvider.canAccess ? resultWithoutAuthProvider : result;
};

// node_modules/ra-core/dist/esm/auth/useCanAccessCallback.js
var __assign53 = function() {
  __assign53 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign53.apply(this, arguments);
};
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator19 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useCanAccessCallback = function(options) {
  if (options === void 0) {
    options = {};
  }
  var authProvider = useAuthProvider_default();
  var mutateAsync = useMutation(__assign53({ mutationFn: function(params) {
    return __awaiter19(void 0, void 0, void 0, function() {
      return __generator19(this, function(_a11) {
        if (!authProvider || !authProvider.canAccess) {
          return [2, true];
        }
        return [2, authProvider.canAccess(params)];
      });
    });
  }, retry: false }, options)).mutateAsync;
  return mutateAsync;
};

// node_modules/ra-core/dist/esm/auth/useCheckAuth.js
var import_react129 = __toESM(require_react());
var useCheckAuth = function() {
  var authProvider = useAuthProvider_default();
  var notify = useNotify();
  var logout = useLogout_default();
  var basename = useBasename();
  var loginUrl = removeDoubleSlashes("".concat(basename, "/").concat(defaultAuthParams.loginUrl));
  var checkAuth = (0, import_react129.useCallback)(function(params, logoutOnFailure, redirectTo) {
    if (params === void 0) {
      params = {};
    }
    if (logoutOnFailure === void 0) {
      logoutOnFailure = true;
    }
    if (redirectTo === void 0) {
      redirectTo = loginUrl;
    }
    return authProvider ? authProvider.checkAuth(params).catch(function(error) {
      if (logoutOnFailure) {
        logout({}, error && error.redirectTo != null ? error.redirectTo : redirectTo);
        var shouldSkipNotify = error && error.message === false;
        !shouldSkipNotify && notify(getErrorMessage3(error, "ra.auth.auth_check_error"), { type: "error" });
      }
      throw error;
    }) : checkAuthWithoutAuthProvider();
  }, [authProvider, logout, notify, loginUrl]);
  return checkAuth;
};
var checkAuthWithoutAuthProvider = function() {
  return Promise.resolve();
};
var getErrorMessage3 = function(error, defaultMessage) {
  return typeof error === "string" ? error : typeof error === "undefined" || !error.message ? defaultMessage : error.message;
};

// node_modules/ra-core/dist/esm/auth/useGetIdentity.js
var import_react130 = __toESM(require_react());
var __assign54 = function() {
  __assign54 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign54.apply(this, arguments);
};
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator20 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest48 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var defaultIdentity = {
  id: ""
};
var defaultQueryParams = {
  staleTime: 5 * 60 * 1e3
};
var useGetIdentity = function(options) {
  if (options === void 0) {
    options = defaultQueryParams;
  }
  var authProvider = useAuthProvider_default();
  var onSuccess = options.onSuccess, onError = options.onError, onSettled = options.onSettled, queryOptions2 = __rest48(options, ["onSuccess", "onError", "onSettled"]);
  var result = useQuery(__assign54({ queryKey: ["auth", "getIdentity"], queryFn: function(_a11) {
    var signal = _a11.signal;
    return __awaiter20(void 0, void 0, void 0, function() {
      return __generator20(this, function(_b) {
        if (authProvider && typeof authProvider.getIdentity === "function") {
          return [2, authProvider.getIdentity({ signal })];
        } else {
          return [2, defaultIdentity];
        }
        return [
          2
          /*return*/
        ];
      });
    });
  } }, queryOptions2));
  var onSuccessEvent = useEvent(onSuccess !== null && onSuccess !== void 0 ? onSuccess : noop11);
  var onErrorEvent = useEvent(onError !== null && onError !== void 0 ? onError : noop11);
  var onSettledEvent = useEvent(onSettled !== null && onSettled !== void 0 ? onSettled : noop11);
  (0, import_react130.useEffect)(function() {
    if (result.data === void 0 || result.isFetching)
      return;
    onSuccessEvent(result.data);
  }, [onSuccessEvent, result.data, result.isFetching]);
  (0, import_react130.useEffect)(function() {
    if (result.error == null || result.isFetching)
      return;
    onErrorEvent(result.error);
  }, [onErrorEvent, result.error, result.isFetching]);
  (0, import_react130.useEffect)(function() {
    if (result.status === "pending" || result.isFetching)
      return;
    onSettledEvent(result.data, result.error);
  }, [
    onSettledEvent,
    result.data,
    result.error,
    result.status,
    result.isFetching
  ]);
  return (0, import_react130.useMemo)(function() {
    return __assign54(__assign54({}, result), { identity: result.data });
  }, [result]);
};
var noop11 = function() {
};

// node_modules/ra-core/dist/esm/auth/useHandleAuthCallback.js
var import_react131 = __toESM(require_react());
var __assign55 = function() {
  __assign55 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign55.apply(this, arguments);
};
var __rest49 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useHandleAuthCallback = function(options) {
  var authProvider = useAuthProvider_default();
  var redirect = useRedirect();
  var location = useLocation();
  var locationState = location.state;
  var nextPathName = locationState && locationState.nextPathname;
  var nextSearch = locationState && locationState.nextSearch;
  var defaultRedirectUrl = nextPathName ? nextPathName + nextSearch : "/";
  var _a11 = options !== null && options !== void 0 ? options : {}, onSuccess = _a11.onSuccess, onError = _a11.onError, onSettled = _a11.onSettled, queryOptions2 = __rest49(_a11, ["onSuccess", "onError", "onSettled"]);
  var handleCallbackPromise;
  var queryResult = useQuery(__assign55({ queryKey: ["auth", "handleCallback"], queryFn: function(_a12) {
    var signal = _a12.signal;
    if (!handleCallbackPromise) {
      handleCallbackPromise = authProvider && typeof authProvider.handleCallback === "function" ? authProvider.handleCallback({ signal }).then(function(result) {
        return result !== null && result !== void 0 ? result : null;
      }) : Promise.resolve();
    }
    return handleCallbackPromise;
  }, retry: false }, queryOptions2));
  var onSuccessEvent = useEvent(onSuccess !== null && onSuccess !== void 0 ? onSuccess : function(data) {
    var _a12;
    var previousLocation = localStorage.getItem(PreviousLocationStorageKey);
    var redirectTo = (_a12 = data === null || data === void 0 ? void 0 : data.redirectTo) !== null && _a12 !== void 0 ? _a12 : previousLocation;
    if (redirectTo === false) {
      return;
    }
    redirect(redirectTo !== null && redirectTo !== void 0 ? redirectTo : defaultRedirectUrl);
  });
  var onErrorEvent = useEvent(onError !== null && onError !== void 0 ? onError : noop12);
  var onSettledEvent = useEvent(onSettled !== null && onSettled !== void 0 ? onSettled : noop12);
  (0, import_react131.useEffect)(function() {
    if (queryResult.error == null || queryResult.isFetching)
      return;
    onErrorEvent(queryResult.error);
  }, [onErrorEvent, queryResult.error, queryResult.isFetching]);
  (0, import_react131.useEffect)(function() {
    if (queryResult.data === void 0 || queryResult.isFetching)
      return;
    onSuccessEvent(queryResult.data);
  }, [onSuccessEvent, queryResult.data, queryResult.isFetching]);
  (0, import_react131.useEffect)(function() {
    if (queryResult.status === "pending" || queryResult.isFetching)
      return;
    onSettledEvent(queryResult.data, queryResult.error);
  }, [
    onSettledEvent,
    queryResult.data,
    queryResult.error,
    queryResult.status,
    queryResult.isFetching
  ]);
  return queryResult;
};
var PreviousLocationStorageKey = "@react-admin/nextPathname";
var noop12 = function() {
};

// node_modules/ra-core/dist/esm/auth/useIsAuthPending.js
var __rest50 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useIsAuthPending = function(params) {
  var action = params.action, props = __rest50(params, ["action"]);
  var queryClient = useQueryClient();
  var authProvider = useAuthProvider_default();
  var resource = useResourceContext(props);
  if (!authProvider) {
    return false;
  }
  var authQueryState = queryClient.getQueryState(["auth", "checkAuth", {}]);
  var canAccessQueryState = queryClient.getQueryState([
    "auth",
    "canAccess",
    { action, resource }
  ]);
  if ((authQueryState === null || authQueryState === void 0 ? void 0 : authQueryState.status) === "pending" || authProvider.canAccess && (canAccessQueryState === null || canAccessQueryState === void 0 ? void 0 : canAccessQueryState.status) === "pending") {
    return true;
  }
  return false;
};

// node_modules/ra-core/dist/esm/auth/useRequireAccess.js
var import_react132 = __toESM(require_react());
var __rest51 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var useRequireAccess = function(params) {
  var _a11 = useCanAccess(params), canAccess = _a11.canAccess, data = _a11.data, error = _a11.error, rest = __rest51(_a11, ["canAccess", "data", "error"]);
  var navigate = useNavigate();
  var basename = useBasename();
  (0, import_react132.useEffect)(function() {
    if (rest.isPending)
      return;
    if (canAccess === false) {
      navigate("".concat(basename, "/access-denied"));
    }
  }, [basename, canAccess, navigate, rest.isPending]);
  (0, import_react132.useEffect)(function() {
    if (error) {
      navigate("".concat(basename, "/authentication-error"));
    }
  }, [basename, navigate, error]);
  return rest;
};

// node_modules/ra-core/dist/esm/auth/addRefreshAuthToAuthProvider.js
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator21 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var addRefreshAuthToAuthProvider = function(provider, refreshAuth) {
  var proxy = new Proxy(provider, {
    get: function(_, name) {
      var _this = this;
      var shouldIntercept = AuthProviderInterceptedMethods.includes(name.toString()) && provider[name.toString()] != null;
      if (shouldIntercept) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return __awaiter21(_this, void 0, void 0, function() {
            return __generator21(this, function(_a11) {
              switch (_a11.label) {
                case 0:
                  return [4, refreshAuth()];
                case 1:
                  _a11.sent();
                  return [2, provider[name.toString()].apply(provider, args)];
              }
            });
          });
        };
      }
      return provider[name.toString()];
    }
  });
  return proxy;
};
var AuthProviderInterceptedMethods = [
  "checkAuth",
  "getIdentity",
  "getPermissions"
];

// node_modules/ra-core/dist/esm/auth/addRefreshAuthToDataProvider.js
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator22 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var addRefreshAuthToDataProvider = function(provider, refreshAuth) {
  var proxy = new Proxy(provider, {
    get: function(_, name) {
      var _this = this;
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter22(_this, void 0, void 0, function() {
          return __generator22(this, function(_a11) {
            switch (_a11.label) {
              case 0:
                return [4, refreshAuth()];
              case 1:
                _a11.sent();
                return [2, provider[name.toString()].apply(provider, args)];
            }
          });
        });
      };
    }
  });
  return proxy;
};

// node_modules/ra-core/dist/esm/routing/useGetPathForRecord.js
var useGetPathForRecord = function(options) {
  if (options === void 0) {
    options = {};
  }
  var link = (options || {}).link;
  var record = useRecordContext(options);
  var resource = useResourceContext(options);
  if (!resource) {
    throw new Error("Cannot generate a link for a record without a resource. You must use useGetPathForRecord within a ResourceContextProvider, or pass a resource prop.");
  }
  var resourceDefinition = useResourceDefinition(options);
  var createPath = useCreatePath();
  var _a11 = (0, import_react133.useState)(link && typeof link !== "function" && record != null ? createPath({
    resource,
    id: record.id,
    type: link
  }) : false), path = _a11[0], setPath = _a11[1];
  var canAccessShow = useCanAccess({
    action: "show",
    resource,
    record,
    enabled: link == null && resourceDefinition.hasShow
  }).canAccess;
  var canAccessEdit = useCanAccess({
    action: "edit",
    resource,
    record,
    enabled: link == null && resourceDefinition.hasEdit
  }).canAccess;
  (0, import_react133.useEffect)(function() {
    if (!record)
      return;
    if (link === false) {
      setPath(false);
      return;
    }
    if (link == null) {
      if (resourceDefinition.hasShow && canAccessShow) {
        setPath(createPath({
          resource,
          id: record.id,
          type: "show"
        }));
        return;
      }
      if (resourceDefinition.hasEdit && canAccessEdit) {
        setPath(createPath({
          resource,
          id: record.id,
          type: "edit"
        }));
        return;
      }
    }
    if (typeof link === "function") {
      var linkResult = link(record, resource);
      if (linkResult instanceof Promise) {
        linkResult.then(function(resolvedPath) {
          return setPath(resolvedPath);
        });
        return;
      }
      setPath(linkResult ? createPath({
        resource,
        id: record.id,
        type: linkResult
      }) : false);
      return;
    }
    if (link) {
      setPath(createPath({
        resource,
        id: record.id,
        type: link
      }));
    }
  }, [
    createPath,
    canAccessShow,
    canAccessEdit,
    link,
    record,
    resource,
    resourceDefinition.hasEdit,
    resourceDefinition.hasShow
  ]);
  return path;
};

// node_modules/ra-core/dist/esm/routing/useGetPathForRecordCallback.js
var import_react136 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/useResourceDefinitionContext.js
var import_react135 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/ResourceDefinitionContext.js
var React49 = __toESM(require_react());
var import_react134 = __toESM(require_react());
var import_isEqual8 = __toESM(require_isEqual());
var __assign56 = function() {
  __assign56 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign56.apply(this, arguments);
};
var __rest52 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var ResourceDefinitionContext = (0, import_react134.createContext)({
  definitions: {},
  register: function() {
  },
  unregister: function() {
  }
});
var ResourceDefinitionContextProvider = function(_a11) {
  var _b = _a11.definitions, defaultDefinitions = _b === void 0 ? {} : _b, children = _a11.children;
  var _c = (0, import_react134.useState)(defaultDefinitions), definitions = _c[0], setState = _c[1];
  var register = (0, import_react134.useCallback)(function(config) {
    setState(function(prev) {
      var _a12;
      return (0, import_isEqual8.default)(prev[config.name], config) ? prev : __assign56(__assign56({}, prev), (_a12 = {}, _a12[config.name] = config, _a12));
    });
  }, []);
  var unregister = (0, import_react134.useCallback)(function(config) {
    setState(function(prev) {
      var _a12 = prev, _b2 = config.name, _ = _a12[_b2], rest = __rest52(_a12, [typeof _b2 === "symbol" ? _b2 : _b2 + ""]);
      return rest;
    });
  }, []);
  var contextValue = (0, import_react134.useMemo)(
    function() {
      return { definitions, register, unregister };
    },
    [definitions]
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return React49.createElement(ResourceDefinitionContext.Provider, { value: contextValue }, children);
};

// node_modules/ra-core/dist/esm/core/useResourceDefinitionContext.js
var useResourceDefinitionContext = function() {
  return (0, import_react135.useContext)(ResourceDefinitionContext);
};

// node_modules/ra-core/dist/esm/core/useResourceDefinitions.js
var useResourceDefinitions = function() {
  return useResourceDefinitionContext().definitions;
};

// node_modules/ra-core/dist/esm/routing/useGetPathForRecordCallback.js
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator23 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useGetPathForRecordCallback = function(options) {
  if (options === void 0) {
    options = {};
  }
  var resource = useResourceContext(options);
  var resourceDefinitions = useResourceDefinitions();
  var createPath = useCreatePath();
  var canAccess = useCanAccessCallback();
  return (0, import_react136.useCallback)(function(params) {
    return __awaiter23(void 0, void 0, void 0, function() {
      var _a11, link, record, finalResource, resourceDefinition, _b, canAccessShow, canAccessEdit, linkFunc, linkResult, linkResultIsPromise, resolvedLink;
      var _c, _d;
      return __generator23(this, function(_e) {
        switch (_e.label) {
          case 0:
            _a11 = params || {}, link = _a11.link, record = _a11.record;
            finalResource = (_c = params.resource) !== null && _c !== void 0 ? _c : resource;
            if (!finalResource) {
              throw new Error("Cannot generate a link for a record without a resource. You must use useGetPathForRecordCallback within a ResourceContextProvider, or pass a resource parameter.");
            }
            resourceDefinition = (_d = resourceDefinitions[finalResource]) !== null && _d !== void 0 ? _d : {};
            if (record == null || link === false) {
              return [2, false];
            }
            if (!(link == null)) return [3, 2];
            return [4, Promise.all([
              resourceDefinition.hasShow ? canAccess({
                action: "show",
                resource: finalResource,
                record
              }) : Promise.resolve(false),
              resourceDefinition.hasEdit ? canAccess({
                action: "edit",
                resource: finalResource,
                record
              }) : Promise.resolve(false)
            ])];
          case 1:
            _b = _e.sent(), canAccessShow = _b[0], canAccessEdit = _b[1];
            if (canAccessShow) {
              return [2, createPath({
                resource: finalResource,
                id: record.id,
                type: "show"
              })];
            }
            if (canAccessEdit) {
              return [2, createPath({
                resource: finalResource,
                id: record.id,
                type: "edit"
              })];
            }
            return [2, false];
          case 2:
            linkFunc = typeof link === "function" ? link : function() {
              return link;
            };
            linkResult = linkFunc(record, finalResource);
            if (linkResult === false) {
              return [2, false];
            }
            linkResultIsPromise = isPromise(linkResult);
            if (!linkResultIsPromise) return [3, 4];
            return [4, linkResult];
          case 3:
            resolvedLink = _e.sent();
            if (resolvedLink === false) {
              return [
                2
                /*return*/
              ];
            }
            return [2, createPath({
              resource: finalResource,
              id: record.id,
              type: resolvedLink
            })];
          case 4:
            return [2, createPath({
              resource: finalResource,
              id: record.id,
              type: linkResult
            })];
        }
      });
    });
  }, [canAccess, createPath, resourceDefinitions, resource]);
};
var isPromise = function(value) {
  return value && typeof value.then === "function";
};

// node_modules/ra-core/dist/esm/routing/useRedirect.js
var import_react137 = __toESM(require_react());
var __assign57 = function() {
  __assign57 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign57.apply(this, arguments);
};
var useRedirect = function() {
  var navigate = useNavigate();
  var basename = useBasename();
  var createPath = useCreatePath();
  return (0, import_react137.useCallback)(function(redirectTo, resource, id, data, state) {
    if (resource === void 0) {
      resource = "";
    }
    if (state === void 0) {
      state = {};
    }
    if (!redirectTo) {
      return;
    } else if (typeof redirectTo === "function") {
      var target = redirectTo(resource, id, data);
      var absoluteTarget = typeof target === "string" ? "".concat(basename, "/").concat(target) : __assign57({ pathname: "".concat(basename, "/").concat(target.pathname) }, target);
      navigate(absoluteTarget, {
        state: __assign57({ _scrollToTop: true }, state)
      });
      return;
    } else if (typeof redirectTo === "string" && redirectTo.startsWith("http") && window) {
      window.location.href = redirectTo;
      return;
    } else {
      navigate(createPath({ resource, id, type: redirectTo }), {
        state: (
          // We force the scrollToTop except when navigating to a list
          // where this is already done by <RestoreScrollPosition> in <Resource>
          redirectTo === "list" ? state : __assign57({ _scrollToTop: true }, state)
        )
      });
      return;
    }
  }, [navigate, basename, createPath]);
};

// node_modules/ra-core/dist/esm/routing/useResetErrorBoundaryOnLocationChange.js
var import_react138 = __toESM(require_react());
var useResetErrorBoundaryOnLocationChange = function(resetErrorBoundary) {
  var pathname = useLocation().pathname;
  var originalPathname = (0, import_react138.useRef)(pathname);
  (0, import_react138.useEffect)(function() {
    if (pathname !== originalPathname.current) {
      resetErrorBoundary();
    }
  }, [pathname, resetErrorBoundary]);
};

// node_modules/ra-core/dist/esm/routing/useScrollToTop.js
var import_react139 = __toESM(require_react());
var useScrollToTop = function() {
  var location = useLocation();
  (0, import_react139.useEffect)(function() {
    var _a11;
    if (((_a11 = location.state) === null || _a11 === void 0 ? void 0 : _a11._scrollToTop) && typeof window != "undefined" && typeof window.scrollTo === "function") {
      window.scrollTo(0, 0);
    }
  }, [location]);
};

// node_modules/ra-core/dist/esm/routing/TestMemoryRouter.js
var React50 = __toESM(require_react());
var __assign58 = function() {
  __assign58 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign58.apply(this, arguments);
};
var __rest53 = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var UseLocation = function(_a11) {
  var locationCallback = _a11.locationCallback;
  var location = useLocation();
  locationCallback(location);
  return null;
};
var UseNavigate = function(_a11) {
  var navigateCallback = _a11.navigateCallback;
  var navigate = useNavigate();
  navigateCallback(navigate);
  return null;
};
var TestMemoryRouter = function(_a11) {
  var children = _a11.children, locationCallback = _a11.locationCallback, navigateCallback = _a11.navigateCallback, rest = __rest53(_a11, ["children", "locationCallback", "navigateCallback"]);
  var router = createMemoryRouter([
    {
      path: "*",
      element: React50.createElement(
        React50.Fragment,
        null,
        children,
        locationCallback && React50.createElement(UseLocation, { locationCallback }),
        navigateCallback && React50.createElement(UseNavigate, { navigateCallback })
      )
    }
  ], __assign58({ future: {
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_relativeSplatPath: false,
    v7_skipActionErrorRevalidation: false
  } }, rest));
  return React50.createElement(RouterProvider2, {
    router,
    // @ts-expect-error react-router types are not up-to-date
    future: { v7_startTransition: false, v7_relativeSplatPath: false }
  });
};

// node_modules/ra-core/dist/esm/routing/useSplatPathBase.js
var useSplatPathBase = function() {
  var location = useLocation();
  var params = useParams();
  var splatPathRelativePart = params["*"];
  var splatPathBase = location.pathname.replace(new RegExp("/".concat(splatPathRelativePart, "$")), "");
  return splatPathBase;
};

// node_modules/ra-core/dist/esm/preferences/PreferencesEditorContextProvider.js
var React51 = __toESM(require_react());
var import_react141 = __toESM(require_react());

// node_modules/ra-core/dist/esm/preferences/PreferencesEditorContext.js
var import_react140 = __toESM(require_react());
var PreferencesEditorContext = (0, import_react140.createContext)(void 0);

// node_modules/ra-core/dist/esm/preferences/PreferencesEditorContextProvider.js
var PreferencesEditorContextProvider = function(_a11) {
  var children = _a11.children;
  var _b = (0, import_react141.useState)(false), isEnabled = _b[0], setIsEnabled = _b[1];
  var _c = (0, import_react141.useState)(null), editor = _c[0], setEditor = _c[1];
  var _d = (0, import_react141.useState)(null), preferenceKey = _d[0], setPreferenceKey = _d[1];
  var _e = (0, import_react141.useState)(null), path = _e[0], setPath = _e[1];
  var _f = (0, import_react141.useState)(null), title = _f[0], setTitleString = _f[1];
  var _g = (0, import_react141.useState)(), titleOptions = _g[0], setTitleOptions = _g[1];
  var enable = (0, import_react141.useCallback)(function() {
    return setIsEnabled(true);
  }, []);
  var disable = (0, import_react141.useCallback)(function() {
    setIsEnabled(false);
    setEditor(null);
  }, []);
  var setTitle = (0, import_react141.useCallback)(function(title2, titleOptions2) {
    setTitleString(title2);
    setTitleOptions(titleOptions2);
  }, []);
  var context = (0, import_react141.useMemo)(function() {
    return {
      editor,
      setEditor,
      preferenceKey,
      setPreferenceKey,
      title,
      titleOptions,
      setTitle,
      isEnabled,
      disable,
      enable,
      path,
      setPath
    };
  }, [
    disable,
    enable,
    editor,
    preferenceKey,
    isEnabled,
    path,
    setPath,
    title,
    titleOptions,
    setTitle
  ]);
  return React51.createElement(PreferencesEditorContext.Provider, { value: context }, children);
};

// node_modules/ra-core/dist/esm/core/CoreAdminContext.js
var defaultStore2 = memoryStore();
var CoreAdminContext = function(props) {
  var authProvider = props.authProvider, basename = props.basename, _a11 = props.dataProvider, dataProvider = _a11 === void 0 ? defaultDataProvider : _a11, i18nProvider = props.i18nProvider, _b = props.store, store = _b === void 0 ? defaultStore2 : _b, children = props.children, queryClient = props.queryClient;
  if (!dataProvider) {
    throw new Error("Missing dataProvider prop.\nReact-admin requires a valid dataProvider function to work.");
  }
  var finalQueryClient = (0, import_react142.useMemo)(function() {
    return queryClient || new QueryClient();
  }, [queryClient]);
  var finalAuthProvider = (0, import_react142.useMemo)(function() {
    return authProvider instanceof Function ? convertLegacyAuthProvider_default(authProvider) : authProvider;
  }, [authProvider]);
  var finalDataProvider = (0, import_react142.useMemo)(function() {
    return dataProvider instanceof Function ? convertLegacyDataProvider_default(dataProvider) : dataProvider;
  }, [dataProvider]);
  return React52.createElement(
    AuthContext.Provider,
    { value: finalAuthProvider },
    React52.createElement(
      DataProviderContext_default.Provider,
      { value: finalDataProvider },
      React52.createElement(
        StoreContextProvider,
        { value: store },
        React52.createElement(
          PreferencesEditorContextProvider,
          null,
          React52.createElement(
            QueryClientProvider,
            { client: finalQueryClient },
            React52.createElement(
              AdminRouter,
              { basename },
              React52.createElement(
                I18nContextProvider,
                { value: i18nProvider },
                React52.createElement(
                  NotificationContextProvider,
                  null,
                  React52.createElement(
                    UndoableMutationsContextProvider,
                    null,
                    React52.createElement(ResourceDefinitionContextProvider, null, children)
                  )
                )
              )
            )
          )
        )
      )
    )
  );
};

// node_modules/ra-core/dist/esm/core/CoreAdminUI.js
var React56 = __toESM(require_react());
var import_react148 = __toESM(require_react());

// node_modules/react-error-boundary/dist/react-error-boundary.development.esm.js
var import_react143 = __toESM(require_react());
var ErrorBoundaryContext = (0, import_react143.createContext)(null);
var initialState = {
  didCatch: false,
  error: null
};
var ErrorBoundary = class extends import_react143.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = (0, import_react143.createElement)(FallbackComponent, props);
      } else if (fallback !== void 0) {
        childToRender = fallback;
      } else {
        {
          console.error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
        }
        throw error;
      }
    }
    return (0, import_react143.createElement)(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
};
function hasArrayChanged() {
  let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));
}

// node_modules/ra-core/dist/esm/core/CoreAdminRoutes.js
var React55 = __toESM(require_react());
var import_react146 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/useConfigureAdminRouterFromChildren.js
var React53 = __toESM(require_react());
var import_react144 = __toESM(require_react());
var __assign59 = function() {
  __assign59 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign59.apply(this, arguments);
};
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator24 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useConfigureAdminRouterFromChildren = function(children) {
  var _a11 = usePermissions_default(), permissions = _a11.permissions, isPending = _a11.isPending;
  var _b = useRoutesAndResourcesFromChildren(children, permissions, isPending), routesAndResources = _b[0], status = _b[1];
  useRegisterResources(routesAndResources.resources, permissions);
  return {
    customRoutesWithLayout: routesAndResources.customRoutesWithLayout,
    customRoutesWithoutLayout: routesAndResources.customRoutesWithoutLayout,
    status,
    resources: routesAndResources.resources
  };
};
var useRoutesAndResourcesFromChildren = function(children, permissions, isLoading) {
  var doLogout = useLogout_default();
  var _a11 = useRoutesAndResourcesState(getRoutesAndResourceFromNodes(children)), routesAndResources = _a11[0], setRoutesAndResources = _a11[1], mergeRoutesAndResources = _a11[2];
  var _b = (0, import_react144.useState)(function() {
    return getStatus(__assign59({ children }, routesAndResources));
  }), status = _b[0], setStatus = _b[1];
  if (!status) {
    throw new Error("Status should be defined");
  }
  (0, import_react144.useEffect)(function() {
    var resolveChildFunction = function(childFunc) {
      return __awaiter24(void 0, void 0, void 0, function() {
        var childrenFuncResult;
        return __generator24(this, function(_a12) {
          try {
            childrenFuncResult = childFunc(permissions);
            if (childrenFuncResult === null || childrenFuncResult === void 0 ? void 0 : childrenFuncResult.then) {
              childrenFuncResult.then(function(resolvedChildren) {
                mergeRoutesAndResources(getRoutesAndResourceFromNodes(resolvedChildren));
                setStatus("ready");
              });
            } else {
              mergeRoutesAndResources(getRoutesAndResourceFromNodes(childrenFuncResult));
              setStatus("ready");
            }
          } catch (error) {
            console.error(error);
            doLogout();
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    var updateFromChildren = function() {
      return __awaiter24(void 0, void 0, void 0, function() {
        var functionChild, newRoutesAndResources;
        return __generator24(this, function(_a12) {
          functionChild = getSingleChildFunction(children);
          newRoutesAndResources = getRoutesAndResourceFromNodes(children);
          setRoutesAndResources(newRoutesAndResources);
          setStatus(!!functionChild ? "loading" : newRoutesAndResources.resources.length > 0 || newRoutesAndResources.customRoutesWithLayout.length > 0 || newRoutesAndResources.customRoutesWithoutLayout.length > 0 ? "ready" : "empty");
          if (functionChild) {
            resolveChildFunction(functionChild);
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    if (!isLoading) {
      updateFromChildren();
    }
  }, [
    children,
    doLogout,
    isLoading,
    mergeRoutesAndResources,
    permissions,
    setRoutesAndResources,
    setStatus
  ]);
  return [routesAndResources, status];
};
var useRoutesAndResourcesState = function(initialState2) {
  var _a11 = (0, import_react144.useState)(initialState2), routesAndResources = _a11[0], setRoutesAndResources = _a11[1];
  var mergeRoutesAndResources = (0, import_react144.useCallback)(function(newRoutesAndResources) {
    setRoutesAndResources(function(previous) {
      return {
        customRoutesWithLayout: previous.customRoutesWithLayout.concat(newRoutesAndResources.customRoutesWithLayout),
        customRoutesWithoutLayout: previous.customRoutesWithoutLayout.concat(newRoutesAndResources.customRoutesWithoutLayout),
        resources: previous.resources.concat(newRoutesAndResources.resources)
      };
    });
  }, []);
  return [routesAndResources, setRoutesAndResources, mergeRoutesAndResources];
};
var useRegisterResources = function(resources, permissions) {
  var _a11 = useResourceDefinitionContext(), register = _a11.register, unregister = _a11.unregister;
  (0, import_react144.useEffect)(function() {
    resources.forEach(function(resource) {
      if (typeof resource.type.registerResource === "function") {
        var definition = resource.type.registerResource(resource.props, permissions);
        register(definition);
      } else {
        throw new Error("When using a custom Resource element, it must have a static registerResource method accepting its props and returning a ResourceDefinition");
      }
    });
    return function() {
      resources.forEach(function(resource) {
        if (typeof resource.type.registerResource === "function") {
          var definition = resource.type.registerResource(resource.props, permissions);
          unregister(definition);
        } else {
          throw new Error("When using a custom Resource element, it must have a static registerResource method accepting its props and returning a ResourceDefinition");
        }
      });
    };
  }, [permissions, register, resources, unregister]);
};
var getStatus = function(_a11) {
  var children = _a11.children, resources = _a11.resources, customRoutesWithLayout = _a11.customRoutesWithLayout, customRoutesWithoutLayout = _a11.customRoutesWithoutLayout;
  return getSingleChildFunction(children) ? "loading" : resources.length > 0 || customRoutesWithLayout.length > 0 || customRoutesWithoutLayout.length > 0 ? "ready" : "empty";
};
var getSingleChildFunction = function(children) {
  var childrenArray = Array.isArray(children) ? children : [children];
  var functionChildren = childrenArray.filter(function(child) {
    return typeof child === "function";
  });
  if (functionChildren.length > 1) {
    throw new Error("You can only provide one function child to AdminRouter");
  }
  if (functionChildren.length === 0) {
    return null;
  }
  return functionChildren[0];
};
var getRoutesAndResourceFromNodes = function(children) {
  var customRoutesWithLayout = [];
  var customRoutesWithoutLayout = [];
  var resources = [];
  if (typeof children === "function") {
    return {
      customRoutesWithLayout: [],
      customRoutesWithoutLayout: [],
      resources: []
    };
  }
  import_react144.Children.forEach(children, function(element) {
    if (!React53.isValidElement(element)) {
      return;
    }
    if (element.type === import_react144.Fragment) {
      var customRoutesFromFragment = getRoutesAndResourceFromNodes(element.props.children);
      customRoutesWithLayout.push.apply(customRoutesWithLayout, customRoutesFromFragment.customRoutesWithLayout);
      customRoutesWithoutLayout.push.apply(customRoutesWithoutLayout, customRoutesFromFragment.customRoutesWithoutLayout);
      resources.push.apply(resources, customRoutesFromFragment.resources);
    }
    if (element.type.raName === "CustomRoutes") {
      var customRoutesElement = element;
      if (customRoutesElement.props.noLayout) {
        customRoutesWithoutLayout.push(customRoutesElement.props.children);
      } else {
        customRoutesWithLayout.push(customRoutesElement.props.children);
      }
    } else if (element.type.raName === "Resource") {
      resources.push(element);
    }
  });
  return {
    customRoutesWithLayout,
    customRoutesWithoutLayout,
    resources
  };
};

// node_modules/ra-core/dist/esm/core/HasDashboardContext.js
var import_react145 = __toESM(require_react());
var HasDashboardContext = (0, import_react145.createContext)(false);
var HasDashboardContextProvider = HasDashboardContext.Provider;
var useHasDashboard = function() {
  return (0, import_react145.useContext)(HasDashboardContext);
};

// node_modules/ra-core/dist/esm/core/NavigateToFirstResource.js
var React54 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/useFirstResourceWithListAccess.js
var useFirstResourceWithListAccess = function() {
  var isPendingAuthenticated = useAuthenticated().isPending;
  var resources = useResourceDefinitions();
  var resourcesNames = Object.keys(resources).filter(function(resource) {
    return resources[resource].hasList;
  });
  var _a11 = useCanAccessResources({
    action: "list",
    resources: resourcesNames,
    enabled: !isPendingAuthenticated
  }), canAccess = _a11.canAccess, isPending = _a11.isPending;
  var firstResourceWithListAccess = resourcesNames.find(function(resource) {
    return canAccess && canAccess[resource] === true;
  });
  return { resource: firstResourceWithListAccess, isPending };
};

// node_modules/ra-core/dist/esm/core/NavigateToFirstResource.js
var NavigateToFirstResource = function(_a11) {
  var LoadingPage = _a11.loading;
  var _b = useFirstResourceWithListAccess(), resource = _b.resource, isPending = _b.isPending;
  var createPath = useCreatePath();
  if (isPending) {
    return React54.createElement(LoadingPage, null);
  }
  if (resource) {
    return React54.createElement(Navigate, { to: createPath({
      resource,
      type: "list"
    }), replace: true });
  }
};

// node_modules/ra-core/dist/esm/core/CoreAdminRoutes.js
var CoreAdminRoutes = function(props) {
  useScrollToTop();
  var _a11 = useConfigureAdminRouterFromChildren(props.children), customRoutesWithLayout = _a11.customRoutesWithLayout, customRoutesWithoutLayout = _a11.customRoutesWithoutLayout, status = _a11.status, resources = _a11.resources;
  var Layout = props.layout, CatchAll = props.catchAll, dashboard = props.dashboard, LoadingPage = props.loading, requireAuth = props.requireAuth, Ready = props.ready, _b = props.authenticationError, AuthenticationError = _b === void 0 ? Noop : _b, _c = props.accessDenied, AccessDenied = _c === void 0 ? Noop : _c;
  var _d = useAuthState_default(
    void 0,
    // do not log the user out on failure to allow access to custom routes with no layout
    false,
    { enabled: requireAuth }
  ), authenticated = _d.authenticated, isPendingAuthenticated = _d.isPending;
  if (status === "empty") {
    if (!Ready) {
      throw new Error("The admin is empty. Please provide an empty component, or pass Resource or CustomRoutes as children.");
    }
    return React55.createElement(Ready, null);
  }
  if (status === "loading" || requireAuth && isPendingAuthenticated) {
    return React55.createElement(
      Routes,
      null,
      customRoutesWithoutLayout,
      React55.createElement(Route, { path: "*", element: React55.createElement(
        "div",
        { style: { height: "100vh" } },
        React55.createElement(LoadingPage, null)
      ) })
    );
  }
  if (requireAuth && (isPendingAuthenticated || !authenticated)) {
    return React55.createElement(
      Routes,
      null,
      customRoutesWithoutLayout,
      React55.createElement(Route, { path: "*", element: React55.createElement(LogoutOnMount, null) })
    );
  }
  return React55.createElement(
    Routes,
    null,
    customRoutesWithoutLayout,
    React55.createElement(Route, { path: "/*", element: React55.createElement(
      HasDashboardContextProvider,
      { value: !!dashboard },
      React55.createElement(
        Layout,
        null,
        React55.createElement(
          Routes,
          null,
          customRoutesWithLayout,
          import_react146.Children.map(resources, function(resource) {
            return React55.createElement(Route, { key: resource.props.name, path: "".concat(resource.props.name, "/*"), element: resource });
          }),
          React55.createElement(Route, { path: "/", element: dashboard ? React55.createElement(WithPermissions_default, { authParams: defaultAuthParams2, component: dashboard, loading: LoadingPage }) : React55.createElement(NavigateToFirstResource, { loading: LoadingPage }) }),
          React55.createElement(Route, { path: "/authentication-error", element: React55.createElement(AuthenticationError, null) }),
          React55.createElement(Route, { path: "/access-denied", element: React55.createElement(AccessDenied, null) }),
          React55.createElement(Route, { path: "*", element: React55.createElement(CatchAll, null) })
        )
      )
    ) })
  );
};
var defaultAuthParams2 = { params: { route: "dashboard" } };
var Noop = function() {
  return null;
};

// node_modules/ra-core/dist/esm/core/DefaultTitleContext.js
var import_react147 = __toESM(require_react());
var DefaultTitleContext = (0, import_react147.createContext)("React Admin");
var DefaultTitleContextProvider = DefaultTitleContext.Provider;
var useDefaultTitle = function() {
  return (0, import_react147.useContext)(DefaultTitleContext);
};

// node_modules/ra-core/dist/esm/core/CoreAdminUI.js
var DefaultLayout = function(_a11) {
  var children = _a11.children;
  return React56.createElement(React56.Fragment, null, children);
};
var DefaultError = function(_a11) {
  var error = _a11.error, errorInfo = _a11.errorInfo, resetErrorBoundary = _a11.resetErrorBoundary;
  useResetErrorBoundaryOnLocationChange(resetErrorBoundary);
  return React56.createElement(
    "div",
    null,
    React56.createElement("h1", null, "Error"),
    React56.createElement(
      "pre",
      null,
      error.message,
      errorInfo === null || errorInfo === void 0 ? void 0 : errorInfo.componentStack
    )
  );
};
var CoreAdminUI = function(props) {
  var _a11 = (0, import_react148.useState)({}), errorInfo = _a11[0], setErrorInfo = _a11[1];
  var _b = props.authCallbackPage, LoginCallbackPage = _b === void 0 ? false : _b, _c = props.catchAll, catchAll = _c === void 0 ? Noop2 : _c, children = props.children, dashboard = props.dashboard, _d = props.disableTelemetry, disableTelemetry = _d === void 0 ? false : _d, _e = props.error, ErrorComponent = _e === void 0 ? DefaultError : _e, _f = props.layout, layout = _f === void 0 ? DefaultLayout : _f, _g = props.loading, loading = _g === void 0 ? Noop2 : _g, _h = props.loginPage, LoginPage = _h === void 0 ? false : _h, _j = props.ready, ready = _j === void 0 ? Ready_default : _j, _k = props.requireAuth, requireAuth = _k === void 0 ? false : _k, _l = props.title, title = _l === void 0 ? "React Admin" : _l, _m = props.authenticationError, authenticationError = _m === void 0 ? Noop2 : _m, _o = props.accessDenied, accessDenied = _o === void 0 ? Noop2 : _o;
  (0, import_react148.useEffect)(function() {
    if (disableTelemetry || true) {
      return;
    }
    var img = new Image();
    img.src = "https://react-admin-telemetry.marmelab.com/react-admin-telemetry?domain=".concat(window.location.hostname);
  }, [disableTelemetry]);
  var handleError = function(error, info) {
    return setErrorInfo(info);
  };
  return React56.createElement(
    DefaultTitleContextProvider,
    { value: title },
    React56.createElement(
      ErrorBoundary,
      { onError: handleError, fallbackRender: function(_a12) {
        var error = _a12.error, resetErrorBoundary = _a12.resetErrorBoundary;
        return React56.createElement(
          "div",
          { style: { minHeight: "100vh" } },
          React56.createElement(ErrorComponent, { error, errorInfo, resetErrorBoundary })
        );
      } },
      React56.createElement(
        Routes,
        null,
        LoginPage !== false && LoginPage !== true ? React56.createElement(Route, { path: "/login", element: createOrGetElement(LoginPage) }) : null,
        LoginCallbackPage !== false && LoginCallbackPage !== true ? React56.createElement(Route, { path: "/auth-callback", element: createOrGetElement(LoginCallbackPage) }) : null,
        React56.createElement(Route, { path: "/*", element: React56.createElement(CoreAdminRoutes, { catchAll, dashboard, layout, loading, requireAuth, ready, authenticationError, accessDenied }, children) })
      )
    )
  );
};
var createOrGetElement = function(el) {
  return (0, import_react148.isValidElement)(el) ? el : (0, import_react148.createElement)(el);
};
var Noop2 = function() {
  return null;
};

// node_modules/ra-core/dist/esm/core/CoreAdmin.js
var CoreAdmin = function(props) {
  var accessDenied = props.accessDenied, authenticationError = props.authenticationError, authProvider = props.authProvider, basename = props.basename, catchAll = props.catchAll, children = props.children, dashboard = props.dashboard, dataProvider = props.dataProvider, disableTelemetry = props.disableTelemetry, error = props.error, i18nProvider = props.i18nProvider, layout = props.layout, loading = props.loading, loginPage = props.loginPage, queryClient = props.queryClient, ready = props.ready, requireAuth = props.requireAuth, store = props.store, _a11 = props.title, title = _a11 === void 0 ? "React Admin" : _a11;
  return React57.createElement(
    CoreAdminContext,
    { authProvider, basename, dataProvider, i18nProvider, queryClient, store },
    React57.createElement(CoreAdminUI, { accessDenied, authenticationError, catchAll, dashboard, disableTelemetry, error, layout, loading, loginPage, ready, requireAuth, title }, children)
  );
};

// node_modules/ra-core/dist/esm/core/CustomRoutes.js
var CustomRoutes = function(_props) {
  return null;
};
CustomRoutes.raName = "CustomRoutes";

// node_modules/ra-core/dist/esm/core/OptionalResourceContextProvider.js
var React59 = __toESM(require_react());

// node_modules/ra-core/dist/esm/core/ResourceContextProvider.js
var React58 = __toESM(require_react());
var ResourceContextProvider = function(_a11) {
  var children = _a11.children, value = _a11.value;
  return value ? React58.createElement(ResourceContext.Provider, { value }, children) : children;
};

// node_modules/ra-core/dist/esm/core/OptionalResourceContextProvider.js
var OptionalResourceContextProvider = function(_a11) {
  var value = _a11.value, children = _a11.children;
  return value ? React59.createElement(ResourceContextProvider, { value }, children) : children;
};

// node_modules/ra-core/dist/esm/core/Resource.js
var React60 = __toESM(require_react());
var import_react149 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());
var Resource = function(props) {
  var create = props.create, edit = props.edit, list = props.list, name = props.name, show = props.show;
  return React60.createElement(
    ResourceContextProvider,
    { value: name },
    React60.createElement(
      Routes,
      null,
      create && React60.createElement(Route, { path: "create/*", element: getElement(create) }),
      show && React60.createElement(Route, { path: ":id/show/*", element: getElement(show) }),
      edit && React60.createElement(Route, { path: ":id/*", element: getElement(edit) }),
      list && React60.createElement(Route, { path: "/*", element: React60.createElement(RestoreScrollPosition, { storeKey: "".concat(name, ".list.scrollPosition") }, getElement(list)) }),
      props.children
    )
  );
};
var getElement = function(ElementOrComponent) {
  if ((0, import_react149.isValidElement)(ElementOrComponent)) {
    return ElementOrComponent;
  }
  if ((0, import_react_is.isValidElementType)(ElementOrComponent)) {
    var Element_1 = ElementOrComponent;
    return React60.createElement(Element_1, null);
  }
  return null;
};
Resource.raName = "Resource";
Resource.registerResource = function(_a11) {
  var create = _a11.create, edit = _a11.edit, icon = _a11.icon, list = _a11.list, name = _a11.name, options = _a11.options, show = _a11.show, recordRepresentation = _a11.recordRepresentation, hasCreate = _a11.hasCreate, hasEdit = _a11.hasEdit, hasShow = _a11.hasShow;
  return {
    name,
    options,
    hasList: !!list,
    hasCreate: !!create || !!hasCreate,
    hasEdit: !!edit || !!hasEdit,
    hasShow: !!show || !!hasShow,
    icon,
    recordRepresentation
  };
};

// node_modules/ra-core/dist/esm/core/SourceContext.js
var import_react150 = __toESM(require_react());
var SourceContext = (0, import_react150.createContext)(void 0);
var defaultContextValue = {
  getSource: function(source) {
    return source;
  },
  getLabel: function(source) {
    return source;
  }
};
var SourceContextProvider = SourceContext.Provider;
var useSourceContext = function() {
  var context = (0, import_react150.useContext)(SourceContext);
  if (!context) {
    return defaultContextValue;
  }
  return context;
};
var useOptionalSourceContext = function() {
  return (0, import_react150.useContext)(SourceContext);
};

// node_modules/ra-core/dist/esm/core/useGetResourceLabel.js
var import_inflection = __toESM(require_inflection());
var useGetResourceLabel = function() {
  var translate = useTranslate();
  var definitions = useResourceDefinitions();
  return function(resource, count) {
    if (count === void 0) {
      count = 2;
    }
    var resourceDefinition = definitions[resource];
    var label = translate("resources.".concat(resource, ".name"), {
      smart_count: count,
      _: resourceDefinition && resourceDefinition.options && resourceDefinition.options.label ? translate(resourceDefinition.options.label, {
        smart_count: count,
        _: resourceDefinition.options.label
      }) : (0, import_inflection.humanize)((0, import_inflection.inflect)(resource, count))
    });
    return label;
  };
};

// node_modules/ra-core/dist/esm/core/useGetRecordRepresentation.js
var React61 = __toESM(require_react());
var import_react152 = __toESM(require_react());
var import_get14 = __toESM(require_get());

// node_modules/ra-core/dist/esm/core/useResourceDefinition.js
var import_react151 = __toESM(require_react());
var import_defaults2 = __toESM(require_defaults());
var useResourceDefinition = function(props) {
  var resource = useResourceContext(props);
  var resourceDefinitions = useResourceDefinitions();
  var _a11 = props || {}, hasCreate = _a11.hasCreate, hasEdit = _a11.hasEdit, hasList = _a11.hasList, hasShow = _a11.hasShow, recordRepresentation = _a11.recordRepresentation;
  var definition = (0, import_react151.useMemo)(function() {
    return (0, import_defaults2.default)({}, {
      hasCreate,
      hasEdit,
      hasList,
      hasShow,
      recordRepresentation
    }, resource ? resourceDefinitions[resource] : {});
  }, [
    resource,
    resourceDefinitions,
    hasCreate,
    hasEdit,
    hasList,
    hasShow,
    recordRepresentation
  ]);
  return definition;
};

// node_modules/ra-core/dist/esm/core/useGetRecordRepresentation.js
var useGetRecordRepresentation = function(resource) {
  var recordRepresentation = useResourceDefinition({ resource }).recordRepresentation;
  return (0, import_react152.useCallback)(function(record) {
    if (!record)
      return "";
    if (typeof recordRepresentation === "function") {
      return recordRepresentation(record);
    }
    if (typeof recordRepresentation === "string") {
      return (0, import_get14.default)(record, recordRepresentation);
    }
    if (React61.isValidElement(recordRepresentation)) {
      return recordRepresentation;
    }
    if ((record === null || record === void 0 ? void 0 : record.name) != null && (record === null || record === void 0 ? void 0 : record.name) !== "") {
      return record.name;
    }
    if ((record === null || record === void 0 ? void 0 : record.title) != null && (record === null || record === void 0 ? void 0 : record.title) !== "") {
      return record.title;
    }
    if ((record === null || record === void 0 ? void 0 : record.label) != null && (record === null || record === void 0 ? void 0 : record.label) !== "") {
      return record.label;
    }
    if ((record === null || record === void 0 ? void 0 : record.reference) != null && (record === null || record === void 0 ? void 0 : record.reference) !== "") {
      return record.reference;
    }
    return "#".concat(record.id);
  }, [recordRepresentation]);
};

// node_modules/ra-core/dist/esm/core/useWrappedSource.js
var useWrappedSource = function(source) {
  var sourceContext = useSourceContext();
  return sourceContext.getSource(source);
};

// node_modules/ra-core/dist/esm/i18n/useTranslateLabel.js
var useTranslateLabel = function() {
  var translate = useTranslate();
  var resourceFromContext = useResourceContext();
  var sourceContext = useOptionalSourceContext();
  return (0, import_react153.useCallback)(function(_a11) {
    var source = _a11.source, label = _a11.label, resource = _a11.resource;
    if (label === false || label === "") {
      return null;
    }
    if (label && typeof label !== "string") {
      return label;
    }
    return translate.apply(void 0, getFieldLabelTranslationArgs({
      label,
      defaultLabel: source ? sourceContext === null || sourceContext === void 0 ? void 0 : sourceContext.getLabel(source) : void 0,
      resource,
      resourceFromContext,
      source
    }));
  }, [resourceFromContext, translate, sourceContext]);
};

// node_modules/ra-core/dist/esm/i18n/index.js
var DEFAULT_LOCALE = "en";

// node_modules/ra-core/dist/esm/util/FieldTitle.js
var FieldTitle = function(props) {
  var source = props.source, label = props.label, resource = props.resource, isRequired2 = props.isRequired;
  var translateLabel = useTranslateLabel();
  if (label === true) {
    throw new Error("Label parameter must be a string, a ReactElement or false");
  }
  if (label === false || label === "") {
    return null;
  }
  if (label && typeof label !== "string") {
    return label;
  }
  return React62.createElement(
    "span",
    null,
    translateLabel({
      label,
      resource,
      source
    }),
    isRequired2 && React62.createElement("span", { "aria-hidden": "true" }, " *")
  );
};
FieldTitle.displayName = "FieldTitle";
var FieldTitle_default = (0, import_react154.memo)(FieldTitle);

// node_modules/ra-core/dist/esm/util/Ready.js
var React63 = __toESM(require_react());
var import_react155 = __toESM(require_react());
var __assign60 = function() {
  __assign60 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign60.apply(this, arguments);
};
var styles = {
  root: {
    width: "100vw",
    height: "100vh",
    display: "flex",
    flexDirection: "column",
    fontFamily: '"Roboto", sans-serif'
  },
  main: {
    flex: 1,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center",
    flexDirection: "column",
    background: "linear-gradient(135deg, #00023b 0%, #00023b 50%, #313264 100%)",
    color: "white",
    fontSize: "1.5em",
    fontWeight: "bold"
  },
  secondary: {
    height: "20vh",
    background: "#e8e8e8",
    color: "black",
    display: "flex",
    alignItems: "center",
    justifyContent: "space-evenly"
  },
  link: {
    textAlign: "center",
    width: 150,
    display: "block",
    textDecoration: "none",
    color: "black",
    opacity: 0.7
  },
  linkHovered: {
    opacity: 1
  },
  image: {
    width: 50
  },
  logo: {
    height: 100
  }
};
var Button = function(_a11) {
  var img = _a11.img, label = _a11.label, href = _a11.href;
  var _b = (0, import_react155.useState)(false), hovered = _b[0], setHovered = _b[1];
  return React63.createElement(
    "div",
    null,
    React63.createElement(
      "a",
      { href, style: hovered ? __assign60(__assign60({}, styles.link), styles.linkHovered) : styles.link, onMouseEnter: function() {
        return setHovered(true);
      }, onMouseLeave: function() {
        return setHovered(false);
      } },
      React63.createElement("img", { src: img, alt: label, style: styles.image }),
      React63.createElement("br", null),
      label
    )
  );
};
var Ready_default = function() {
  return false ? React63.createElement("span", null) : React63.createElement(
    "div",
    { style: styles.root },
    React63.createElement(
      "div",
      { style: styles.main },
      React63.createElement("img", { style: styles.logo, src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhbHF1ZV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgMTMxIDEzMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMTMxIDEzMTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiMyMjI0NTg7fQoJLnN0MXtmaWxsOiM1MTUzN0Q7fQoJLnN0MntmaWxsOiNBM0E0Qjk7fQoJLnN0M3tmaWxsOiMwMDAyM0I7fQoJLnN0NHtmaWxsOiNGRkZGRkY7fQoJLnN0NXtlbmFibGUtYmFja2dyb3VuZDpuZXcgICAgO30KPC9zdHlsZT4KPHRpdGxlPkxvZ29fc29tYnJlX2FpPC90aXRsZT4KPGcgaWQ9IlJlY3RhbmdsZV81NiI+Cgk8Zz4KCQk8cmVjdCB4PSIxOS4xIiB5PSIxOSIgdHJhbnNmb3JtPSJtYXRyaXgoMC41IC0wLjg2NiAwLjg2NiAwLjUgLTIzLjkyMjYgODkuNTQ2KSIgY2xhc3M9InN0MCIgd2lkdGg9IjkyLjkiIGhlaWdodD0iOTIuOSIvPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik04MywxMzAuM0wwLjgsODIuOUw0OC4yLDAuN2w4Mi4yLDQ3LjVMODMsMTMwLjN6IE0zLjUsODIuMWw3OC43LDQ1LjVsNDUuNS03OC43TDQ5LDMuNEwzLjUsODIuMXoiLz4KCTwvZz4KPC9nPgo8ZyBpZD0iUmVjdGFuZ2xlXzU2LTIiPgoJPGc+CgkJPHJlY3QgeD0iMTkiIHk9IjE5LjEiIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2IC0wLjUgMC41IDAuODY2IC0yMy45Nzc3IDQxLjUyNykiIGNsYXNzPSJzdDAiIHdpZHRoPSI5Mi45IiBoZWlnaHQ9IjkyLjkiLz4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNNDcuOSwxMzFMMCw0OEw4My4xLDBsNDgsODMuMUw0Ny45LDEzMXogTTQuMSw0OS4xbDQ1LDc3LjlsNzcuOS00NUw4Miw0LjFMNC4xLDQ5LjF6Ii8+Cgk8L2c+CjwvZz4KPGcgaWQ9IlJlY3RhbmdsZV81Ni0zIj4KCTxnPgoJCTxyZWN0IHg9IjE5LjEiIHk9IjE5IiBjbGFzcz0ic3QzIiB3aWR0aD0iOTIuOSIgaGVpZ2h0PSI5Mi45Ii8+CgkJPHBhdGggY2xhc3M9InN0NCIgZD0iTTExNC41LDExNC41SDE2LjZWMTYuNWg5Ny45VjExNC41eiBNMjEuNiwxMDkuNWg4Ny45VjIxLjVIMjEuNlYxMDkuNXoiLz4KCTwvZz4KPC9nPgo8ZyBpZD0iUmEiPgoJPGcgY2xhc3M9InN0NSI+CgkJPHBhdGggY2xhc3M9InN0NCIgZD0iTTU5LDg2LjdsLTYuNy0xOS4yaC0xLjJIMzguOXYxOS4yaC01LjZWMzguNWgxOC41YzMuNiwwLDYuMywwLjYsOC4xLDEuOGMxLjgsMS4yLDMsMi44LDMuNSw0LjgKCQkJYzAuNSwyLDAuOCw0LjYsMC44LDcuOGMwLDMuNS0wLjQsNi40LTEuMyw4LjdjLTAuOCwyLjMtMi42LDMuOS01LjMsNC44TDY1LDg2LjdINTl6IE01NS43LDYxLjZjMS4yLTAuNywyLTEuNywyLjQtMwoJCQljMC40LTEuMywwLjYtMy4yLDAuNi01LjZjMC0yLjUtMC4yLTQuMy0wLjUtNS42Yy0wLjMtMS4zLTEuMS0yLjItMi4zLTIuOWMtMS4yLTAuNy0zLTEtNS41LTFIMzguOXYxOS4xSDUwCgkJCUM1Mi41LDYyLjYsNTQuNCw2Mi4zLDU1LjcsNjEuNnoiLz4KCQk8cGF0aCBjbGFzcz0ic3Q0IiBkPSJNNzQuMyw4NWMtMS42LTEuNS0yLjUtNC4yLTIuNS04LjJjMC0yLjcsMC4zLTQuOCwwLjktNi4zYzAuNi0xLjUsMS42LTIuNiwzLTMuM2MxLjQtMC43LDMuNC0xLDYtMQoJCQljMS4zLDAsNS4xLDAuMSwxMS40LDAuM3YtMi40YzAtMi45LTAuMi01LTAuNy02LjJjLTAuNS0xLjItMS4zLTItMi42LTIuNGMtMS4yLTAuMy0zLjMtMC41LTYuMy0wLjVjLTEuMywwLTMsMC4xLTQuOSwwLjIKCQkJYy0yLDAuMS0zLjYsMC4zLTQuOCwwLjV2LTQuM2MzLjMtMC43LDcuMS0xLDExLjQtMWMzLjcsMCw2LjUsMC40LDguNCwxLjJjMS44LDAuOCwzLjEsMi4yLDMuOCw0LjFjMC43LDEuOSwxLDQuNywxLDguNHYyMi41aC00LjgKCQkJbC0wLjMtNWgtMC4zYy0wLjgsMi4yLTIuMiwzLjctNC4xLDQuNGMtMS45LDAuNy00LjEsMS4xLTYuNiwxLjFDNzguNiw4Ny4yLDc2LDg2LjUsNzQuMyw4NXogTTg5LjEsODJjMS4yLTAuNCwyLjItMS4yLDIuOC0yLjQKCQkJYzAuOS0xLjgsMS4zLTQuMywxLjMtNy4zdi0yaC0xMGMtMS43LDAtMywwLjItMy44LDAuNWMtMC44LDAuMy0xLjQsMC45LTEuNywxLjhjLTAuMywwLjktMC41LDIuMi0wLjUsNGMwLDEuOCwwLjIsMy4xLDAuNiwzLjkKCQkJYzAuNCwwLjgsMS4xLDEuNCwyLDEuOGMxLDAuMywyLjUsMC41LDQuNSwwLjVDODYuMiw4Mi42LDg3LjgsODIuNCw4OS4xLDgyeiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=", alt: "react-admin logo" }),
      React63.createElement("h1", null, "Welcome to React-admin"),
      React63.createElement(
        "div",
        null,
        "Your application is properly configured.",
        React63.createElement("br", null),
        "Now you can add a <Resource> as child of <Admin>."
      )
    ),
    React63.createElement(
      "div",
      { style: styles.secondary },
      React63.createElement(Button, { href: "https://marmelab.com/react-admin/documentation.html", img: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNHB4IgoJIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyNCAyNCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnIGlkPSJCb3VuZGluZ19Cb3giPgoJPHJlY3QgZmlsbD0ibm9uZSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ii8+CjwvZz4KPGcgaWQ9IkZsYXQiPgoJPGcgaWQ9InVpX3g1Rl9zcGVjX3g1Rl9oZWFkZXJfY29weV8yIj4KCTwvZz4KCTxnPgoJCTxwYXRoIGQ9Ik0yMSw1Yy0xLjExLTAuMzUtMi4zMy0wLjUtMy41LTAuNWMtMS45NSwwLTQuMDUsMC40LTUuNSwxLjVjLTEuNDUtMS4xLTMuNTUtMS41LTUuNS0xLjVTMi40NSw0LjksMSw2djE0LjY1CgkJCWMwLDAuMjUsMC4yNSwwLjUsMC41LDAuNWMwLjEsMCwwLjE1LTAuMDUsMC4yNS0wLjA1QzMuMSwyMC40NSw1LjA1LDIwLDYuNSwyMGMxLjk1LDAsNC4wNSwwLjQsNS41LDEuNWMxLjM1LTAuODUsMy44LTEuNSw1LjUtMS41CgkJCWMxLjY1LDAsMy4zNSwwLjMsNC43NSwxLjA1YzAuMSwwLjA1LDAuMTUsMC4wNSwwLjI1LDAuMDVjMC4yNSwwLDAuNS0wLjI1LDAuNS0wLjVWNkMyMi40LDUuNTUsMjEuNzUsNS4yNSwyMSw1eiBNMywxOC41VjcKCQkJYzEuMS0wLjM1LDIuMy0wLjUsMy41LTAuNWMxLjM0LDAsMy4xMywwLjQxLDQuNSwwLjk5djExLjVDOS42MywxOC40MSw3Ljg0LDE4LDYuNSwxOEM1LjMsMTgsNC4xLDE4LjE1LDMsMTguNXogTTIxLDE4LjUKCQkJYy0xLjEtMC4zNS0yLjMtMC41LTMuNS0wLjVjLTEuMzQsMC0zLjEzLDAuNDEtNC41LDAuOTlWNy40OWMxLjM3LTAuNTksMy4xNi0wLjk5LDQuNS0wLjk5YzEuMiwwLDIuNCwwLjE1LDMuNSwwLjVWMTguNXoiLz4KCQk8cGF0aCBvcGFjaXR5PSIwLjMiIGQ9Ik0xMSw3LjQ5QzkuNjMsNi45MSw3Ljg0LDYuNSw2LjUsNi41QzUuMyw2LjUsNC4xLDYuNjUsMyw3djExLjVDNC4xLDE4LjE1LDUuMywxOCw2LjUsMTgKCQkJYzEuMzQsMCwzLjEzLDAuNDEsNC41LDAuOTlWNy40OXoiLz4KCTwvZz4KCTxnPgoJCTxwYXRoIGQ9Ik0xNy41LDEwLjVjMC44OCwwLDEuNzMsMC4wOSwyLjUsMC4yNlY5LjI0QzE5LjIxLDkuMDksMTguMzYsOSwxNy41LDljLTEuMjgsMC0yLjQ2LDAuMTYtMy41LDAuNDd2MS41NwoJCQlDMTQuOTksMTAuNjksMTYuMTgsMTAuNSwxNy41LDEwLjV6Ii8+CgkJPHBhdGggZD0iTTE3LjUsMTMuMTZjMC44OCwwLDEuNzMsMC4wOSwyLjUsMC4yNlYxMS45Yy0wLjc5LTAuMTUtMS42NC0wLjI0LTIuNS0wLjI0Yy0xLjI4LDAtMi40NiwwLjE2LTMuNSwwLjQ3djEuNTcKCQkJQzE0Ljk5LDEzLjM2LDE2LjE4LDEzLjE2LDE3LjUsMTMuMTZ6Ii8+CgkJPHBhdGggZD0iTTE3LjUsMTUuODNjMC44OCwwLDEuNzMsMC4wOSwyLjUsMC4yNnYtMS41MmMtMC43OS0wLjE1LTEuNjQtMC4yNC0yLjUtMC4yNGMtMS4yOCwwLTIuNDYsMC4xNi0zLjUsMC40N3YxLjU3CgkJCUMxNC45OSwxNi4wMiwxNi4xOCwxNS44MywxNy41LDE1LjgzeiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=", label: "Documentation" }),
      React63.createElement(Button, { href: "https://github.com/marmelab/react-admin/tree/master/examples", img: "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0Ij48cGF0aCBmaWxsPSJub25lIiBkPSJNMCAwaDI0djI0SDBWMHoiLz48cGF0aCBkPSJNOS40IDE2LjZMNC44IDEybDQuNi00LjZMOCA2bC02IDYgNiA2IDEuNC0xLjR6bTUuMiAwbDQuNi00LjYtNC42LTQuNkwxNiA2bDYgNi02IDYtMS40LTEuNHoiLz48L3N2Zz4=", label: "Examples" }),
      React63.createElement(Button, { href: "https://stackoverflow.com/questions/tagged/react-admin", img: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDIzLjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIyNHB4IgoJIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyNCAyNCIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxnIGlkPSJCb3VuZGluZ19Cb3giPgoJPHJlY3QgZmlsbD0ibm9uZSIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0Ii8+CjwvZz4KPGcgaWQ9IkZsYXQiPgoJPGcgaWQ9InVpX3g1Rl9zcGVjX3g1Rl9oZWFkZXJfY29weV8yIj4KCTwvZz4KCTxnPgoJCTxjaXJjbGUgb3BhY2l0eT0iMC4zIiBjeD0iOSIgY3k9IjgiIHI9IjIiLz4KCQk8cGF0aCBvcGFjaXR5PSIwLjMiIGQ9Ik05LDE1Yy0yLjcsMC01LjgsMS4yOS02LDIuMDFMMywxOGgxMnYtMUMxNC44LDE2LjI5LDExLjcsMTUsOSwxNXoiLz4KCQk8cGF0aCBkPSJNMTYuNjcsMTMuMTNDMTguMDQsMTQuMDYsMTksMTUuMzIsMTksMTd2M2g0di0zQzIzLDE0LjgyLDE5LjQzLDEzLjUzLDE2LjY3LDEzLjEzeiIvPgoJCTxwYXRoIGQ9Ik0xNSwxMmMyLjIxLDAsNC0xLjc5LDQtNGMwLTIuMjEtMS43OS00LTQtNGMtMC40NywwLTAuOTEsMC4xLTEuMzMsMC4yNEMxNC41LDUuMjcsMTUsNi41OCwxNSw4cy0wLjUsMi43My0xLjMzLDMuNzYKCQkJQzE0LjA5LDExLjksMTQuNTMsMTIsMTUsMTJ6Ii8+CgkJPHBhdGggZD0iTTksMTJjMi4yMSwwLDQtMS43OSw0LTRjMC0yLjIxLTEuNzktNC00LTRTNSw1Ljc5LDUsOEM1LDEwLjIxLDYuNzksMTIsOSwxMnogTTksNmMxLjEsMCwyLDAuOSwyLDJjMCwxLjEtMC45LDItMiwyCgkJCVM3LDkuMSw3LDhDNyw2LjksNy45LDYsOSw2eiIvPgoJCTxwYXRoIGQ9Ik05LDEzYy0yLjY3LDAtOCwxLjM0LTgsNHYzaDE2di0zQzE3LDE0LjM0LDExLjY3LDEzLDksMTN6IE0xNSwxOEgzbDAtMC45OUMzLjIsMTYuMjksNi4zLDE1LDksMTVzNS44LDEuMjksNiwyVjE4eiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=", label: "Community" })
    )
  );
};

// node_modules/ra-core/dist/esm/util/useWhyDidYouUpdate.js
var import_react156 = __toESM(require_react());
var __assign61 = function() {
  __assign61 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign61.apply(this, arguments);
};
function useWhyDidYouUpdate(name, props) {
  var previousProps = (0, import_react156.useRef)();
  (0, import_react156.useEffect)(function() {
    if (previousProps.current) {
      var allKeys = Object.keys(__assign61(__assign61({}, previousProps.current), props));
      var changesObj_1 = {};
      allKeys.forEach(function(key) {
        if (previousProps.current[key] !== props[key]) {
          changesObj_1[key] = {
            from: previousProps.current[key],
            to: props[key]
          };
        }
      });
      if (Object.keys(changesObj_1).length) {
        console.log("[why-did-you-update]", name, changesObj_1);
      }
    }
    previousProps.current = props;
  });
}

// node_modules/ra-core/dist/esm/util/getMutationMode.js
var getMutationMode = function(mutationMode, undoable) {
  if (mutationMode) {
    return mutationMode;
  }
  switch (undoable) {
    case true:
      return "undoable";
    case false:
      return "pessimistic";
    default:
      return "undoable";
  }
};

// node_modules/ra-core/dist/esm/util/getFieldLabelTranslationArgs.js
var import_inflection2 = __toESM(require_inflection());
var getFieldLabelTranslationArgs = function(options) {
  if (!options)
    return [""];
  var label = options.label, defaultLabel = options.defaultLabel, resource = options.resource, resourceFromContext = options.resourceFromContext, source = options.source;
  if (typeof label !== "undefined")
    return [label, { _: label }];
  if (typeof source === "undefined")
    return [""];
  var _a11 = getSourceParts(source), sourceWithoutDigits = _a11.sourceWithoutDigits, sourceSuffix = _a11.sourceSuffix;
  var defaultLabelTranslation = (0, import_inflection2.transform)(sourceSuffix.replace(/\./g, " "), ["underscore", "humanize"]);
  if (resource) {
    return [
      getResourceFieldLabelKey(resource, sourceWithoutDigits),
      { _: defaultLabelTranslation }
    ];
  }
  if (defaultLabel) {
    return [defaultLabel, { _: defaultLabelTranslation }];
  }
  return [
    getResourceFieldLabelKey(resourceFromContext || "undefined", sourceWithoutDigits),
    { _: defaultLabelTranslation }
  ];
};
var getResourceFieldLabelKey = function(resource, source) {
  return "resources.".concat(resource, ".fields.").concat(source);
};
var getSourceParts = function(source) {
  var sourceWithoutDigits = source.replace(/\.\d+\./g, ".");
  var parts = source.split(".");
  var lastPartWithDigits;
  parts.forEach(function(part, index) {
    if (onlyDigits(part)) {
      lastPartWithDigits = index;
    }
  });
  var sourceSuffix = lastPartWithDigits != null ? parts.slice(lastPartWithDigits + 1).join(".") : source;
  return { sourceWithoutDigits, sourceSuffix };
};
var onlyDigits = function(s) {
  for (var i = s.length - 1; i >= 0; i--) {
    var d = s.charCodeAt(i);
    if (d < 48 || d > 57)
      return false;
  }
  return true;
};

// node_modules/ra-core/dist/esm/util/mergeRefs.js
function mergeRefs(refs) {
  return function(value) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}

// node_modules/ra-core/dist/esm/util/useEvent.js
var React64 = __toESM(require_react());
var import_react157 = __toESM(require_react());
var useLayoutEffect2 = typeof window !== "undefined" ? React64.useLayoutEffect : React64.useEffect;
var useEvent = function(fn) {
  var ref = React64.useRef(function() {
    throw new Error("Cannot call an event handler while rendering.");
  });
  useLayoutEffect2(function() {
    ref.current = fn;
  });
  return (0, import_react157.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return ref.current.apply(ref, args);
  }, []);
};

// node_modules/ra-core/dist/esm/util/useDebouncedEvent.js
var React65 = __toESM(require_react());
var import_react158 = __toESM(require_react());
var import_debounce6 = __toESM(require_debounce());
var useLayoutEffect4 = typeof window !== "undefined" ? React65.useLayoutEffect : React65.useEffect;
var useDebouncedEvent = function(callback, delay) {
  var debouncedCallbackRef = (0, import_react158.useRef)(function() {
    throw new Error("Cannot call an event handler while rendering.");
  });
  var stableCallback = useEvent(callback);
  useLayoutEffect4(function() {
    debouncedCallbackRef.current = (0, import_debounce6.default)(stableCallback, delay);
  }, [stableCallback, delay]);
  return (0, import_react158.useCallback)(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return debouncedCallbackRef.current.apply(debouncedCallbackRef, args);
  }, []);
};

// node_modules/ra-core/dist/esm/util/useFieldValue.js
var import_get15 = __toESM(require_get());
var useFieldValue = function(params) {
  var defaultValue = params.defaultValue, source = params.source;
  var record = useRecordContext(params);
  return (0, import_get15.default)(record, source, defaultValue);
};

// node_modules/ra-core/dist/esm/util/asyncDebounce.js
var import_debounce7 = __toESM(require_debounce());
function asyncDebounce(func, wait) {
  var resolveSet = /* @__PURE__ */ new Set();
  var rejectSet = /* @__PURE__ */ new Set();
  var debounced = (0, import_debounce7.default)(function(args) {
    func.apply(void 0, args).then(function() {
      var res = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        res[_i] = arguments[_i];
      }
      resolveSet.forEach(function(resolve) {
        return resolve.apply(void 0, res);
      });
    }).catch(function() {
      var res = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        res[_i] = arguments[_i];
      }
      rejectSet.forEach(function(reject) {
        return reject.apply(void 0, res);
      });
    }).finally(function() {
      resolveSet.clear();
      rejectSet.clear();
    });
  }, wait);
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return new Promise(function(resolve, reject) {
      resolveSet.add(resolve);
      rejectSet.add(reject);
      debounced(args);
    });
  };
}

// node_modules/ra-core/dist/esm/util/useCheckForApplicationUpdate.js
var import_react159 = __toESM(require_react());
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator25 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var useCheckForApplicationUpdate = function(options) {
  var _a11 = options.url, url = _a11 === void 0 ? window.location.href : _a11, fetchOptions = options.fetchOptions, _b = options.interval, delay = _b === void 0 ? ONE_HOUR : _b, onNewVersionAvailableProp = options.onNewVersionAvailable, _c = options.disabled, disabled = _c === void 0 ? true : _c;
  var currentHash = (0, import_react159.useRef)();
  var onNewVersionAvailable = useEvent(onNewVersionAvailableProp);
  (0, import_react159.useEffect)(function() {
    if (disabled)
      return;
    getHashForUrl(url, fetchOptions).then(function(hash2) {
      if (hash2 != null) {
        currentHash.current = hash2;
      }
    });
  }, [disabled, url, JSON.stringify(fetchOptions)]);
  (0, import_react159.useEffect)(function() {
    if (disabled)
      return;
    var interval = setInterval(function() {
      getHashForUrl(url, fetchOptions).then(function(hash2) {
        if (hash2 != null && currentHash.current !== hash2) {
          currentHash.current = hash2;
          onNewVersionAvailable();
        }
      }).catch(function() {
      });
    }, delay);
    return function() {
      return clearInterval(interval);
    };
  }, [
    delay,
    onNewVersionAvailable,
    disabled,
    url,
    // eslint-disable-next-line react-hooks/exhaustive-deps
    JSON.stringify(fetchOptions)
  ]);
};
var getHashForUrl = function(url, fetchOptions) {
  return __awaiter25(void 0, void 0, void 0, function() {
    var response, text, e_1;
    return __generator25(this, function(_a11) {
      switch (_a11.label) {
        case 0:
          _a11.trys.push([0, 3, , 4]);
          return [4, fetch(url, fetchOptions)];
        case 1:
          response = _a11.sent();
          if (!response.ok)
            return [2, null];
          return [4, response.text()];
        case 2:
          text = _a11.sent();
          return [2, hash(text)];
        case 3:
          e_1 = _a11.sent();
          return [2, null];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
};
var hash = function(value, seed) {
  if (seed === void 0) {
    seed = 0;
  }
  var h1 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  for (var i = 0, ch = void 0; i < value.length; i++) {
    ch = value.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
  h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h1 >>> 0);
};
var ONE_HOUR = 1e3 * 60 * 60;

// node_modules/ra-core/dist/esm/store/useStore.js
var useStore = function(key, defaultValue) {
  var _a11 = useStoreContext(), getItem = _a11.getItem, setItem = _a11.setItem, subscribe = _a11.subscribe;
  var _b = (0, import_react160.useState)(function() {
    return getItem(key, defaultValue);
  }), value = _b[0], setValue = _b[1];
  (0, import_react160.useEffect)(function() {
    var storedValue = getItem(key, defaultValue);
    if (!(0, import_isEqual9.default)(value, storedValue)) {
      setValue(storedValue);
    }
    var unsubscribe = subscribe(key, function(newValue) {
      setValue(typeof newValue === "undefined" ? defaultValue : newValue);
    });
    return function() {
      return unsubscribe();
    };
  }, [key, subscribe, defaultValue, getItem, value]);
  var set8 = useEvent(function(valueParam, runtimeDefaultValue) {
    var newValue = typeof valueParam === "function" ? valueParam(value) : valueParam;
    setItem(key, typeof newValue === "undefined" ? typeof runtimeDefaultValue === "undefined" ? defaultValue : runtimeDefaultValue : newValue);
  });
  return [value, set8];
};

// node_modules/ra-core/dist/esm/i18n/I18nContextProvider.js
var I18nContextProvider = function(_a11) {
  var _b = _a11.value, value = _b === void 0 ? defaulti18nContext : _b, children = _a11.children;
  var locale = useStore("locale")[0];
  var notify = useNotify();
  var _c = (0, import_react161.useState)(0), key = _c[0], setKey = _c[1];
  var _d = (0, import_react161.useState)(locale === value.getLocale()), isInitialized = _d[0], setInitialized = _d[1];
  (0, import_react161.useEffect)(function() {
    if (locale && value.getLocale() !== locale) {
      new Promise(function(resolve) {
        resolve(value.changeLocale(locale));
      }).then(function() {
        setKey(function(key2) {
          return key2 + 1;
        });
        setInitialized(true);
      }).catch(function(error) {
        setInitialized(true);
        notify("ra.notification.i18n_error", { type: "error" });
        console.error(error);
      });
    } else {
      setInitialized(true);
    }
  }, [value, locale, notify]);
  return isInitialized ? React66.createElement(I18nContext.Provider, { value, key }, children) : null;
};
var defaulti18nContext = {
  translate: function(x) {
    return x;
  },
  changeLocale: function() {
    return Promise.resolve();
  },
  getLocale: function() {
    return "en";
  }
};

// node_modules/ra-core/dist/esm/preferences/PreferenceKeyContext.js
var React67 = __toESM(require_react());
var import_react162 = __toESM(require_react());
var PreferenceKeyContext = (0, import_react162.createContext)("");
var PreferenceKeyContextProvider = function(_a11) {
  var _b = _a11.value, value = _b === void 0 ? "" : _b, children = _a11.children;
  return React67.createElement(PreferenceKeyContext.Provider, { value }, children);
};
var usePreferenceKey = function() {
  return (0, import_react162.useContext)(PreferenceKeyContext);
};

// node_modules/ra-core/dist/esm/preferences/usePreference.js
var usePreference = function(key, defaultValue) {
  var preferenceKey = usePreferenceKey();
  if (!preferenceKey) {
    throw new Error("usePreference cannot be used outside of a Configurable component. Did you forget to wrap your component with <Configurable>? If you don't want to use Configurable, you can use the useStore hook instead.");
  }
  return useStore(preferenceKey && key ? "".concat(preferenceKey, ".").concat(key) : preferenceKey !== null && preferenceKey !== void 0 ? preferenceKey : key, defaultValue);
};

// node_modules/ra-core/dist/esm/preferences/usePreferencesEditor.js
var import_react163 = __toESM(require_react());
var usePreferencesEditor = function() {
  var context = (0, import_react163.useContext)(PreferencesEditorContext);
  if (!context) {
    throw new Error("usePreferencesEditor must be used within a PreferencesEditorContextProvider");
  }
  return context;
};

// node_modules/ra-core/dist/esm/preferences/usePreferenceInput.js
var import_react164 = __toESM(require_react());
var __spreadArray22 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var usePreferenceInput = function(key, defaultValue) {
  var _a11 = usePreference(key, defaultValue), valueFromStore = _a11[0], setValueFromStore = _a11[1];
  var _b = (0, import_react164.useState)(valueFromStore), value = _b[0], setValue = _b[1];
  (0, import_react164.useEffect)(function() {
    setValue(valueFromStore || defaultValue);
  }, [valueFromStore, defaultValue]);
  var onChange = function(event) {
    setValue(event.target.value === "" ? defaultValue : event.target.value);
  };
  var onBlur = function() {
    setValueFromStore(value);
  };
  var onKeyDown = function(event) {
    var _a12;
    if (event.key === "Enter") {
      setValueFromStore(value);
      var form = event.target.form;
      if (form) {
        var index = __spreadArray22([], form, true).indexOf(event.target);
        (_a12 = form.elements[index + 1]) === null || _a12 === void 0 ? void 0 : _a12.focus();
      }
      event.preventDefault();
    }
  };
  return { value, onChange, onBlur, onKeyDown };
};

// node_modules/ra-core/dist/esm/preferences/useSetInspectorTitle.js
var import_react165 = __toESM(require_react());
var useSetInspectorTitle = function(title, options) {
  var preferencesEditorContext = usePreferencesEditor();
  if (!preferencesEditorContext) {
    throw new Error("useSetInspectorTitle cannot be called outside of a PreferencesEditorContext");
  }
  var setTitle = preferencesEditorContext.setTitle;
  (0, import_react165.useEffect)(function() {
    setTitle(title, options);
  }, [title, JSON.stringify(options), setTitle]);
};

// node_modules/ra-core/dist/esm/inference/getValuesFromRecords.js
var getValuesFromRecords_default = function(records) {
  return records.reduce(function(values, record) {
    Object.keys(record).forEach(function(fieldName) {
      if (!values[fieldName]) {
        values[fieldName] = [];
      }
      if (record[fieldName] != null) {
        var value = Array.isArray(record[fieldName]) ? [record[fieldName]] : record[fieldName];
        values[fieldName] = values[fieldName].concat(value);
      }
    });
    return values;
  }, {});
};

// node_modules/ra-core/dist/esm/inference/InferredElement.js
var import_react166 = __toESM(require_react());
var __assign62 = function() {
  __assign62 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign62.apply(this, arguments);
};
var InferredElement = (
  /** @class */
  function() {
    function InferredElement2(type, props, children) {
      this.type = type;
      this.props = props;
      this.children = children;
      this.type = type;
      this.props = props;
      this.children = children;
    }
    InferredElement2.prototype.getElement = function(props) {
      if (props === void 0) {
        props = {};
      }
      if (!this.type || !this.type.component) {
        return;
      }
      return this.children ? (0, import_react166.createElement)(this.type.component, __assign62(__assign62({}, this.props), props), this.children.length > 0 ? this.children.map(function(child, index) {
        return child.getElement({ key: index });
      }) : this.children.getElement()) : (0, import_react166.createElement)(this.type.component, __assign62(__assign62({}, this.props), props));
    };
    InferredElement2.prototype.getProps = function() {
      return this.props;
    };
    InferredElement2.prototype.isDefined = function() {
      return !!this.type;
    };
    InferredElement2.prototype.getRepresentation = function() {
      if (!this.type) {
        return "";
      }
      if (this.type.representation) {
        return this.type.representation(this.props, this.children);
      }
      if (this.type.component) {
        return "<".concat(this.type.component.displayName || this.type.component.name, ' source="').concat(this.props.source, '" />');
      }
      return "";
    };
    return InferredElement2;
  }()
);
var InferredElement_default = InferredElement;

// node_modules/ra-core/dist/esm/inference/inferElementFromValues.js
var React68 = __toESM(require_react());

// node_modules/date-fns/toDate.mjs
function toDate(argument) {
  const argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || typeof argument === "object" && argStr === "[object Date]") {
    return new argument.constructor(+argument);
  } else if (typeof argument === "number" || argStr === "[object Number]" || typeof argument === "string" || argStr === "[object String]") {
    return new Date(argument);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}

// node_modules/date-fns/constructFrom.mjs
function constructFrom(date, value) {
  if (date instanceof Date) {
    return new date.constructor(value);
  } else {
    return new Date(value);
  }
}

// node_modules/date-fns/addDays.mjs
function addDays(date, amount) {
  const _date = toDate(date);
  if (isNaN(amount)) return constructFrom(date, NaN);
  if (!amount) {
    return _date;
  }
  _date.setDate(_date.getDate() + amount);
  return _date;
}

// node_modules/date-fns/constants.mjs
var daysInYear = 365.2425;
var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1e3;
var minTime = -maxTime;
var millisecondsInWeek = 6048e5;
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var secondsInHour = 3600;
var secondsInDay = secondsInHour * 24;
var secondsInWeek = secondsInDay * 7;
var secondsInYear = secondsInDay * daysInYear;
var secondsInMonth = secondsInYear / 12;
var secondsInQuarter = secondsInMonth * 3;

// node_modules/date-fns/_lib/defaultOptions.mjs
var defaultOptions2 = {};
function getDefaultOptions() {
  return defaultOptions2;
}

// node_modules/date-fns/startOfWeek.mjs
function startOfWeek(date, options) {
  var _a11, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a11 = options == null ? void 0 : options.locale) == null ? void 0 : _a11.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const day = _date.getDay();
  const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  _date.setDate(_date.getDate() - diff);
  _date.setHours(0, 0, 0, 0);
  return _date;
}

// node_modules/date-fns/startOfISOWeek.mjs
function startOfISOWeek(date) {
  return startOfWeek(date, { weekStartsOn: 1 });
}

// node_modules/date-fns/getISOWeekYear.mjs
function getISOWeekYear(date) {
  const _date = toDate(date);
  const year = _date.getFullYear();
  const fourthOfJanuaryOfNextYear = constructFrom(date, 0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  const fourthOfJanuaryOfThisYear = constructFrom(date, 0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds.mjs
function getTimezoneOffsetInMilliseconds(date) {
  const _date = toDate(date);
  const utcDate = new Date(
    Date.UTC(
      _date.getFullYear(),
      _date.getMonth(),
      _date.getDate(),
      _date.getHours(),
      _date.getMinutes(),
      _date.getSeconds(),
      _date.getMilliseconds()
    )
  );
  utcDate.setUTCFullYear(_date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns/startOfISOWeekYear.mjs
function startOfISOWeekYear(date) {
  const year = getISOWeekYear(date);
  const fourthOfJanuary = constructFrom(date, 0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  return startOfISOWeek(fourthOfJanuary);
}

// node_modules/date-fns/isDate.mjs
function isDate(value) {
  return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
}

// node_modules/date-fns/isValid.mjs
function isValid(date) {
  if (!isDate(date) && typeof date !== "number") {
    return false;
  }
  const _date = toDate(date);
  return !isNaN(Number(_date));
}

// node_modules/date-fns/locale/en-US/_lib/formatDistance.mjs
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options == null ? void 0 : options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};

// node_modules/date-fns/locale/_lib/buildFormatLongFn.mjs
function buildFormatLongFn(args) {
  return (options = {}) => {
    const width = options.width ? String(options.width) : args.defaultWidth;
    const format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}

// node_modules/date-fns/locale/en-US/_lib/formatLong.mjs
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/en-US/_lib/formatRelative.mjs
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];

// node_modules/date-fns/locale/_lib/buildLocalizeFn.mjs
function buildLocalizeFn(args) {
  return (value, options) => {
    const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
    let valuesArray;
    if (context === "formatting" && args.formattingValues) {
      const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      const defaultWidth = args.defaultWidth;
      const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[width] || args.values[defaultWidth];
    }
    const index = args.argumentCallback ? args.argumentCallback(value) : value;
    return valuesArray[index];
  };
}

// node_modules/date-fns/locale/en-US/_lib/localize.mjs
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ],
  wide: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = (dirtyNumber, _options) => {
  const number2 = Number(dirtyNumber);
  const rem100 = number2 % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number2 + "st";
      case 2:
        return number2 + "nd";
      case 3:
        return number2 + "rd";
    }
  }
  return number2 + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/_lib/buildMatchFn.mjs
function buildMatchFn(args) {
  return (string, options = {}) => {
    const width = options.width;
    const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    const matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    const matchedString = matchResult[0];
    const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      findKey(parsePatterns, (pattern) => pattern.test(matchedString))
    );
    let value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any -- I challange you to fix the type
      options.valueCallback(value)
    ) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}
function findKey(object, predicate) {
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (let key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}

// node_modules/date-fns/locale/_lib/buildMatchPatternFn.mjs
function buildMatchPatternFn(args) {
  return (string, options = {}) => {
    const matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    const matchedString = matchResult[0];
    const parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    const rest = string.slice(matchedString.length);
    return { value, rest };
  };
}

// node_modules/date-fns/locale/en-US/_lib/match.mjs
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [
    /^j/i,
    /^f/i,
    /^m/i,
    /^a/i,
    /^m/i,
    /^j/i,
    /^j/i,
    /^a/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ],
  any: [
    /^ja/i,
    /^f/i,
    /^mar/i,
    /^ap/i,
    /^may/i,
    /^jun/i,
    /^jul/i,
    /^au/i,
    /^s/i,
    /^o/i,
    /^n/i,
    /^d/i
  ]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index) => index + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/en-US.mjs
var enUS = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/date-fns/getISOWeek.mjs
function getISOWeek(date) {
  const _date = toDate(date);
  const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/getWeekYear.mjs
function getWeekYear(date, options) {
  var _a11, _b, _c, _d;
  const _date = toDate(date);
  const year = _date.getFullYear();
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a11 = options == null ? void 0 : options.locale) == null ? void 0 : _a11.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const firstWeekOfNextYear = constructFrom(date, 0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  const firstWeekOfThisYear = constructFrom(date, 0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (_date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (_date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

// node_modules/date-fns/startOfWeekYear.mjs
function startOfWeekYear(date, options) {
  var _a11, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a11 = options == null ? void 0 : options.locale) == null ? void 0 : _a11.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const year = getWeekYear(date, options);
  const firstWeek = constructFrom(date, 0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  const _date = startOfWeek(firstWeek, options);
  return _date;
}

// node_modules/date-fns/getWeek.mjs
function getWeek(date, options) {
  const _date = toDate(date);
  const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
  return Math.round(diff / millisecondsInWeek) + 1;
}

// node_modules/date-fns/_lib/format/longFormatters.mjs
var dateLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "P":
      return formatLong2.date({ width: "short" });
    case "PP":
      return formatLong2.date({ width: "medium" });
    case "PPP":
      return formatLong2.date({ width: "long" });
    case "PPPP":
    default:
      return formatLong2.date({ width: "full" });
  }
};
var timeLongFormatter = (pattern, formatLong2) => {
  switch (pattern) {
    case "p":
      return formatLong2.time({ width: "short" });
    case "pp":
      return formatLong2.time({ width: "medium" });
    case "ppp":
      return formatLong2.time({ width: "long" });
    case "pppp":
    default:
      return formatLong2.time({ width: "full" });
  }
};
var dateTimeLongFormatter = (pattern, formatLong2) => {
  const matchResult = pattern.match(/(P+)(p+)?/) || [];
  const datePattern = matchResult[1];
  const timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  let dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({ width: "short" });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({ width: "medium" });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({ width: "long" });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({ width: "full" });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

// node_modules/date-fns/_lib/protectedTokens.mjs
var dayOfYearTokenRE = /^D+$/;
var weekYearTokenRE = /^Y+$/;
var throwTokens = ["D", "DD", "YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return dayOfYearTokenRE.test(token);
}
function isProtectedWeekYearToken(token) {
  return weekYearTokenRE.test(token);
}
function warnOrThrowProtectedError(token, format2, input) {
  const _message = message(token, format2, input);
  console.warn(_message);
  if (throwTokens.includes(token)) throw new RangeError(_message);
}
function message(token, format2, input) {
  const subject = token[0] === "Y" ? "years" : "days of the month";
  return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
}

// node_modules/date-fns/getDefaultOptions.mjs
function getDefaultOptions2() {
  return Object.assign({}, getDefaultOptions());
}

// node_modules/date-fns/getISODay.mjs
function getISODay(date) {
  const _date = toDate(date);
  let day = _date.getDay();
  if (day === 0) {
    day = 7;
  }
  return day;
}

// node_modules/date-fns/transpose.mjs
function transpose(fromDate, constructor) {
  const date = constructor instanceof Date ? constructFrom(constructor, 0) : new constructor(0);
  date.setFullYear(
    fromDate.getFullYear(),
    fromDate.getMonth(),
    fromDate.getDate()
  );
  date.setHours(
    fromDate.getHours(),
    fromDate.getMinutes(),
    fromDate.getSeconds(),
    fromDate.getMilliseconds()
  );
  return date;
}

// node_modules/date-fns/parse/_lib/Setter.mjs
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = class {
  constructor() {
    __publicField(this, "subPriority", 0);
  }
  validate(_utcDate, _options) {
    return true;
  }
};
var ValueSetter = class extends Setter {
  constructor(value, validateValue, setValue, priority, subPriority) {
    super();
    this.value = value;
    this.validateValue = validateValue;
    this.setValue = setValue;
    this.priority = priority;
    if (subPriority) {
      this.subPriority = subPriority;
    }
  }
  validate(date, options) {
    return this.validateValue(date, this.value, options);
  }
  set(date, flags, options) {
    return this.setValue(date, flags, this.value, options);
  }
};
var DateToSystemTimezoneSetter = class extends Setter {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", TIMEZONE_UNIT_PRIORITY);
    __publicField(this, "subPriority", -1);
  }
  set(date, flags) {
    if (flags.timestampIsSet) return date;
    return constructFrom(date, transpose(date, Date));
  }
};

// node_modules/date-fns/parse/_lib/Parser.mjs
var Parser = class {
  run(dateString, token, match2, options) {
    const result = this.parse(dateString, token, match2, options);
    if (!result) {
      return null;
    }
    return {
      setter: new ValueSetter(
        result.value,
        this.validate,
        this.set,
        this.priority,
        this.subPriority
      ),
      rest: result.rest
    };
  }
  validate(_utcDate, _value, _options) {
    return true;
  }
};

// node_modules/date-fns/parse/_lib/parsers/EraParser.mjs
var EraParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 140);
    __publicField(this, "incompatibleTokens", ["R", "u", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
      case "GGGGG":
        return match2.era(dateString, { width: "narrow" });
      case "GGGG":
      default:
        return match2.era(dateString, { width: "wide" }) || match2.era(dateString, { width: "abbreviated" }) || match2.era(dateString, { width: "narrow" });
    }
  }
  set(date, flags, value) {
    flags.era = value;
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/constants.mjs
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

// node_modules/date-fns/parse/_lib/utils.mjs
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  const matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  const sign = matchResult[1] === "+" ? 1 : -1;
  const hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  const minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  const seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  const isCommonEra = currentYear > 0;
  const absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  let result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    const rangeEnd = absCurrentYear + 50;
    const rangeEndCentury = Math.trunc(rangeEnd / 100) * 100;
    const isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

// node_modules/date-fns/parse/_lib/parsers/YearParser.mjs
var YearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "yy"
    });
    switch (token) {
      case "y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value) {
    const currentYear = date.getFullYear();
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(normalizedTwoDigitYear, 0, 1);
      date.setHours(0, 0, 0, 0);
      return date;
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.mjs
var LocalWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (year) => ({
      year,
      isTwoDigitYear: token === "YY"
    });
    switch (token) {
      case "Y":
        return mapValue(parseNDigits(4, dateString), valueCallback);
      case "Yo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "year"
          }),
          valueCallback
        );
      default:
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }
  validate(_date, value) {
    return value.isTwoDigitYear || value.year > 0;
  }
  set(date, flags, value, options) {
    const currentYear = getWeekYear(date, options);
    if (value.isTwoDigitYear) {
      const normalizedTwoDigitYear = normalizeTwoDigitYear(
        value.year,
        currentYear
      );
      date.setFullYear(
        normalizedTwoDigitYear,
        0,
        options.firstWeekContainsDate
      );
      date.setHours(0, 0, 0, 0);
      return startOfWeek(date, options);
    }
    const year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
    date.setFullYear(year, 0, options.firstWeekContainsDate);
    date.setHours(0, 0, 0, 0);
    return startOfWeek(date, options);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.mjs
var ISOWeekYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", [
      "G",
      "y",
      "Y",
      "u",
      "Q",
      "q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token) {
    if (token === "R") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    const firstWeekOfYear = constructFrom(date, 0);
    firstWeekOfYear.setFullYear(value, 0, 4);
    firstWeekOfYear.setHours(0, 0, 0, 0);
    return startOfISOWeek(firstWeekOfYear);
  }
};

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.mjs
var ExtendedYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 130);
    __publicField(this, "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token) {
    if (token === "u") {
      return parseNDigitsSigned(4, dateString);
    }
    return parseNDigitsSigned(token.length, dateString);
  }
  set(date, _flags, value) {
    date.setFullYear(value, 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.mjs
var QuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "Q":
      case "QQ":
        return parseNDigits(token.length, dateString);
      case "Qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "QQQ":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQQ":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.mjs
var StandAloneQuarterParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 120);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "q":
      case "qq":
        return parseNDigits(token.length, dateString);
      case "qo":
        return match2.ordinalNumber(dateString, { unit: "quarter" });
      case "qqq":
        return match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqqq":
        return match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return match2.quarter(dateString, {
          width: "wide",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.quarter(dateString, {
          width: "narrow",
          context: "standalone"
        });
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 4;
  }
  set(date, _flags, value) {
    date.setMonth((value - 1) * 3, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MonthParser.mjs
var MonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "L",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
    __publicField(this, "priority", 110);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "M":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "MM":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Mo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "MMM":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
      case "MMMMM":
        return match2.month(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return match2.month(dateString, { width: "wide", context: "formatting" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.month(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.mjs
var StandAloneMonthParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 110);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => value - 1;
    switch (token) {
      case "L":
        return mapValue(
          parseNumericPattern(numericPatterns.month, dateString),
          valueCallback
        );
      case "LL":
        return mapValue(parseNDigits(2, dateString), valueCallback);
      case "Lo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "month"
          }),
          valueCallback
        );
      case "LLL":
        return match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
      case "LLLLL":
        return match2.month(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return match2.month(dateString, { width: "wide", context: "standalone" }) || match2.month(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.month(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    date.setMonth(value, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setWeek.mjs
function setWeek(date, week, options) {
  const _date = toDate(date);
  const diff = getWeek(_date, options) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.mjs
var LocalWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "i",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "w":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "wo":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value, options) {
    return startOfWeek(setWeek(date, value, options), options);
  }
};

// node_modules/date-fns/setISOWeek.mjs
function setISOWeek(date, week) {
  const _date = toDate(date);
  const diff = getISOWeek(_date) - week;
  _date.setDate(_date.getDate() - diff * 7);
  return _date;
}

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.mjs
var ISOWeekParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 100);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "I":
        return parseNumericPattern(numericPatterns.week, dateString);
      case "Io":
        return match2.ordinalNumber(dateString, { unit: "week" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 53;
  }
  set(date, _flags, value) {
    return startOfISOWeek(setISOWeek(date, value));
  }
};

// node_modules/date-fns/parse/_lib/parsers/DateParser.mjs
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [
  31,
  29,
  31,
  30,
  31,
  30,
  31,
  31,
  30,
  31,
  30,
  31
];
var DateParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subPriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "w",
      "I",
      "D",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "d":
        return parseNumericPattern(numericPatterns.date, dateString);
      case "do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    const month = date.getMonth();
    if (isLeapYear2) {
      return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
    } else {
      return value >= 1 && value <= DAYS_IN_MONTH[month];
    }
  }
  set(date, _flags, value) {
    date.setDate(value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.mjs
var DayOfYearParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "subpriority", 1);
    __publicField(this, "incompatibleTokens", [
      "Y",
      "R",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "I",
      "d",
      "E",
      "i",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "D":
      case "DD":
        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
      case "Do":
        return match2.ordinalNumber(dateString, { unit: "date" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(date, value) {
    const year = date.getFullYear();
    const isLeapYear2 = isLeapYearIndex(year);
    if (isLeapYear2) {
      return value >= 1 && value <= 366;
    } else {
      return value >= 1 && value <= 365;
    }
  }
  set(date, _flags, value) {
    date.setMonth(0, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setDay.mjs
function setDay(date, day, options) {
  var _a11, _b, _c, _d;
  const defaultOptions3 = getDefaultOptions();
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_b = (_a11 = options == null ? void 0 : options.locale) == null ? void 0 : _a11.options) == null ? void 0 : _b.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.weekStartsOn) ?? 0;
  const _date = toDate(date);
  const currentDay = _date.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(_date, diff);
}

// node_modules/date-fns/parse/_lib/parsers/DayParser.mjs
var DayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEEE":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "EEEE":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.mjs
var LocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "e":
      case "ee":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "eo":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "eee":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeeee":
        return match2.day(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
      case "eeee":
      default:
        return match2.day(dateString, { width: "wide", context: "formatting" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.day(dateString, { width: "short", context: "formatting" }) || match2.day(dateString, { width: "narrow", context: "formatting" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.mjs
var StandAloneLocalDayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "R",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "I",
      "d",
      "D",
      "E",
      "i",
      "e",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2, options) {
    const valueCallback = (value) => {
      const wholeWeekDays = Math.floor((value - 1) / 7) * 7;
      return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
    };
    switch (token) {
      case "c":
      case "cc":
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      case "co":
        return mapValue(
          match2.ordinalNumber(dateString, {
            unit: "day"
          }),
          valueCallback
        );
      case "ccc":
        return match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "ccccc":
        return match2.day(dateString, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
      case "cccc":
      default:
        return match2.day(dateString, { width: "wide", context: "standalone" }) || match2.day(dateString, {
          width: "abbreviated",
          context: "standalone"
        }) || match2.day(dateString, { width: "short", context: "standalone" }) || match2.day(dateString, { width: "narrow", context: "standalone" });
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 6;
  }
  set(date, _flags, value, options) {
    date = setDay(date, value, options);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/setISODay.mjs
function setISODay(date, day) {
  const _date = toDate(date);
  const currentDay = getISODay(_date);
  const diff = day - currentDay;
  return addDays(_date, diff);
}

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.mjs
var ISODayParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 90);
    __publicField(this, "incompatibleTokens", [
      "y",
      "Y",
      "u",
      "q",
      "Q",
      "M",
      "L",
      "w",
      "d",
      "D",
      "E",
      "e",
      "c",
      "t",
      "T"
    ]);
  }
  parse(dateString, token, match2) {
    const valueCallback = (value) => {
      if (value === 0) {
        return 7;
      }
      return value;
    };
    switch (token) {
      case "i":
      case "ii":
        return parseNDigits(token.length, dateString);
      case "io":
        return match2.ordinalNumber(dateString, { unit: "day" });
      case "iii":
        return mapValue(
          match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiii":
        return mapValue(
          match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiiiii":
        return mapValue(
          match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
      case "iiii":
      default:
        return mapValue(
          match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }),
          valueCallback
        );
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 7;
  }
  set(date, _flags, value) {
    date = setISODay(date, value);
    date.setHours(0, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.mjs
var AMPMParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "a":
      case "aa":
      case "aaa":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaaa":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.mjs
var AMPMMidnightParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "b":
      case "bb":
      case "bbb":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbbb":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.mjs
var DayPeriodParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 80);
    __publicField(this, "incompatibleTokens", ["a", "b", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBBB":
        return match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return match2.dayPeriod(dateString, {
          width: "wide",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "abbreviated",
          context: "formatting"
        }) || match2.dayPeriod(dateString, {
          width: "narrow",
          context: "formatting"
        });
    }
  }
  set(date, _flags, value) {
    date.setHours(dayPeriodEnumToHours(value), 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.mjs
var Hour1to12Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["H", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "h":
        return parseNumericPattern(numericPatterns.hour12h, dateString);
      case "ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 12;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else if (!isPM && value === 12) {
      date.setHours(0, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.mjs
var Hour0to23Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "H":
        return parseNumericPattern(numericPatterns.hour23h, dateString);
      case "Ho":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 23;
  }
  set(date, _flags, value) {
    date.setHours(value, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.mjs
var Hour0To11Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["h", "H", "k", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "K":
        return parseNumericPattern(numericPatterns.hour11h, dateString);
      case "Ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 11;
  }
  set(date, _flags, value) {
    const isPM = date.getHours() >= 12;
    if (isPM && value < 12) {
      date.setHours(value + 12, 0, 0, 0);
    } else {
      date.setHours(value, 0, 0, 0);
    }
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.mjs
var Hour1To24Parser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 70);
    __publicField(this, "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "k":
        return parseNumericPattern(numericPatterns.hour24h, dateString);
      case "ko":
        return match2.ordinalNumber(dateString, { unit: "hour" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 1 && value <= 24;
  }
  set(date, _flags, value) {
    const hours = value <= 24 ? value % 24 : value;
    date.setHours(hours, 0, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.mjs
var MinuteParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 60);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "m":
        return parseNumericPattern(numericPatterns.minute, dateString);
      case "mo":
        return match2.ordinalNumber(dateString, { unit: "minute" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setMinutes(value, 0, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/SecondParser.mjs
var SecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 50);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token, match2) {
    switch (token) {
      case "s":
        return parseNumericPattern(numericPatterns.second, dateString);
      case "so":
        return match2.ordinalNumber(dateString, { unit: "second" });
      default:
        return parseNDigits(token.length, dateString);
    }
  }
  validate(_date, value) {
    return value >= 0 && value <= 59;
  }
  set(date, _flags, value) {
    date.setSeconds(value, 0);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.mjs
var FractionOfSecondParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 30);
    __publicField(this, "incompatibleTokens", ["t", "T"]);
  }
  parse(dateString, token) {
    const valueCallback = (value) => Math.trunc(value * Math.pow(10, -token.length + 3));
    return mapValue(parseNDigits(token.length, dateString), valueCallback);
  }
  set(date, _flags, value) {
    date.setMilliseconds(value);
    return date;
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.mjs
var ISOTimezoneWithZParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "x"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "X":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "XX":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "XXXX":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "XXXXX":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "XXX":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.mjs
var ISOTimezoneParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 10);
    __publicField(this, "incompatibleTokens", ["t", "T", "X"]);
  }
  parse(dateString, token) {
    switch (token) {
      case "x":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalMinutes,
          dateString
        );
      case "xx":
        return parseTimezonePattern(timezonePatterns.basic, dateString);
      case "xxxx":
        return parseTimezonePattern(
          timezonePatterns.basicOptionalSeconds,
          dateString
        );
      case "xxxxx":
        return parseTimezonePattern(
          timezonePatterns.extendedOptionalSeconds,
          dateString
        );
      case "xxx":
      default:
        return parseTimezonePattern(timezonePatterns.extended, dateString);
    }
  }
  set(date, flags, value) {
    if (flags.timestampIsSet) return date;
    return constructFrom(
      date,
      date.getTime() - getTimezoneOffsetInMilliseconds(date) - value
    );
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.mjs
var TimestampSecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 40);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value * 1e3), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.mjs
var TimestampMillisecondsParser = class extends Parser {
  constructor() {
    super(...arguments);
    __publicField(this, "priority", 20);
    __publicField(this, "incompatibleTokens", "*");
  }
  parse(dateString) {
    return parseAnyDigitsSigned(dateString);
  }
  set(date, _flags, value) {
    return [constructFrom(date, value), { timestampIsSet: true }];
  }
};

// node_modules/date-fns/parse/_lib/parsers.mjs
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

// node_modules/date-fns/parse.mjs
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse3(dateStr, formatStr, referenceDate, options) {
  var _a11, _b, _c, _d, _e, _f, _g, _h;
  const defaultOptions3 = getDefaultOptions2();
  const locale = (options == null ? void 0 : options.locale) ?? defaultOptions3.locale ?? enUS;
  const firstWeekContainsDate = (options == null ? void 0 : options.firstWeekContainsDate) ?? ((_b = (_a11 = options == null ? void 0 : options.locale) == null ? void 0 : _a11.options) == null ? void 0 : _b.firstWeekContainsDate) ?? defaultOptions3.firstWeekContainsDate ?? ((_d = (_c = defaultOptions3.locale) == null ? void 0 : _c.options) == null ? void 0 : _d.firstWeekContainsDate) ?? 1;
  const weekStartsOn = (options == null ? void 0 : options.weekStartsOn) ?? ((_f = (_e = options == null ? void 0 : options.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) ?? defaultOptions3.weekStartsOn ?? ((_h = (_g = defaultOptions3.locale) == null ? void 0 : _g.options) == null ? void 0 : _h.weekStartsOn) ?? 0;
  if (formatStr === "") {
    if (dateStr === "") {
      return toDate(referenceDate);
    } else {
      return constructFrom(referenceDate, NaN);
    }
  }
  const subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale
  };
  const setters = [new DateToSystemTimezoneSetter()];
  const tokens = formatStr.match(longFormattingTokensRegExp).map((substring) => {
    const firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      const longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  const usedTokens = [];
  for (let token of tokens) {
    if (!(options == null ? void 0 : options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    if (!(options == null ? void 0 : options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
      warnOrThrowProtectedError(token, formatStr, dateStr);
    }
    const firstCharacter = token[0];
    const parser = parsers[firstCharacter];
    if (parser) {
      const { incompatibleTokens } = parser;
      if (Array.isArray(incompatibleTokens)) {
        const incompatibleToken = usedTokens.find(
          (usedToken) => incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter
        );
        if (incompatibleToken) {
          throw new RangeError(
            `The format string mustn't contain \`${incompatibleToken.fullToken}\` and \`${token}\` at the same time`
          );
        }
      } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
        throw new RangeError(
          `The format string mustn't contain \`${token}\` and any other token at the same time`
        );
      }
      usedTokens.push({ token: firstCharacter, fullToken: token });
      const parseResult = parser.run(
        dateStr,
        token,
        locale.match,
        subFnOptions
      );
      if (!parseResult) {
        return constructFrom(referenceDate, NaN);
      }
      setters.push(parseResult.setter);
      dateStr = parseResult.rest;
    } else {
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      if (token === "''") {
        token = "'";
      } else if (firstCharacter === "'") {
        token = cleanEscapedString(token);
      }
      if (dateStr.indexOf(token) === 0) {
        dateStr = dateStr.slice(token.length);
      } else {
        return constructFrom(referenceDate, NaN);
      }
    }
  }
  if (dateStr.length > 0 && notWhitespaceRegExp.test(dateStr)) {
    return constructFrom(referenceDate, NaN);
  }
  const uniquePrioritySetters = setters.map((setter) => setter.priority).sort((a, b) => b - a).filter((priority, index, array) => array.indexOf(priority) === index).map(
    (priority) => setters.filter((setter) => setter.priority === priority).sort((a, b) => b.subPriority - a.subPriority)
  ).map((setterArray) => setterArray[0]);
  let date = toDate(referenceDate);
  if (isNaN(date.getTime())) {
    return constructFrom(referenceDate, NaN);
  }
  const flags = {};
  for (const setter of uniquePrioritySetters) {
    if (!setter.validate(date, subFnOptions)) {
      return constructFrom(referenceDate, NaN);
    }
    const result = setter.set(date, flags, subFnOptions);
    if (Array.isArray(result)) {
      date = result[0];
      Object.assign(flags, result[1]);
    } else {
      date = result;
    }
  }
  return constructFrom(referenceDate, date);
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

// node_modules/date-fns/isMatch.mjs
function isMatch(dateStr, formatStr, options) {
  return isValid(parse3(dateStr, formatStr, /* @__PURE__ */ new Date(), options));
}

// node_modules/date-fns/parseISO.mjs
function parseISO(argument, options) {
  const additionalDigits = (options == null ? void 0 : options.additionalDigits) ?? 2;
  const dateStrings = splitDateString(argument);
  let date;
  if (dateStrings.date) {
    const parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const timestamp = date.getTime();
  let time = 0;
  let offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return /* @__PURE__ */ new Date(NaN);
    }
  } else {
    const dirtyDate = new Date(timestamp + time);
    const result = /* @__PURE__ */ new Date(0);
    result.setFullYear(
      dirtyDate.getUTCFullYear(),
      dirtyDate.getUTCMonth(),
      dirtyDate.getUTCDate()
    );
    result.setHours(
      dirtyDate.getUTCHours(),
      dirtyDate.getUTCMinutes(),
      dirtyDate.getUTCSeconds(),
      dirtyDate.getUTCMilliseconds()
    );
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  const dateStrings = {};
  const array = dateString.split(patterns.dateTimeDelimiter);
  let timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(
        dateStrings.date.length,
        dateString.length
      );
    }
  }
  if (timeString) {
    const token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  const regex2 = new RegExp(
    "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
  );
  const captures = dateString.match(regex2);
  if (!captures) return { year: NaN, restDateString: "" };
  const year = captures[1] ? parseInt(captures[1]) : null;
  const century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null) return /* @__PURE__ */ new Date(NaN);
  const captures = dateString.match(dateRegex);
  if (!captures) return /* @__PURE__ */ new Date(NaN);
  const isWeekDate = !!captures[4];
  const dayOfYear = parseDateUnit(captures[1]);
  const month = parseDateUnit(captures[2]) - 1;
  const day = parseDateUnit(captures[3]);
  const week = parseDateUnit(captures[4]);
  const dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    const date = /* @__PURE__ */ new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  const captures = timeString.match(timeRegex);
  if (!captures) return NaN;
  const hours = parseTimeUnit(captures[1]);
  const minutes = parseTimeUnit(captures[2]);
  const seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z") return 0;
  const captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  const sign = captures[1] === "+" ? -1 : 1;
  const hours = parseInt(captures[2]);
  const minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  const date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex2(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex2(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex2(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

// node_modules/ra-core/dist/esm/inference/assertions.js
var isNumeric = function(value) {
  return !isNaN(parseFloat(value)) && isFinite(value);
};
var valuesAreNumeric = function(values) {
  return values.every(isNumeric);
};
var isInteger = function(value) {
  return Number.isInteger(value) || !isNaN(parseInt(value));
};
var valuesAreInteger = function(values) {
  return values.every(isInteger);
};
var isBoolean2 = function(value) {
  return typeof value === "boolean";
};
var valuesAreBoolean = function(values) {
  return values.every(isBoolean2);
};
var isString2 = function(value) {
  return typeof value === "string";
};
var valuesAreString = function(values) {
  return values.every(isString2);
};
var HtmlRegexp = /<([A-Z][A-Z0-9]*)\b[^>]*>(.*?)<\/\1>/i;
var isHtml = function(value) {
  return !value || HtmlRegexp.test(value);
};
var valuesAreHtml = function(values) {
  return values.every(isHtml);
};
var UrlRegexp = /http(s*):\/\/.*/i;
var isUrl = function(value) {
  return !value || UrlRegexp.test(value);
};
var valuesAreUrl = function(values) {
  return values.every(isUrl);
};
var ImageUrlRegexp = /http(s*):\/\/.*\.(jpeg|jpg|jfif|pjpeg|pjp|png|svg|gif|webp|apng|bmp|ico|cur|tif|tiff)/i;
var isImageUrl = function(value) {
  return !value || ImageUrlRegexp.test(value);
};
var valuesAreImageUrl = function(values) {
  return values.every(isImageUrl);
};
var EmailRegexp = /@{1}/;
var isEmail = function(value) {
  return !value || EmailRegexp.test(value);
};
var valuesAreEmail = function(values) {
  return values.every(isEmail);
};
var isArray = function(value) {
  return Array.isArray(value);
};
var valuesAreArray = function(values) {
  return values.every(isArray);
};
var isDate2 = function(value) {
  return !value || value instanceof Date;
};
var valuesAreDate = function(values) {
  return values.every(isDate2);
};
var isDateString = function(value) {
  return !value || typeof value === "string" && (isMatch(value, "MM/dd/yyyy") || isMatch(value, "MM/dd/yy") || isValid(parseISO(value)));
};
var valuesAreDateString = function(values) {
  return values.every(isDateString);
};
var isObject3 = function(value) {
  return Object.prototype.toString.call(value) === "[object Object]";
};
var valuesAreObject = function(values) {
  return values.every(isObject3);
};

// node_modules/ra-core/dist/esm/inference/inferElementFromValues.js
var import_inflection3 = __toESM(require_inflection());
var DefaultComponent = function() {
  return React68.createElement("span", null, ";");
};
var defaultType = {
  type: DefaultComponent,
  representation: function() {
    return "<DefaultComponent />";
  }
};
var defaultTypes = {
  array: defaultType,
  boolean: defaultType,
  date: defaultType,
  email: defaultType,
  id: defaultType,
  number: defaultType,
  reference: defaultType,
  referenceArray: defaultType,
  richText: defaultType,
  string: defaultType,
  url: defaultType
};
var hasType = function(type, types) {
  return typeof types[type] !== "undefined";
};
var inferElementFromValues = function(name, values, types) {
  if (values === void 0) {
    values = [];
  }
  if (types === void 0) {
    types = defaultTypes;
  }
  if (name === "id" && hasType("id", types)) {
    return new InferredElement_default(types.id, { source: name });
  }
  if (name.substr(name.length - 3) === "_id" && hasType("reference", types)) {
    var reference = (0, import_inflection3.pluralize)(name.substr(0, name.length - 3));
    return types.reference && new InferredElement_default(types.reference, {
      source: name,
      reference
    });
  }
  if (name.substr(name.length - 2) === "Id" && hasType("reference", types)) {
    var reference = (0, import_inflection3.pluralize)(name.substr(0, name.length - 2));
    return types.reference && new InferredElement_default(types.reference, {
      source: name,
      reference
    });
  }
  if (name.substr(name.length - 4) === "_ids" && hasType("referenceArray", types)) {
    var reference = (0, import_inflection3.pluralize)(name.substr(0, name.length - 4));
    return types.referenceArray && new InferredElement_default(types.referenceArray, {
      source: name,
      reference
    });
  }
  if (name.substr(name.length - 3) === "Ids" && hasType("referenceArray", types)) {
    var reference = (0, import_inflection3.pluralize)(name.substr(0, name.length - 3));
    return types.referenceArray && new InferredElement_default(types.referenceArray, {
      source: name,
      reference
    });
  }
  if (values.length === 0) {
    return new InferredElement_default(types.string, { source: name });
  }
  if (valuesAreArray(values)) {
    if (isObject3(values[0][0]) && hasType("array", types)) {
      var leafValues_1 = getValuesFromRecords_default(values.reduce(function(acc, vals) {
        return acc.concat(vals);
      }, []));
      return types.array && new InferredElement_default(types.array, {
        source: name
      }, Object.keys(leafValues_1).map(function(leafName) {
        return inferElementFromValues(leafName, leafValues_1[leafName], types);
      }));
    }
    return new InferredElement_default(types.string, { source: name });
  }
  if (valuesAreBoolean(values) && hasType("boolean", types)) {
    return new InferredElement_default(types.boolean, { source: name });
  }
  if (valuesAreDate(values) && hasType("date", types)) {
    return new InferredElement_default(types.date, { source: name });
  }
  if (valuesAreString(values)) {
    if (name === "email" && hasType("email", types)) {
      return new InferredElement_default(types.email, { source: name });
    }
    if (name === "url" && hasType("url", types)) {
      return new InferredElement_default(types.url, { source: name });
    }
    if (valuesAreDateString(values) && hasType("date", types)) {
      return new InferredElement_default(types.date, { source: name });
    }
    if (valuesAreHtml(values) && hasType("richText", types)) {
      return new InferredElement_default(types.richText, { source: name });
    }
    return new InferredElement_default(types.string, { source: name });
  }
  if ((valuesAreInteger(values) || valuesAreNumeric(values)) && hasType("number", types)) {
    return new InferredElement_default(types.number, { source: name });
  }
  if (valuesAreObject(values)) {
    var propName_1 = Object.keys(values[0]).shift();
    if (!propName_1) {
      return new InferredElement_default(types.string, { source: name });
    }
    var leafValues = values.map(function(v) {
      return v[propName_1];
    });
    return inferElementFromValues("".concat(name, ".").concat(propName_1), leafValues, types);
  }
  return new InferredElement_default(types.string, { source: name });
};
var inferElementFromValues_default = inferElementFromValues;

// node_modules/ra-core/dist/esm/inference/getElementsFromRecords.js
var getElementsFromRecords_default = function(records, types) {
  var fieldValues = getValuesFromRecords_default(records);
  return Object.keys(fieldValues).reduce(function(fields, fieldName) {
    return fields.concat(inferElementFromValues_default(fieldName, fieldValues[fieldName], types));
  }, []).filter(function(inferredElement) {
    return inferredElement.isDefined();
  });
};

// node_modules/ra-core/dist/esm/inference/inferTypeFromValues.js
var import_inflection4 = __toESM(require_inflection());
var InferenceTypes = [
  "array",
  "boolean",
  "date",
  "email",
  "id",
  "image",
  "number",
  "reference",
  "referenceChild",
  "referenceArray",
  "referenceArrayChild",
  "richText",
  "string",
  "url",
  "object"
];
var inferTypeFromValues = function(name, values) {
  if (values === void 0) {
    values = [];
  }
  if (name === "id") {
    return { type: "id", props: { source: name } };
  }
  if (name.substr(name.length - 3) === "_id") {
    return {
      type: "reference",
      props: {
        source: name,
        reference: (0, import_inflection4.pluralize)(name.substr(0, name.length - 3))
      },
      children: { type: "referenceChild" }
    };
  }
  if (name.substr(name.length - 2) === "Id") {
    return {
      type: "reference",
      props: {
        source: name,
        reference: (0, import_inflection4.pluralize)(name.substr(0, name.length - 2))
      },
      children: { type: "referenceChild" }
    };
  }
  if (name.substr(name.length - 4) === "_ids") {
    return {
      type: "referenceArray",
      props: {
        source: name,
        reference: (0, import_inflection4.pluralize)(name.substr(0, name.length - 4))
      },
      children: { type: "referenceArrayChild" }
    };
  }
  if (name.substr(name.length - 3) === "Ids") {
    return {
      type: "referenceArray",
      props: {
        source: name,
        reference: (0, import_inflection4.pluralize)(name.substr(0, name.length - 3))
      },
      children: { type: "referenceArrayChild" }
    };
  }
  if (values.length === 0) {
    if (name === "email") {
      return { type: "email", props: { source: name } };
    }
    if (name === "url") {
      return { type: "url", props: { source: name } };
    }
    return { type: "string", props: { source: name } };
  }
  if (valuesAreArray(values)) {
    if (isObject3(values[0][0])) {
      var leafValues_1 = getValuesFromRecords_default(values.reduce(function(acc, vals) {
        return acc.concat(vals);
      }, []));
      return {
        type: "array",
        props: { source: name },
        children: Object.keys(leafValues_1).map(function(leafName) {
          return inferTypeFromValues(leafName, leafValues_1[leafName]);
        })
      };
    }
    return { type: "string", props: { source: name } };
  }
  if (valuesAreBoolean(values)) {
    return { type: "boolean", props: { source: name } };
  }
  if (valuesAreDate(values)) {
    return { type: "date", props: { source: name } };
  }
  if (valuesAreString(values)) {
    if (name === "email" || valuesAreEmail(values)) {
      return { type: "email", props: { source: name } };
    }
    if (name === "url" || valuesAreUrl(values)) {
      if (valuesAreImageUrl(values)) {
        return { type: "image", props: { source: name } };
      }
      return { type: "url", props: { source: name } };
    }
    if (valuesAreDateString(values)) {
      return { type: "date", props: { source: name } };
    }
    if (valuesAreHtml(values)) {
      return { type: "richText", props: { source: name } };
    }
    if (valuesAreInteger(values) || valuesAreNumeric(values)) {
      return { type: "number", props: { source: name } };
    }
    return { type: "string", props: { source: name } };
  }
  if (valuesAreInteger(values) || valuesAreNumeric(values)) {
    return { type: "number", props: { source: name } };
  }
  if (valuesAreObject(values)) {
    var propName_1 = Object.keys(values[0]).shift();
    if (!propName_1) {
      return { type: "object", props: { source: name } };
    }
    var leafValues = values.map(function(v) {
      return v[propName_1];
    });
    return inferTypeFromValues("".concat(name, ".").concat(propName_1), leafValues);
  }
  return { type: "string", props: { source: name } };
};

// node_modules/ra-core/dist/esm/types.js
var I18N_TRANSLATE = "I18N_TRANSLATE";
var I18N_CHANGE_LOCALE = "I18N_CHANGE_LOCALE";

export {
  AuthContext,
  useAuthProvider_default,
  localStorageStore,
  getStorage,
  require_set,
  memoryStore,
  StoreContext,
  StoreContextProvider,
  useStoreContext,
  StoreSetter,
  escapePath_default,
  substituteTokens,
  I18nContext,
  AddNotificationContext,
  NotificationContext,
  NotificationContextProvider,
  useAddNotificationContext,
  useNotificationContext,
  useNotify,
  I18nContextProvider,
  TestTranslationProvider,
  testI18nProvider,
  TranslatableContext,
  TranslatableContextProvider,
  require_isArrayLikeObject,
  require_merge,
  resolveBrowserLocale,
  mergeTranslations,
  useI18nProvider,
  useLocaleState,
  useLocale,
  useLocales,
  useSetLocale,
  useTranslatable,
  getRecordForLocale,
  useTranslatableContext,
  useTranslate,
  BasenameContextProvider,
  AdminRouter,
  useRestoreScrollPosition,
  useTrackScrollPosition,
  RestoreScrollPosition,
  useBasename,
  useCreatePath,
  removeDoubleSlashes,
  ResourceContext,
  useResourceContext,
  RecordContext,
  RecordContextProvider,
  useRecordContext,
  useGetPathForRecord,
  ResourceDefinitionContext,
  ResourceDefinitionContextProvider,
  useResourceDefinitionContext,
  useResourceDefinitions,
  useCanAccessCallback,
  useGetPathForRecordCallback,
  useRedirect,
  useResetErrorBoundaryOnLocationChange,
  useScrollToTop,
  TestMemoryRouter,
  useSplatPathBase,
  GET_LIST,
  GET_ONE,
  GET_MANY,
  GET_MANY_REFERENCE,
  CREATE,
  UPDATE,
  UPDATE_MANY,
  DELETE,
  DELETE_MANY,
  fetchActionsWithRecordResponse,
  fetchActionsWithArrayOfIdentifiedRecordsResponse,
  fetchActionsWithArrayOfRecordsResponse,
  fetchActionsWithTotalResponse,
  reactAdminFetchActions,
  sanitizeFetchType,
  defaultDataProvider,
  convertLegacyDataProvider_default,
  DataProviderContext_default,
  HttpError_default,
  require_query_string,
  fetch_exports,
  undoableEventEmitter_default,
  combineDataProviders,
  testDataProvider,
  withLifecycleCallbacks,
  applyCallbacks,
  useLogoutIfAccessDenied_default,
  useDataProvider,
  useIsDataLoaded,
  useLoading,
  useRefresh,
  useGetOne,
  useGetList,
  useGetMany,
  require_union,
  useGetManyAggregate,
  useGetManyReference,
  useFilterState_default,
  shallowEqual,
  removeEmpty_default,
  removeKey_default,
  SET_SORT,
  SORT_ASC,
  SORT_DESC,
  SET_PAGE,
  SET_PER_PAGE,
  SET_FILTER,
  SHOW_FILTER,
  HIDE_FILTER,
  queryReducer,
  useSortState_default,
  usePaginationState_default,
  useCheckMinimumRequiredProps,
  useDeleteWithUndoController_default,
  useDeleteWithConfirmController_default,
  SaveContext,
  SaveContextProvider,
  require_basePickBy,
  usePickSaveContext,
  useSaveContext,
  useMutationMiddlewares,
  useRegisterMutationMiddleware,
  useCreateController,
  CreateContext,
  CreateContextProvider,
  CreateBase,
  CreateController,
  useCreateContext,
  useEditController,
  WithRecord,
  OptionalRecordContextProvider,
  RecordRepresentation,
  EditContext,
  EditContextProvider,
  EditBase,
  EditController,
  useEditContext,
  ReferenceFieldContext,
  ReferenceFieldContextProvider,
  useReferenceFieldContext,
  useReference,
  useReferenceFieldController,
  ReferenceFieldBase,
  downloadCSV,
  defaultExporter,
  ExporterContext,
  fetchRelatedRecords,
  useRecordSelection,
  useSafeSetState,
  usePrevious,
  useDeepCompareEffect,
  useTimeout,
  useIsMounted,
  useListParams,
  parseQueryFromLocation,
  hasCustomParams,
  getQuery,
  getNumberOrDefault,
  useSelectAll,
  useInfiniteListController,
  ListContext,
  ListFilterContext,
  usePickFilterContext,
  ListSortContext,
  usePickSortContext,
  ListPaginationContext,
  usePickPaginationContext,
  ListContextProvider,
  InfinitePaginationContext,
  InfiniteListBase,
  useListController,
  injectedProps,
  getListControllerProps,
  sanitizeListRestProps,
  ListBase,
  ListController,
  useExpanded,
  useExpandAll,
  useInfinitePaginationContext,
  useList,
  useListContext,
  require_defaults,
  useListContextWithProps,
  useListFilterContext,
  useListPaginationContext,
  useListSortContext,
  useUnselect,
  useUnselectAll,
  WithListContext,
  useReferenceArrayFieldController,
  useReferenceManyFieldController,
  useReferenceOneFieldController,
  getStatusForInput,
  getSelectedReferencesStatus,
  getStatusForArrayInput,
  useFormContext,
  useFormState,
  useFieldArray,
  useReferenceArrayInputController,
  useReferenceInputController,
  ChoicesContext,
  ChoicesContextProvider,
  useChoicesContext,
  useChoices,
  FormGroupsProvider,
  useWarnWhenUnsavedChanges,
  WarnWhenUnsavedChanges,
  getSimpleValidationResolver,
  setSubmissionErrors,
  useNotifyIsFormInvalid,
  useRecordFromLocation,
  getRecordFromLocation,
  useAugmentedForm,
  Form,
  FormDataConsumer,
  FormDataConsumerView,
  FormGroupContext,
  useFormGroups,
  FormGroupContextProvider,
  useFormGroup,
  getFormGroupState,
  useFormGroupContext,
  useApplyInputDefaultValues,
  useGetValidationErrorMessage,
  isEmpty2 as isEmpty,
  combine2Validators,
  composeValidators,
  composeSyncValidators,
  required,
  minLength,
  maxLength,
  minValue,
  maxValue,
  number,
  regex,
  email,
  choices,
  isRequired,
  useUnique,
  ValidationError,
  useInput,
  useSuggestions,
  getSuggestionsFactory,
  FilterLiveForm,
  getFilterFormValues,
  ReferenceInputBase,
  useShowController,
  ShowContext,
  ShowContextProvider,
  ShowBase,
  ShowController,
  useShowContext,
  usePrevNextController,
  useGetRecordId,
  useCreate,
  AddUndoableMutationContext,
  useAddUndoableMutation,
  useUpdate,
  useUpdateMany,
  useDelete,
  useDeleteMany,
  useInfiniteGetList,
  TakeUndoableMutationContext,
  UndoableMutationsContextProvider,
  useTakeUndoableMutation,
  PreferencesEditorContext,
  PreferencesEditorContextProvider,
  CoreAdminContext,
  ErrorBoundary,
  usePermissions_default,
  HasDashboardContext,
  HasDashboardContextProvider,
  useHasDashboard,
  useCanAccessResources,
  useFirstResourceWithListAccess,
  NavigateToFirstResource,
  CoreAdminRoutes,
  DefaultTitleContext,
  DefaultTitleContextProvider,
  useDefaultTitle,
  CoreAdminUI,
  CoreAdmin,
  CustomRoutes,
  ResourceContextProvider,
  OptionalResourceContextProvider,
  Resource,
  SourceContext,
  SourceContextProvider,
  useSourceContext,
  useOptionalSourceContext,
  require_inflection,
  useGetResourceLabel,
  useResourceDefinition,
  useGetRecordRepresentation,
  useWrappedSource,
  useTranslateLabel,
  DEFAULT_LOCALE,
  FieldTitle_default,
  Ready_default,
  warning_default,
  useWhyDidYouUpdate,
  getMutationMode,
  getFieldLabelTranslationArgs,
  getResourceFieldLabelKey,
  mergeRefs,
  useEvent,
  useDebouncedEvent,
  useFieldValue,
  asyncDebounce,
  useCheckForApplicationUpdate,
  useStore,
  useRemoveFromStore,
  useRemoveItemsFromStore,
  useResetStore,
  useLogout_default,
  useAuthState_default,
  useAuthenticated,
  WithPermissions_default,
  useLogin_default,
  useGetPermissions_default,
  AUTH_LOGIN,
  AUTH_CHECK,
  AUTH_ERROR,
  AUTH_LOGOUT,
  AUTH_GET_PERMISSIONS,
  convertLegacyAuthProvider_default,
  Authenticated,
  useCanAccess,
  CanAccess,
  LogoutOnMount,
  useCheckAuth,
  useGetIdentity,
  useHandleAuthCallback,
  PreviousLocationStorageKey,
  useIsAuthPending,
  useRequireAccess,
  addRefreshAuthToAuthProvider,
  addRefreshAuthToDataProvider,
  PreferenceKeyContext,
  PreferenceKeyContextProvider,
  usePreferenceKey,
  usePreference,
  usePreferencesEditor,
  usePreferenceInput,
  useSetInspectorTitle,
  getValuesFromRecords_default,
  InferredElement_default,
  getElementsFromRecords_default,
  InferenceTypes,
  inferTypeFromValues,
  I18N_TRANSLATE,
  I18N_CHANGE_LOCALE
};
/*! Bundled license information:

inflection/lib/inflection.js:
  (*!
   * inflection
   * Copyright(c) 2011 Ben Lin <ben@dreamerslab.com>
   * MIT Licensed
   *
   * @fileoverview
   * A port of inflection-js to node.js module.
   *)
*/
//# sourceMappingURL=chunk-AHUOQRIT.js.map
